// ****************************************************************************
//         (c) Copyright, Real-Time Innovations, All rights reserved.
//
//         Permission to modify and use for internal purposes granted.
// This software is provided "as is", without warranty, express or implied.
//
// ****************************************************************************

package com.rti.routingservice.adapter.jms;

import java.util.List;
import java.util.Properties;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageConsumer;
import javax.jms.MessageListener;
import com.rti.dds.dynamicdata.DynamicData;
import com.rti.dds.infrastructure.BadKind;
import com.rti.dds.infrastructure.Bounds;
import com.rti.dds.subscription.SampleInfo;
import com.rti.dds.typecode.TypeCode;
import com.rti.routingservice.adapter.StreamReader;
import com.rti.routingservice.adapter.StreamReaderListener;
import com.rti.routingservice.adapter.infrastructure.AdapterException;
import com.rti.routingservice.adapter.infrastructure.StreamInfo;

/**
 * The JMSAdapterStreamReader class implements the StreamReader interface to
 * create a JMS MessageConsumer to receive JMS Messages, translate them to DDS
 * Samples, and deliver them to the Routing Service.
 *
 * Because a DynamicData Sample received by a StreamWriter was sent from a
 * DynamicData Producer and already received by a DynamicData Consumer (for
 * example, a DDS Publisher and a DDS Subscriber), and the StreamWriter sends
 * the Sample translated to the configured JMS Destination; any StreamReader
 * receiving JMS Messages from that same JMS Destination will translate the
 * JMS Message back again to a DynamicData Sample and send it to its
 * configured DynamicData Destination and received by a DynamicData Consumer
 * for that Destination (for example, a DDS Topic and a DDS Subscriber), the
 * DynamicData Consumer (in this case, the DDS Subscriber) will receive the
 * sample twice: one from the DynamicData Producer and one more from the
 * StreamReader receiving an "echo" of the translated Sample generated by the
 * StreamWriter. To avoid receiving the "echo" Sample in the DynamicData
 * Consumers, the StreamWriter sends its JMS Messages with a JMS Property with
 * the name specified in JMSAdapter.GENERATED_BY_JMS_ADAPTER_ROUTING_GROUP,
 * with the value set to the Routing Group Name configured for the Connection
 * that contains the StreamWriter. When this StreamReader receives a JMS
 * Message, it checks if the Message contains the JMS Property named
 * JMSAdapter.GENERATED_BY_JMS_ADAPTER_ROUTING_GROUP. If the JMS Property is
 * found, its value is compared to the Routing Group Name configured for the
 * Connection that contains this StreamReader. If the names are the same, that
 * is, the StreamWriter and StreamReader belong to the same Routing Group in a
 * Connection, the JMS Message is discarded by this StreamReader; and the
 * "echo" Message is not translated and sent again to DynamicData Destination.
 *
 * The Translation class used in this StreamReader can be configured in the
 * Routing Service configuration file, in the Property section of this
 * StreamReader's input configuration section with the name
 * JMSDynamicDataTranslator. The Translation class must implement the
 * com.rti.routingservice.adapter.jms.JMSToDynamicDataMessageTranslation interface.
 */
public class JMSAdapterStreamReader implements StreamReader {
    /**
     * The JMSAdapterStreamReaderErrors enum contains error codes and their
     * description. It also creates new AdapterException exceptions to be
     * thrown with the error code, description, and cause. This enum class
     * can't be instantiated. Use its methods only through the enum values.
     */
    private enum JMSAdapterStreamReaderErrors {
        // JMSAdapterStreamReaderErrors enumeration values
        INVALID_STREAMREADERLISTENER
            ("Invalid (null) StreamReaderListener provided to StreamReader."),
        READER_TYPECODE_NOT_FOUND
            ("DynamicData TypeCode not found in StreamReader's StreamInfo."),
        ERROR_CREATING_TRANSLATION_INSTANCE
            ("Could not create Translation class instance for StreamReader"),
        ERROR_SETTING_MESSAGE_LISTENER
            ("Error assigning JMS MessageListener to StreamReader"),
        ERROR_TRANSLATING_JMS_MESSAGE
            ("Error translating JMS Message to DynamicData in StreamReader"),
        REMOTE_ADMINISTRATION_NOT_SUPPORTED
            ("Remote Administration not supported in JMSAdapter. Modify " +
             "source code to support it.");

        /** Error Message */
        private final String _errorMessage;

        /**
         * Constructor. Assign enumeration field.
         *
         * @param message   Error message.
         */
        private JMSAdapterStreamReaderErrors(String message) {
            this._errorMessage = message;
        }

        /**
         * This method returns a new AdapterException with this instance's error
         * information.
         *
         * @returns An AdapterException with the error information
         */
        private AdapterException createAdapterException() {
            return new AdapterException(this.ordinal(), this._errorMessage);
        }

        /**
         * This method returns a new AdapterException with this instance's error
         * information and the information of the Throwable that caused it.
         *
         * @param originalException The Throwable that caused the error.
         *
         * @returns An AdapterException with the error information
         */
        private AdapterException createAdapterException(
                                                Throwable originalException) {
            return new AdapterException(this.ordinal(), this._errorMessage +
                                        " (caused by " +
                                        originalException.getMessage() + ")",
                                        originalException);
        }
    }

    /**
     * The DynamicDataSample class is a helper class to group a DynamicData
     * with its corresponding SampleInfo in one object.
     */
    private class DynamicDataSample {
        private final DynamicData _dynamicData;
        private final SampleInfo _sampleInfo;

        /**
         * Constructor. Initializes DynamicDataSample.
         *
         * @param dynamicData   The DynamicData object belonging to this
         *                      sample.
         * @param sampleInfo    The SampleInfo object belonging to this
         *                      sample.
         */
        private DynamicDataSample(DynamicData dynamicData,
                                  SampleInfo sampleInfo) {
            _dynamicData = dynamicData;
            _sampleInfo = sampleInfo;
        }
    }

    /**
     * The JMSAdapterMessageListener class implements the JMS MessageListener
     * interface to receive JMS messages asynchronously.
     */
    private class JMSAdapterMessageListener implements MessageListener {
        /**
         * The one and only method of a JMS MessageListener. It gets called
         * when a JMS Message arrives. If a Message is received, it is added
         * to this JMSAdapterMessageListener's JMSAdapterStreamReader.
         *
         * @param message    Message received from JMS
         */
        public void onMessage(Message message) {
            // Is not a valid message, like a timeout?
            if (message == null) {
                // Exit
                return;
            }

            try {
                // Add new JMS Message
                addNewJMSMessage(message);
            } catch (Exception messageException) {
                // Report exception to Routing Service
                addNewException(messageException);
            }
        }
    }

    /** Initial DynamicDataSamples to be allocated in sample queue */
    private static final int STREAMREADER_INITIAL_SAMPLES = 10;
    /** Increment DynamicDataSamples to be allocated in sample queue */
    private static final int STREAMREADER_INCREMENT_SAMPLES = 5;
    /** Property Name that defines the class to use to translate messages */
    private static final String JMS_TO_DYNAMICDATA_TRANSLATOR_CLASS_ELEMENT =
                                                   "JMSDynamicDataTranslator";
    /** Default translation interface implementation class */
    private static final String DEFAULT_JMS_TO_DYNAMICDATA_TRANSLATOR_CLASS =
           "com.rti.routingservice.adapter.jms.JMSAdapterJMSToDynamicDataTranslation";
    /** StreamReader's connection routing service group name */
    private final String _streamReaderRoutingGroupName;
    /** StreamReader's Stream TypeCode */
    private final TypeCode _streamReaderTypeCode;
    /** StreamReader's properties */
    private final Properties _streamReaderProperties;
    /** StreamReaderListener instance for new sample notifications */
    private final StreamReaderListener _streamReaderListener;
    /** StreamReader's JMS to DynamicData translator implementation */
    private final JMSToDynamicDataMessageTranslation
                                        _streamReaderJMSDynamicDataTranslator;
    /** JMS MessageConsumer's Listener */
    private final JMSAdapterMessageListener _jmsConsumerMessageListener;
    /**  JMS MessageConsumer */
    private final MessageConsumer _jmsConsumer;

    private final Object _queueLock = new Object();

    // The JMSAdapterStreamReader class is implemented to receive JMS Messages
    // asynchronously. When a JMS Message is received, it is translated to a
    // DynamicData Sample and the Routing Service is notified that there is
    // new data available. Because more JMS Messages can arrive between the
    // moment that the Routing Service is notified about new data and the
    // moment that the Routing Service calls the StreamReader's read method to
    // retrieve the new translated DynamicData Samples, all new translated
    // DynamicData Samples must be enqueued. To improve performance and avoid
    // thread conflicts, the following queuing pattern is used:
    // To avoid allocating and deallocating DynamicData Samples every time a
    // new message is received, a batch of available DynamicData Samples is
    // created in the class constructor and placed in the Available Queue.
    // When a new JMS Message arrives, the addNewJMSMessage method is called
    // to process it. This method polls a DynamicData Sample from the
    // Available Queue and it is used to store the translated JMS Message. If
    // there are no DynamicData Samples in the Available Queue, more Samples
    // are allocated and added to the Available Queue. This new allocations
    // occur rarely, thus performance is optimized. When the translated JMS
    // Message is placed in the available DynamicData Sample, this sample is
    // no longer available, and it's placed in a synchronized block in the
    // Received Queue, and the Routing Service is notified that new data is
    // available. The result is that this method can be called regardless of
    // the Routing Service having or not read the received data.
    // If an exception occurs in the translation process, the addNewException
    // method is called, and the Exception is added to the Exceptions Queue.
    // When the Routing Service calls the read method to get new data, the
    // readDynamicDataSampleQueue method is called. This method first checks
    // the Exceptions Queue. If an exception is found, it is thrown to the
    // Routing Service, and the Routing Service is notified to read again if
    // there are more Exceptions/Samples received. If no exceptions are
    // pending, a Read Queue is used to return all received data to the
    // Routing Service. The Read Queue is created in the class constructor to
    // avoid unnecessary queue allocations every time the Routing Service
    // reads data. The Read Queue is always empty when the Routing Service
    // calls the read method. This way, the Received and Read Queues are
    // swapped in a synchronized block, resulting in the Read Queue containing
    // all received data, and the Received Queue being empty, ready to receive
    // new data.
    // When the Read Queue is available in the read method, every DynamicData
    // Sample is polled from the Read Queue, added to the Routing Service's
    // DynamicData and SampleInfo Lists, and added to the Loaned Queue,
    // leaving the Read Queue empty.
    // When the Routing Service calls the returnLoan method, the
    // setAvailableDynamicDataSamples method is called to transfer all Samples
    // in the Loaned Queue to the Available Queue, since the Routing Service
    // no longer needs them. The result is that the Loaned Queue is empty and
    // ready to be used again by another read method call, and the loaned
    // DynamicData Samples are again Available to be reused.
    /** StreamReader's DynamicDataSamples Available Queue */
    private final Queue<DynamicDataSample>
                                 _streamReaderAvailableDynamicDataSampleQueue;
    /** StreamReader's DynamicDataSample Received Queue */
    private Queue<DynamicDataSample>
                                  _streamReaderReceivedDynamicDataSampleQueue;
    /** StreamReader's DynamicDataSamples Read Queue */
    private Queue<DynamicDataSample> _streamReaderReadDynamicDataSampleQueue;
    /** StreamReader's DynamicDataSamples Loaned Queue */
    private final Queue<DynamicDataSample>
                                    _streamReaderLoanedDynamicDataSampleQueue;
    /** StreamReader's Queue of Exceptions on message translation */
    private final Queue<Exception> _streamReaderExceptionQueue;

    /**
     * Constructor. Initializes members.
     *
     * @param jmsConsumer       StreamReader's JMS Message Consumer.
     * @param routingGroupName  The Routing Group Name of the Connection that
     *                          contains this StreamReader.
     * @param listener          StreamReader's StreamReaderListener.
     * @param streamInfo        StreamReader's StreamInfo.
     * @param properties        StreamReader's properties.
     *
     * @throws AdapterException If the StreamReader's TypeCode is not valid.
     */
    JMSAdapterStreamReader(MessageConsumer jmsConsumer,
                           String routingGroupName,
                           StreamReaderListener listener,
                           StreamInfo streamInfo,
                           Properties properties) throws AdapterException {
        // Assign JMS MessageConsumer and Routing Group Name
        _jmsConsumer = jmsConsumer;
        _streamReaderRoutingGroupName = routingGroupName;

        // StreamReaderListener exists?
        if (listener == null) {
            // Notify failure
            throw JMSAdapterStreamReaderErrors.INVALID_STREAMREADERLISTENER.
                                                     createAdapterException();
        }

        // Set StreamReaderListener
        _streamReaderListener = listener;
        // Create local copies of parameters so we don't depend on them
        _streamReaderProperties = new Properties();
        _streamReaderProperties.putAll(properties);

        // Get TypeCode
        _streamReaderTypeCode = (TypeCode) (streamInfo.getTypeInfo().
                                                     getTypeRepresentation());

        // TypeCode provided?
        if (_streamReaderTypeCode == null) {
            // Notify failure
            throw JMSAdapterStreamReaderErrors.READER_TYPECODE_NOT_FOUND.
                                                     createAdapterException();
        }

        // Create a Translator instance. Check if it was configured.
        String translatorClassName = _streamReaderProperties.getProperty(
                                 JMS_TO_DYNAMICDATA_TRANSLATOR_CLASS_ELEMENT);

        // Translator not configured?
        if (translatorClassName == null) {
            // Use default translator implementation
            translatorClassName = DEFAULT_JMS_TO_DYNAMICDATA_TRANSLATOR_CLASS;
        }

        try {
            // Load and instantiate translation class
            _streamReaderJMSDynamicDataTranslator =
                                          (JMSToDynamicDataMessageTranslation)
                                            Class.forName(translatorClassName,
                                                          true,
                                                          ClassLoader.
                                                      getSystemClassLoader()).
                                                                newInstance();
        } catch (Exception translatorException) {
            // Notify failure
            throw JMSAdapterStreamReaderErrors.
                                          ERROR_CREATING_TRANSLATION_INSTANCE.
                                  createAdapterException(translatorException);
        }

        // Create DynamicDataSample queues
        _streamReaderReadDynamicDataSampleQueue =
                               new ConcurrentLinkedQueue<DynamicDataSample>();
        _streamReaderReceivedDynamicDataSampleQueue =
                               new ConcurrentLinkedQueue<DynamicDataSample>();
        _streamReaderAvailableDynamicDataSampleQueue =
                               new ConcurrentLinkedQueue<DynamicDataSample>();
        _streamReaderLoanedDynamicDataSampleQueue =
                               new ConcurrentLinkedQueue<DynamicDataSample>();

        // Allocate initial DynamicDataSamples
        addNewAvailableDynamicDataSamples(STREAMREADER_INITIAL_SAMPLES);

        // Create Exception queue
        _streamReaderExceptionQueue = new ConcurrentLinkedQueue<Exception>();

        // Create and assign the Consumer's JMS MessageListener to receive JMS
        // Messages asynchronously
        _jmsConsumerMessageListener = new JMSAdapterMessageListener();

        try {
            _jmsConsumer.setMessageListener(_jmsConsumerMessageListener);
        } catch (JMSException jmsException) {
            // Notify failure
            throw JMSAdapterStreamReaderErrors.ERROR_SETTING_MESSAGE_LISTENER.
                                         createAdapterException(jmsException);
        }
    }

    /**
     * This method is invoked by the Routing Service to get any new available
     * data in this StreamReader and a "loan" to them.
     *
     * @param sampleList        List that will hold the output samples.
     * @param infoList          List that will hold the output sample infos.
     *
     * @throws AdapterException	If data couldn't be read.
     *
     */
    public void read(List<Object> sampleList, List<Object> infoList)
                                                     throws AdapterException {
        // Get all DynamicDataSamples received and empty the queue
        try {
            readDynamicDataSampleQueue();
        } catch (Exception pendingException) {
            // Notify failure
            throw JMSAdapterStreamReaderErrors.ERROR_TRANSLATING_JMS_MESSAGE.
                                     createAdapterException(pendingException);
        }

        // Get all DynamicDataSamples in the read queue
        while (!_streamReaderReadDynamicDataSampleQueue.isEmpty()) {
            // Get oldest sample available
            DynamicDataSample dynamicDataSample =
                               _streamReaderReadDynamicDataSampleQueue.poll();
            // Add sample data and info to the lists
            sampleList.add(dynamicDataSample._dynamicData);
            infoList.add(dynamicDataSample._sampleInfo);
            // It's been loaned; add it to the loaned queue
            _streamReaderLoanedDynamicDataSampleQueue.
                                                     offer(dynamicDataSample);
        }
    }

    /**
     * This method is invoked by the Routing Service to return the "loan"
     * granted when the Routing Service invoked the read method.
     *
     * @param sampleList        List of samples.
     * @param infoList          List of sample infos.
     *
     * @throws AdapterException	If loan couldn't be returned.
     *
     */
    public void returnLoan(List<Object> sampleList, List<Object> infoList)
                                                     throws AdapterException {
        // Free lists
        sampleList.clear();
        sampleList = null;
        infoList.clear();
        infoList = null;

        // All loaned DynamicDataSamples become available
        setAvailableDynamicDataSamples(
                                   _streamReaderLoanedDynamicDataSampleQueue);
    }

    /**
     * This method is invoked by the Routing Service to set new properties to
     * this object. This is a result of remote administration.
     *
     * @param properties        New properties.
     *
     * @throws AdapterException If the properties couldn't be changed.
     *
     */
    public void update(Properties properties) throws AdapterException {
        // Remote Administration not supported in this implementation
        throw JMSAdapterStreamReaderErrors
                                         .REMOTE_ADMINISTRATION_NOT_SUPPORTED.
                                                     createAdapterException();
    }

    /**
     * This method attempts to release the existing JMS MessageConsumer.
     *
     * @throws JMSException If a StreamReader could not be closed.
     */
    void close() throws JMSException {
        try {
            // Close MessageConsumer
            _jmsConsumer.close();
        } finally {
            // Release queues and properties
            _streamReaderProperties.clear();
            _streamReaderLoanedDynamicDataSampleQueue.clear();
            _streamReaderAvailableDynamicDataSampleQueue.clear();
            _streamReaderReceivedDynamicDataSampleQueue.clear();
            _streamReaderReceivedDynamicDataSampleQueue = null;
            _streamReaderReadDynamicDataSampleQueue.clear();
            _streamReaderReadDynamicDataSampleQueue = null;
        }
    }

    /**
     * This method gets a DynamicDataSample instance from the available queue.
     * If the available queue is empty, new DynamicDataSamples are allocated
     * and added to the available queue in order to guarantee that an
     * available DynamicDataSample instance is returned. The returned instance
     * is removed from the available queue.
     *
     * @returns A DynamicDataSample available to be used.
     */
    private DynamicDataSample getAvailableDynamicDataSample() {
        // No instances available? Add new ones
        if (_streamReaderAvailableDynamicDataSampleQueue.isEmpty()) {
            addNewAvailableDynamicDataSamples(STREAMREADER_INCREMENT_SAMPLES);
        }

        // Get an available DynamicDataSample instance
        DynamicDataSample dynamicDataSample =
                          _streamReaderAvailableDynamicDataSampleQueue.poll();

        // Clear previous data
        dynamicDataSample._dynamicData.clear_all_members();

        // DynamicDataSample instance is ready to be used
        return dynamicDataSample;
    }

    /**
     * This method transfers existing DynamicDataSample instances from the
     * given queue to the available queue.
     *
     * @param queueToEmpty  The DynamicDataSample Queue to empty and make its
     *                      samples available for future use.
     */
    private void setAvailableDynamicDataSamples(
                                      Queue<DynamicDataSample> queueToEmpty) {
        // Transfer all DynamicDataSamples
        while (queueToEmpty.size() > 0) {
            _streamReaderAvailableDynamicDataSampleQueue.offer(
                                                         queueToEmpty.poll());
        }
    }

    /**
     * This method allocates the desired number of DynamicDataSamples and
     * places them in the DynamicDataSample available queue.
     *
     * @param numberOfSamples   Number of DynamicDataSamples to be allocated.
     */
    private void addNewAvailableDynamicDataSamples(int numberOfSamples) {
        // Create desired DynamicDataSamples
        for (int numberOfAllocatedSamples = 0;
             numberOfAllocatedSamples < numberOfSamples;
             numberOfAllocatedSamples++) {
            // Create new sample data
            DynamicData sampleData = new DynamicData(_streamReaderTypeCode,
                                                DynamicData.PROPERTY_DEFAULT);
            // Create new sample info
            SampleInfo sampleInfo = new SampleInfo();
            // Create new sample
            DynamicDataSample dynamicDataSample =
                                new DynamicDataSample(sampleData, sampleInfo);
            // Add new available DynamicDataSample
            _streamReaderAvailableDynamicDataSampleQueue.offer(
                                                           dynamicDataSample);
        }
    }

    /**
     * This method adds a new JMS Message to be delivered to the Routing
     * Service translated to DynamicDataSample. This method notifies the
     * Routing Service that new data is available.
     *
     * @param jmsMessage The received JMS Message to add.
     *
     * @throws IllegalArgumentException If a parameter is not valid.
     * @throws BadKind                  If a TypeCode exception occurred.
     * @throws Bounds                   If a TypeCode out-of-bounds occurred.
     * @throws RETCODE_ERROR            If a DynamicData exception occurred.
     * @throws JMSException             If a JMS exception occurred.
     */
    private void addNewJMSMessage(Message jmsMessage) throws BadKind, Bounds,
                                                                JMSException {
        // Was this JMS Message created by a JMSAdapter StreamWriter?
        if (jmsMessage.propertyExists(
                         JMSAdapter.GENERATED_BY_JMS_ADAPTER_ROUTING_GROUP)) {
            // Was it generated in the same Routing Group as the StreamReader?
            if (_streamReaderRoutingGroupName.equals(
                                                 jmsMessage.getStringProperty(
                        JMSAdapter.GENERATED_BY_JMS_ADAPTER_ROUTING_GROUP))) {
                // Discard it to avoid publishing it again as DynamicData
                return;
            }
        }

        // Get an available DynamicDataSample instance
        DynamicDataSample dynamicDataSample = getAvailableDynamicDataSample();

        // Translate Message to DynamicData and SampleInfo
        _streamReaderJMSDynamicDataTranslator.
                                             translateJMSMessageToDynamicData(
                                               dynamicDataSample._dynamicData,
                                                dynamicDataSample._sampleInfo,
                                                                  jmsMessage);

        // This can occur when the received queue reference is being changed;
        // exclusive access
        synchronized (_queueLock) {
            // Add new DynamicDataSample to the received queue
            _streamReaderReceivedDynamicDataSampleQueue.offer(dynamicDataSample);
        }

        // Notify Routing Service
        _streamReaderListener.onDataAvailable(this);
    }

    /**
     * This method gets the current DynamicDataSamples received queue and sets
     * it to the DynamicDataSamples read queue, and the DynamicDataSamples
     * received queue is emptied. If an exception is pending to be reported to
     * the Routing Service, this method throws the pending exception and
     * notifies the Routing Service to read again if there are more pending
     * Exceptions/Samples.
     *
     * @throws Exception    If there is an exception in this StreamReader
     *                      pending to be reported to the Routing Service.
     */
    private void readDynamicDataSampleQueue() throws Exception {
        // If an exception is pending, throw it
        if (!_streamReaderExceptionQueue.isEmpty()) {
            // Get exception pending to be reported
            Exception pendingException = _streamReaderExceptionQueue.poll();

            // Are there more Samples/Exceptions to be read?
            if (!_streamReaderReceivedDynamicDataSampleQueue.isEmpty() ||
                !_streamReaderExceptionQueue.isEmpty()) {
                // Notify Routing Service
                _streamReaderListener.onDataAvailable(this);
            }

            // Throw pending exception
            throw pendingException;
        }

        // Get reference to empty read queue
        Queue<DynamicDataSample> emptyQueue =
                                      _streamReaderReadDynamicDataSampleQueue;

        // Get received queue and set it to read queue
        _streamReaderReadDynamicDataSampleQueue =
                                  _streamReaderReceivedDynamicDataSampleQueue;

        // We are changing the reference to received queue; exclusive access
        synchronized (_queueLock) {
            // Set received queue to empty queue
            _streamReaderReceivedDynamicDataSampleQueue = emptyQueue;
        }
    }

    /**
     * This method adds a new Exception occurred during message translation
     * to this StreamReader's exception queue. When the Routing Service reads
     * data, all exceptions will be thrown before any data is returned. This
     * method notifies the Routing Service that new data is available.
     *
     * @param exception The Exception to throw.
     */
    private void addNewException(Exception exception) {
        // Add exception to exception queue
        _streamReaderExceptionQueue.offer(exception);

        // Notify Routing Service about new data
        _streamReaderListener.onDataAvailable(this);
    }
}
