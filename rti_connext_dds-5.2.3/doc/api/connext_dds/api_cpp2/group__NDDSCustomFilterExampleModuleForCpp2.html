<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>RTI Connext Modern C++ API: Creating Custom Content Filters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RTI Connext Modern C++ API
   &#160;<span id="projectnumber">Version 5.2.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2-20120808 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__NDDSCustomFilterExampleModuleForCpp2.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Creating Custom Content Filters</div>  </div>
<div class="ingroups"><a class="el" href="group__DDSHowToModule.html">Programming How-To's</a></div></div><!--header-->
<div class="contents">

<p>Creating a custom content filter.  
<a href="#details">More...</a></p>
<p>Creating a custom content filter. </p>
<h1><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_intro"></a>
Introduction</h1>
<p>By default, RTI Connext creates content filters with the DDS_SQL_FILTER, which implements a superset of the DDS-specified SQL WHERE clause. However, in many cases this filter may not be what you want. Some examples are:</p>
<ul>
<li>The default filter can only filter based on the content of a sample, not on a computation on the content of a sample. You can use a custom filter that is customized for a specific type and can filter based on a computation of the type members.</li>
<li>You want to use a different filter language then SQL</li>
</ul>
<p>This HOWTO explains how to write your own custom filter and is divided into the following sections:</p>
<ul>
<li><a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_anatomy">The Custom Content Filter API</a></li>
<li><a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_example">Example Custom Writer Content Filter</a></li>
</ul>
<h1><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_anatomy"></a>
The Custom Content Filter API</h1>
<p>A custom content filter is created by calling the DomainParticipant::register_contentfilter function with a <a class="el" href="classrti_1_1topic_1_1CustomFilter.html" title="&lt;&lt;extension&gt;&gt; &lt;&lt;reference-type&gt;&gt; A wrapper class for the user-defined implementation of a ContentFilt...">rti::topic::CustomFilter</a>. A CustomFilter is created with either a <a class="el" href="classrti_1_1topic_1_1ContentFilter.html" title="&lt;&lt;extension&gt;&gt; A class to inherit from when implementing a custom content filter">rti::topic::ContentFilter</a> or <a class="el" href="classrti_1_1topic_1_1WriterContentFilter.html" title="&lt;&lt;extension&gt;&gt; A class to inherit from when implementing a writer-side custom content filter...">rti::topic::WriterContentFilter</a>.</p>
<p>A ContentFilter contains a <b>compile</b>, an <b>evaluate</b> and a <b>finalize</b> function.</p>
<p>A WriterContentFilter contains a <b>compile</b>, an <b>evaluate</b>, a <b>finalize</b>, a <b>writer_attach</b>, <b>writer_compile</b>, <b>writer_evaluate</b>, <b>wrtier_detach</b>, and <b>writer_finalize</b> functions.</p>
<p>A ContentFilteredTopic can be created with a <a class="el" href="classdds_1_1topic_1_1Filter.html" title="Defines the filter to create a ContentFilteredTopic.">dds::topic::Filter</a> that has been created with the name that is registered with the participant.</p>
<p>A custom ContentFilter is used by RTI Connext at the following times during the life-time of a ContentFilteredTopic (the function called is shown in parenthesis).</p>
<ul>
<li>When a ContentFilteredTopic is created (<a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_compile">compile</a>)</li>
<li>When the filter parameters are changed on the ContentFilteredTopic (<a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_compile">compile</a>)</li>
<li>When a sample is filtered (<a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_evaluate">evaluate</a>). This function is called by the RTI Connext core with a de-serialized sample</li>
<li>When a ContentFilteredTopic is deleted (<a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_finalize">finalize</a>)</li>
</ul>
<p>A custom WriterContentFilter is used by RTI Connext at the following times during the life-time of a ContentFilteredTopic (the function called is shown in parenthesis).</p>
<ul>
<li>When a DataWriter discovers a DataReader with a ContentFilteredTopic or when a DataWriter is notified of a change in the DataReader's filter parameter (<a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_writer_compile">writer_compile</a>)</li>
<li>When the DataWriter matches a DataReader using the specified filter for the first time (<a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_writer_attach">writer_attach</a>)</li>
<li>When a DataWriter writes a new sample (<a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_writer_evaluate">writer_evaluate</a>). This function is called by the RTI Connext core with a de-serialized sample</li>
<li>When RTI Connext is finished using the sequence of Cookies returned by writer_evaluate (<a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_writer_return_loan">writer_return_loan</a>)</li>
<li>When a DataWriter is no longer matching with a DataReader for which it was previously performing writer-side filtering (<a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_writer_finalize">writer_finalize</a>)</li>
</ul>
<h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_compile"></a>
The compile function</h2>
<p>The "compile" function is used to <b>compile</b> a filter expression and expression parameters. Please note that the term <b>compile</b> is intentionally loosely defined. It is up to the user to decide what this function should do and return.</p>
<h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_evaluate"></a>
The evaluate function</h2>
<p>When using a ContentFilter, the "evaluate" function is called each time a sample is received to determine if a sample should be filtered out and discarded.</p>
<p>When using a WriterContentFilter, the "evaluate" function is called each time a sample is written to determine if a sample should be filtered out and discarded. It is called for each DataReader for which the DataWriter is filtering and for which the writer_compile function set the ExpressionProperty.writer_side_filter_optimization to false.</p>
<h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_finalize"></a>
The finalize function</h2>
<p>The "finalize" function is called when an instance of the custom content filter is no longer needed. When this function is called, it is safe to free all resources used by this particular instance of the custom content filter.</p>
<h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_writer_attach"></a>
The writer_attach function</h2>
<p>The "writer_attach" function is called the first time that a DataWriter matches with a DataReader with the same ContentFilter. It will not be called for subsequent DataReaders that are using the same filter. This function is used to create some state required to perform filtering on the writer-side. It is entirely up to you, as the implementer of the filter, to decide if the filter requires this state.</p>
<h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_writer_compile"></a>
The writer_compile function</h2>
<p>The "writer_compile" function is called when a DataWriter matches with a DataReader with the same ContentFilter. It is called every time that the DataWriter matches a DataReader that is using the same filter as well as each time the DataWriter is notified that a DataReader's filter parameters have changed. This function will receive as an input a <a class="el" href="classrti_1_1core_1_1Cookie.html" title="Unique identifier for a written data sample in the form of a sequence of bytes.">rti::core::Cookie</a> which uniquely identifies the DataReader for which the function was invoked.</p>
<h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_writer_evaluate"></a>
The writer_evaluate function</h2>
<p>The "writer_evaluate" function is called every time that a DataWriter writes a new sample. Its purpose is to evaluate the sample for all the readers for which the DataWriter is performing writer-side filtering and return the sequence of <a class="el" href="classrti_1_1core_1_1Cookie.html" title="Unique identifier for a written data sample in the form of a sequence of bytes.">rti::core::Cookie</a> associated with the DataReaders whose filter pass the sample.</p>
<h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_writer_detach"></a>
The writer_detach function</h2>
<p>The "writer_detach" function is called when an instance of the custom content filter is no longer needed. When this function is called, it is safe to free all resources used by this particular instance of the custom content filter.</p>
<h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_writer_return_loan"></a>
The writer_return_loan function</h2>
<p>The "writer_return_loan" function is called to return the loan on the rti::core::CookieSeq provided by the writer_evaluate function.</p>
<h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_writer_finalize"></a>
The writer_finalize function</h2>
<p>The "writer_finalize" function will be called by Connext to notify the filter implementation that the DataWriter is no longer matching with a DataReader for which it was previously performing writer-side filtering. This will allow the filter to purge any state it was maintaining for the DataReader.</p>
<h1><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_example"></a>
Example Custom Writer Content Filter</h1>
<p>Assume that you have a type <a class="el" href="classFoo.html" title="A hypothetical topic-type.">Foo</a>.</p>
<p>Our filter will show how to enable the writer-side filter optimization for some readers and not for others. The ones with writer-side filter optimization will only pass samples where Foo.x == y where y is a value determined by an expression parameter, see the writer_evaluate function. Readers without the optimization turned on will pass all samples where Foo.x &gt; 7, see the evaluate function. The filter will <b>only</b> be used to filter samples of type <a class="el" href="classFoo.html" title="A hypothetical topic-type.">Foo</a>.</p>
<p>The following #includes are needed for the examples on this page </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;dds/topic/ddstopic.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;rti/topic/findImpl.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;dds/sub/ddssub.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;dds/pub/ddspub.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;dds/core/ddscore.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Foo.hpp&quot;</span></div>
</div><!-- fragment --><p> The following is the definition of the WriterFilterData, the state that is created and returned by the writer_attach method: </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>WriterFilterData</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>: </div>
<div class="line">    <span class="keyword">typedef</span> std::pair&lt;rti::core::Cookie, int32_t&gt; CookieValue;</div>
<div class="line">    <span class="keyword">typedef</span> std::vector&lt;CookieValue&gt; CookieValueSeq;</div>
<div class="line"><span class="keyword">public</span>: </div>
<div class="line">    WriterFilterData()</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> add_pair(<span class="keyword">const</span> CookieValue&amp; cookie_value_pair)</div>
<div class="line">    {</div>
<div class="line">        reader_pairs_.resize(reader_pairs_.size() + 1);</div>
<div class="line">        reader_pairs_[reader_pairs_.size() - 1] = cookie_value_pair;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    CookieValueSeq&amp; reader_pairs()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> reader_pairs_;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    CookieValueSeq reader_pairs_;</div>
<div class="line">};</div>
</div><!-- fragment --><p> And here is the declaration of our custom writer content filter. Notice, we are inheriting from <a class="el" href="classrti_1_1topic_1_1WriterContentFilter.html" title="&lt;&lt;extension&gt;&gt; A class to inherit from when implementing a writer-side custom content filter...">rti::topic::WriterContentFilter</a>. We could have inherited from <a class="el" href="classrti_1_1topic_1_1ContentFilter.html" title="&lt;&lt;extension&gt;&gt; A class to inherit from when implementing a custom content filter">rti::topic::ContentFilter</a> or <a class="el" href="classrti_1_1topic_1_1WriterContentFilterHelper.html" title="&lt;&lt;extension&gt;&gt; A class to inherit from when implementing a writer-side custom content filter...">rti::topic::WriterContentFilterHelper</a> here too to create other custom content filters.</p>
<div class="fragment"><div class="line"><span class="comment">// A custom WriterContentFilter</span></div>
<div class="line"><span class="keyword">class </span>ExampleWriterContentFilter : </div>
<div class="line">    <span class="keyword">public</span> <a class="code" href="classrti_1_1topic_1_1WriterContentFilter.html" title="&lt;&lt;extension&gt;&gt; A class to inherit from when implementing a writer-side custom content filter...">rti::topic::WriterContentFilter</a>&lt;</div>
<div class="line">    Foo, </div>
<div class="line">    rti::topic::no_compile_data_t, </div>
<div class="line">    WriterFilterData&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ExampleWriterContentFilter() {}</div>
<div class="line"></div>
<div class="line">    ~ExampleWriterContentFilter() {}</div>
<div class="line"></div>
<div class="line">    <a class="code" href="structrti_1_1topic_1_1no__compile__data__t.html" title="The type to specify as the CompileData template parameter to your ContentFilter if your compile funct...">rti::topic::no_compile_data_t</a>&amp; <a class="code" href="classrti_1_1topic_1_1ContentFilter.html#a3d61a7042a5c0d507dbec9738f311fdc" title="Compile an instance of the content filter according to the filter expression and parameters of the gi...">compile</a>(</div>
<div class="line">       <span class="keyword">const</span> <a class="code" href="group__DDSCPP2SupportingTypes.html#gad310659fde3bf0bf1bf71a0a50abbfa2" title="A string convertible to std::string and with similar functionality.">std::string</a>&amp; expression,</div>
<div class="line">       <span class="keyword">const</span> <a class="code" href="group__DDSCPP2SupportingTypes.html#gaf41924828eff7595b676d2196b993482" title="A vector of strings.">dds::core::StringSeq</a>&amp; parameters,</div>
<div class="line">       <span class="keyword">const</span> <a class="code" href="classdds_1_1core_1_1optional.html" title="&lt;&lt;value-type&gt;&gt; Represents an object that may not contain a valid value">dds::core::optional&lt;dds::core::xtypes::DynamicType&gt;</a>&amp; type_code,</div>
<div class="line">       <span class="keyword">const</span> <a class="code" href="group__DDSCPP2SupportingTypes.html#gad310659fde3bf0bf1bf71a0a50abbfa2" title="A string convertible to std::string and with similar functionality.">std::string</a>&amp; type_class_name,</div>
<div class="line">       <a class="code" href="structrti_1_1topic_1_1no__compile__data__t.html" title="The type to specify as the CompileData template parameter to your ContentFilter if your compile funct...">rti::topic::no_compile_data_t</a>* old_compile_data);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classrti_1_1topic_1_1ContentFilter.html#a08bcef6bc04b6df48d0aa4de15e92d55" title="Evaluate whether the sample is passing the filter or not according to the sample content.">evaluate</a>(</div>
<div class="line">       <a class="code" href="structrti_1_1topic_1_1no__compile__data__t.html" title="The type to specify as the CompileData template parameter to your ContentFilter if your compile funct...">rti::topic::no_compile_data_t</a>&amp; compile_data,</div>
<div class="line">       <span class="keyword">const</span> <a class="code" href="classFoo.html" title="A hypothetical topic-type.">Foo</a>&amp; sample,</div>
<div class="line">       <span class="keyword">const</span> <a class="code" href="classrti_1_1topic_1_1FilterSampleInfo.html" title="&lt;&lt;extension&gt;&gt; &lt;&lt;value-type&gt;&gt; Provides meta information associated with the sample.">rti::topic::FilterSampleInfo</a>&amp; meta_data);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classrti_1_1topic_1_1ContentFilter.html#a7804e6b317453ab1d968c03857f72f4d" title="A previously compiled instance of the content filter is no longer in use and resources can now be cle...">finalize</a>(<a class="code" href="structrti_1_1topic_1_1no__compile__data__t.html" title="The type to specify as the CompileData template parameter to your ContentFilter if your compile funct...">rti::topic::no_compile_data_t</a>&amp; compile_data);</div>
<div class="line"></div>
<div class="line">    WriterFilterData&amp; <a class="code" href="classrti_1_1topic_1_1WriterContentFilter.html#a4032a240dd5d2656ccec24bf0ceb4e98" title="A writer-side filtering API to create some state that can facilitate filtering on the writer side...">writer_attach</a>();</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classrti_1_1topic_1_1WriterContentFilter.html#a14ad1be1ae51de270149bf81291392de" title="A writer-side filtering API to compile an instance of the content filter according to the filter expr...">writer_compile</a>(</div>
<div class="line">        WriterFilterData&amp; writer_filter_data,</div>
<div class="line">        <a class="code" href="classrti_1_1topic_1_1ExpressionProperty.html" title="&lt;&lt;extension&gt;&gt; &lt;&lt;value-type&gt;&gt; Provides additional information about the filter expression passed to th...">rti::topic::ExpressionProperty</a>&amp; prop,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group__DDSCPP2SupportingTypes.html#gad310659fde3bf0bf1bf71a0a50abbfa2" title="A string convertible to std::string and with similar functionality.">std::string</a>&amp; expression,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group__DDSCPP2SupportingTypes.html#gaf41924828eff7595b676d2196b993482" title="A vector of strings.">dds::core::StringSeq</a>&amp; parameters,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classdds_1_1core_1_1optional.html" title="&lt;&lt;value-type&gt;&gt; Represents an object that may not contain a valid value">dds::core::optional&lt;dds::core::xtypes::DynamicType&gt;</a>&amp; type_code,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group__DDSCPP2SupportingTypes.html#gad310659fde3bf0bf1bf71a0a50abbfa2" title="A string convertible to std::string and with similar functionality.">std::string</a>&amp; type_class_name,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classrti_1_1core_1_1Cookie.html" title="Unique identifier for a written data sample in the form of a sequence of bytes.">rti::core::Cookie</a>&amp; cookie);</div>
<div class="line"></div>
<div class="line">    rti::core::CookieSeq&amp; <a class="code" href="classrti_1_1topic_1_1WriterContentFilter.html#a0011df4957aede420da3ad41a50869f1" title="A writer-side filtering API to compile an instance of the content filter according to the filter expr...">writer_evaluate</a>(</div>
<div class="line">       WriterFilterData&amp; writer_filter_data, </div>
<div class="line">       <span class="keyword">const</span> <a class="code" href="classFoo.html" title="A hypothetical topic-type.">Foo</a>&amp; sample,</div>
<div class="line">       <span class="keyword">const</span> <a class="code" href="classrti_1_1topic_1_1FilterSampleInfo.html" title="&lt;&lt;extension&gt;&gt; &lt;&lt;value-type&gt;&gt; Provides meta information associated with the sample.">rti::topic::FilterSampleInfo</a> &amp;meta_data);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classrti_1_1topic_1_1WriterContentFilter.html#a6b9655f5066bac7aed3ae3b4b1437547" title="A writer-side filtering API to clean up a previously compiled instance of the content filter...">writer_finalize</a>(</div>
<div class="line">        WriterFilterData&amp; writer_filter_data,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classrti_1_1core_1_1Cookie.html" title="Unique identifier for a written data sample in the form of a sequence of bytes.">rti::core::Cookie</a>&amp; cookie);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classrti_1_1topic_1_1WriterContentFilter.html#a1cd1af75d0500a11426301f53421f5a3" title="A writer-side filtering API to clean up a previously created state using writer_attach.">writer_detach</a>(WriterFilterData&amp; writer_filter_data);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classrti_1_1topic_1_1WriterContentFilter.html#a91629cd664ce36e2024f9a2244dfba65" title="A writer-side filtering API to return the loan on the list of DataReaders returned by writer_evaluate...">writer_return_loan</a>(</div>
<div class="line">        WriterFilterData&amp; writer_filter_data, rti::core::CookieSeq&amp; cookies);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> writer_data(<span class="keyword">const</span> WriterFilterData&amp; is_writer_data) { writer_data_ = is_writer_data; }</div>
<div class="line"></div>
<div class="line">    WriterFilterData&amp; writer_data() { <span class="keywordflow">return</span> writer_data_; } </div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> reset_cookie_seq()</div>
<div class="line">    {</div>
<div class="line">        cookie_seq_.resize(0);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> add_cookie(<a class="code" href="classrti_1_1core_1_1Cookie.html" title="Unique identifier for a written data sample in the form of a sequence of bytes.">rti::core::Cookie</a>&amp; cookie)</div>
<div class="line">    {</div>
<div class="line">        cookie_seq_.resize(cookie_seq_.size() + 1);</div>
<div class="line">        cookie_seq_[cookie_seq_.size() - 1] = cookie;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    rti::core::CookieSeq&amp; cookie_seq()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> cookie_seq_;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    rti::core::CookieSeq cookie_seq_;</div>
<div class="line">    WriterFilterData writer_data_;</div>
<div class="line">};</div>
</div><!-- fragment --> <h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_example_compile"></a>
Writing the Compile Function</h2>
<p>Since we already know what the expression is (Foo.x &gt; 7), we can simply return rti::topic::no_compile_data.</p>
<p>Below is the entire <a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_compile">compile</a> function.</p>
<div class="fragment"><div class="line"><a class="code" href="structrti_1_1topic_1_1no__compile__data__t.html" title="The type to specify as the CompileData template parameter to your ContentFilter if your compile funct...">rti::topic::no_compile_data_t</a>&amp; ExampleWriterContentFilter::compile(</div>
<div class="line">       <span class="keyword">const</span> <a class="code" href="group__DDSCPP2SupportingTypes.html#gad310659fde3bf0bf1bf71a0a50abbfa2" title="A string convertible to std::string and with similar functionality.">std::string</a>&amp;,</div>
<div class="line">       <span class="keyword">const</span> <a class="code" href="group__DDSCPP2SupportingTypes.html#gaf41924828eff7595b676d2196b993482" title="A vector of strings.">dds::core::StringSeq</a>&amp;,</div>
<div class="line">       <span class="keyword">const</span> <a class="code" href="classdds_1_1core_1_1optional.html" title="&lt;&lt;value-type&gt;&gt; Represents an object that may not contain a valid value">dds::core::optional&lt;dds::core::xtypes::DynamicType&gt;</a>&amp;,</div>
<div class="line">       <span class="keyword">const</span> <a class="code" href="group__DDSCPP2SupportingTypes.html#gad310659fde3bf0bf1bf71a0a50abbfa2" title="A string convertible to std::string and with similar functionality.">std::string</a>&amp;,</div>
<div class="line">       <a class="code" href="structrti_1_1topic_1_1no__compile__data__t.html" title="The type to specify as the CompileData template parameter to your ContentFilter if your compile funct...">rti::topic::no_compile_data_t</a>*)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// We don&#39;t have any compile data to setup in this compile function. We</span></div>
<div class="line">    <span class="comment">// will do all necessary setup in the writer_compile function</span></div>
<div class="line">    <span class="keywordflow">return</span> rti::topic::no_compile_data;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_example_evaluate"></a>
Writing the Evaluate Function</h2>
<p>The next step is to implement the <b>evaluate</b> function. The evaluate function receives no_compile_data because it is unecessary in this example. The function then evaluates the received sample against our filter expression and passes the sample if Foo.x &gt; 7. Below is the entire <a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_evaluate">evaluate</a> function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> ExampleWriterContentFilter::evaluate(</div>
<div class="line">   <a class="code" href="structrti_1_1topic_1_1no__compile__data__t.html" title="The type to specify as the CompileData template parameter to your ContentFilter if your compile funct...">rti::topic::no_compile_data_t</a>&amp;,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="classFoo.html" title="A hypothetical topic-type.">Foo</a>&amp; sample,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="classrti_1_1topic_1_1FilterSampleInfo.html" title="&lt;&lt;extension&gt;&gt; &lt;&lt;value-type&gt;&gt; Provides meta information associated with the sample.">rti::topic::FilterSampleInfo</a>&amp;)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (sample.x() &gt; 7) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    } </div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_example_finalize"></a>
Writing the Finalize Function</h2>
<p>The next function to write is the finalize function. It is safe to free all resources used by this particular instance of the custom content filter that is allocated in <b>compile</b>. Because we did not create any resources in the <b>compile</b> function, we have nothing to do in the <b>finalize</b>. Below is the entire <a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_finalize">finalize</a> function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ExampleWriterContentFilter::finalize(</div>
<div class="line">   <a class="code" href="structrti_1_1topic_1_1no__compile__data__t.html" title="The type to specify as the CompileData template parameter to your ContentFilter if your compile funct...">rti::topic::no_compile_data_t</a>&amp;)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// There is nothing to finalize in this example</span></div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_example_writer_attach"></a>
Writing the Writer Attach Function</h2>
<p>The <b>writer_attach</b> is used to create some state required to perform filtering on the writer-side. In our example filter, this state is kept as part of our custom filter class, ExampleWriterContentFilter, so we therefore simply return a reference to our writer data that will be used during the <b>writer_compile</b> and <b>writer_evaluate</b> functions.</p>
<div class="fragment"><div class="line">WriterFilterData&amp; ExampleWriterContentFilter::writer_attach()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Setup the writer_filter_data to point to our WriterFilterData</span></div>
<div class="line">    <span class="keywordflow">return</span> writer_data();</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_example_writer_compile"></a>
Writing the Writer Compile Function</h2>
<p>The <b>writer_compile</b> function is called when a DataWriter matches with a DataReader with the same ContentFilter. In our case, we use the parameters to determine if we should turn on the writer-side filtering optimization. If parameters[0] == 1, then we store the provided <a class="el" href="classrti_1_1core_1_1Cookie.html" title="Unique identifier for a written data sample in the form of a sequence of bytes.">rti::core::Cookie</a> along with parameters[1] in our writer_filter_data to be accessed during the writer_evaluate function whenever we receive a new sample.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ExampleWriterContentFilter::writer_compile(</div>
<div class="line">   WriterFilterData&amp; writer_filter_data,</div>
<div class="line">   <a class="code" href="classrti_1_1topic_1_1ExpressionProperty.html" title="&lt;&lt;extension&gt;&gt; &lt;&lt;value-type&gt;&gt; Provides additional information about the filter expression passed to th...">rti::topic::ExpressionProperty</a>&amp; prop,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="group__DDSCPP2SupportingTypes.html#gad310659fde3bf0bf1bf71a0a50abbfa2" title="A string convertible to std::string and with similar functionality.">std::string</a>&amp; <span class="comment">/* expression */</span>,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="group__DDSCPP2SupportingTypes.html#gaf41924828eff7595b676d2196b993482" title="A vector of strings.">dds::core::StringSeq</a>&amp; parameters,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="classdds_1_1core_1_1optional.html" title="&lt;&lt;value-type&gt;&gt; Represents an object that may not contain a valid value">dds::core::optional&lt;dds::core::xtypes::DynamicType&gt;</a>&amp; <span class="comment">/* type */</span>,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="group__DDSCPP2SupportingTypes.html#gad310659fde3bf0bf1bf71a0a50abbfa2" title="A string convertible to std::string and with similar functionality.">std::string</a>&amp; <span class="comment">/* type_class_name */</span>,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="classrti_1_1core_1_1Cookie.html" title="Unique identifier for a written data sample in the form of a sequence of bytes.">rti::core::Cookie</a>&amp; cookie)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> length = parameters.size();</div>
<div class="line">    <span class="keywordtype">bool</span> optimize = <span class="keyword">false</span>;</div>
<div class="line">    int32_t x = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (length == 2) {</div>
<div class="line">        std::istringstream(parameters[0]) &gt;&gt; optimize;</div>
<div class="line">        std::istringstream(parameters[1]) &gt;&gt; x;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Add this DataReader&#39;s cookie to our writer filter data</span></div>
<div class="line">    <span class="keywordflow">if</span> (optimize) {</div>
<div class="line">        writer_filter_data.add_pair(</div>
<div class="line">           std::pair&lt;rti::core::Cookie, int32_t&gt;(cookie, x));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    prop.<a class="code" href="classrti_1_1topic_1_1ExpressionProperty.html#ae133eeaa58ce74de8a45f06db4f5c3c5" title="Get the value of writer_side_filter_optimization.">writer_side_filter_optimization</a>(optimize);</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_example_writer_evaluate"></a>
Writing the Writer Evaluate Function</h2>
<p>The writer_evaluate function receives our stored writer_filter_data and a sample to evaluate. We iterate through our (<a class="el" href="classrti_1_1core_1_1Cookie.html" title="Unique identifier for a written data sample in the form of a sequence of bytes.">rti::core::Cookie</a>, value) pairs and add any Cookie with a matching value of x to the sample's Foo.x to the rti::core::CookieSeq that we return. Any Cookie in this sequence then represents a DataReader to which this sample will be sent.</p>
<div class="fragment"><div class="line">rti::core::CookieSeq&amp; ExampleWriterContentFilter::writer_evaluate(</div>
<div class="line">   WriterFilterData&amp; writer_filter_data, </div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="classFoo.html" title="A hypothetical topic-type.">Foo</a>&amp; sample,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="classrti_1_1topic_1_1FilterSampleInfo.html" title="&lt;&lt;extension&gt;&gt; &lt;&lt;value-type&gt;&gt; Provides meta information associated with the sample.">rti::topic::FilterSampleInfo</a>&amp;)</div>
<div class="line">{ </div>
<div class="line">    WriterFilterData::CookieValueSeq&amp; reader_pairs = </div>
<div class="line">           writer_filter_data.reader_pairs();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If x == value, pass the reader</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; reader_pairs.size(); i++) {</div>
<div class="line">        <span class="keywordflow">if</span> (sample.x() == reader_pairs[i].second) {</div>
<div class="line">            add_cookie(reader_pairs[i].first);</div>
<div class="line">        } </div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> cookie_seq();</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_example_writer_detach"></a>
Writing the Writer Detach Function</h2>
<p>It is safe to free all resources used by this particular instance of the custom content filter that is allocated in <b>writer_attach</b>. Because we did not allocate any resources in the <b>writer_attach</b> function, there is nothing to release in the writer_finalize. Below is the entire <a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_writer_detach">writer_detach</a> function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ExampleWriterContentFilter::writer_detach(</div>
<div class="line">   WriterFilterData&amp;)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Nothing to do in writer detach for this example</span></div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_example_writer_return_loan"></a>
Writing the Writer Return Loan Function</h2>
<p>RTI Connext uses the writer_return_loan function specified in the WriterContentFilter to indicate to the filter implementation that it has finished using the sequence of cookies returned by the filter’s writer_evaluate function. Your filter implementation should not free the memory associated with the cookie sequence before the writer_return_loan function is called. You can also create your custom content filter by inheriting from the <a class="el" href="classrti_1_1topic_1_1WriterContentFilterHelper.html" title="&lt;&lt;extension&gt;&gt; A class to inherit from when implementing a writer-side custom content filter...">rti::topic::WriterContentFilterHelper</a>, which manages the DataReader CookieSeq for you. If you do that, then the writer_return_loan is implemented for you. Below is the entire <a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_writer_return_loan">writer_return_loan</a> function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ExampleWriterContentFilter::writer_return_loan(</div>
<div class="line">    WriterFilterData&amp;,</div>
<div class="line">    rti::core::CookieSeq&amp;)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// The cookie sequence&#39;s destructor will take care of returning the loan</span></div>
<div class="line">    <span class="comment">// to the middleware, but we will reset the size to 0</span></div>
<div class="line">    <span class="keyword">const_cast&lt;</span>rti::core::CookieSeq&amp;<span class="keyword">&gt;</span>(cookie_seq()).resize(0);</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_example_writer_finalize"></a>
Writing the Writer Finalize Function</h2>
<p>The writer_finalize function specified in the WriterContentFilter will be called when the DataWriter no longer matches with a DataReader that was created with ContentFilteredTopic. This will allow the filter implementation to delete any state it was maintaining for the DataReader. Because we did not create any resources in the <b>writer_compile</b> function, we have nothing to do in the <b>writer_finalize</b>. Below is the entire <a class="el" href="group__NDDSCustomFilterExampleModuleForCpp2.html#NDDSCustomFilterExampleModuleForCpp2_writer_finalize">writer_finalize</a> function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ExampleWriterContentFilter::writer_finalize(</div>
<div class="line">   WriterFilterData&amp;,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="classrti_1_1core_1_1Cookie.html" title="Unique identifier for a written data sample in the form of a sequence of bytes.">rti::core::Cookie</a>&amp;)</div>
<div class="line">{ </div>
<div class="line">    <span class="comment">// There is nothing to finalize in this example</span></div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_create1"></a>
Creating a CustomFilter</h2>
<p>The first thing that an application needs to do when using a custom filter is to give it a name and wrap an instance of their custom filter with a <a class="el" href="classrti_1_1topic_1_1CustomFilter.html" title="&lt;&lt;extension&gt;&gt; &lt;&lt;reference-type&gt;&gt; A wrapper class for the user-defined implementation of a ContentFilt...">rti::topic::CustomFilter</a>. The CustomFilter class receives shared pointer to an instance of your custom filter and ensures that your filter does not go out-of-scope while it is being used. This means that you do not have to retain a reference to your filter throughout its lifetime, the CustomFilter class handles this detail for you.</p>
<div class="fragment"><div class="line">    <span class="comment">// Create an instance of the ExampleWriterContentFilter and then </span></div>
<div class="line">    <span class="comment">// create a CustomFilter object which holds a shared pointer to your </span></div>
<div class="line">    <span class="comment">// ContentFilter. </span></div>
<div class="line">    <a class="code" href="group__DDSCPP2SupportingTypes.html#gad310659fde3bf0bf1bf71a0a50abbfa2" title="A string convertible to std::string and with similar functionality.">std::string</a> my_filter_name = <span class="stringliteral">&quot;my_custom_filter&quot;</span>;</div>
<div class="line">    <a class="code" href="classrti_1_1topic_1_1CustomFilter.html" title="&lt;&lt;extension&gt;&gt; &lt;&lt;reference-type&gt;&gt; A wrapper class for the user-defined implementation of a ContentFilt...">rti::topic::CustomFilter&lt;ExampleWriterContentFilter&gt;</a> </div>
<div class="line">        my_custom_filter(<span class="keyword">new</span> ExampleWriterContentFilter());</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classdds_1_1domain_1_1DomainParticipant.html" title="&lt;&lt;reference-type&gt;&gt; Container for all dds::core::Entity objects.">dds::domain::DomainParticipant</a> participant1(0);</div>
<div class="line">    <a class="code" href="classdds_1_1domain_1_1DomainParticipant.html" title="&lt;&lt;reference-type&gt;&gt; Container for all dds::core::Entity objects.">dds::domain::DomainParticipant</a> participant2(0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// To make sure that we don&#39;t miss any samples in this example, </span></div>
<div class="line">    <span class="comment">// setup there DataWriter and DataReaders to be reliable</span></div>
<div class="line">    <a class="code" href="classdds_1_1pub_1_1qos_1_1DataWriterQos.html" title="&lt;&lt;value-type&gt;&gt; Container of the QoS policies that a dds::pub::DataWriter supports">dds::pub::qos::DataWriterQos</a> writer_qos; </div>
<div class="line">    writer_qos &lt;&lt; <a class="code" href="classdds_1_1core_1_1policy_1_1Reliability.html#aa68882d7648a4a3241ccc57ce15ef4ea" title="Creates a policy with ReliabilityKind::RELIABLE and optionally a max blocking time.">dds::core::policy::Reliability::Reliable</a>();</div>
<div class="line">    writer_qos &lt;&lt; <a class="code" href="classdds_1_1core_1_1policy_1_1Durability.html#a3c100040656eec03e13edb8d1ea5da5b" title="Creates a Durability instance with trasient-local kind.">dds::core::policy::Durability::TransientLocal</a>();</div>
<div class="line">    writer_qos &lt;&lt; <a class="code" href="classdds_1_1core_1_1policy_1_1History.html#abbb117f178a30e6753ba7e36998a471a" title="Creates a History with HistoryKind::KEEP_ALL.">dds::core::policy::History::KeepAll</a>();</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classdds_1_1sub_1_1qos_1_1DataReaderQos.html" title="&lt;&lt;value-type&gt;&gt; Container of the QoS policies that a dds::sub::DataReader supports">dds::sub::qos::DataReaderQos</a> reader_qos; </div>
<div class="line">    reader_qos &lt;&lt; <a class="code" href="classdds_1_1core_1_1policy_1_1Reliability.html#aa68882d7648a4a3241ccc57ce15ef4ea" title="Creates a policy with ReliabilityKind::RELIABLE and optionally a max blocking time.">dds::core::policy::Reliability::Reliable</a>();</div>
<div class="line">    reader_qos &lt;&lt; <a class="code" href="classdds_1_1core_1_1policy_1_1Durability.html#a3c100040656eec03e13edb8d1ea5da5b" title="Creates a Durability instance with trasient-local kind.">dds::core::policy::Durability::TransientLocal</a>();</div>
<div class="line">    reader_qos &lt;&lt; <a class="code" href="classdds_1_1core_1_1policy_1_1History.html#abbb117f178a30e6753ba7e36998a471a" title="Creates a History with HistoryKind::KEEP_ALL.">dds::core::policy::History::KeepAll</a>();</div>
</div><!-- fragment --> <h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_register"></a>
Registering the Filter</h2>
<p>After wrapping your content filter with the CustomFilter class, and before the custom filter can be used, it must be registered with RTI Connext:</p>
<div class="fragment"><div class="line">    <span class="comment">// Register the filter with both participants. Doing this will </span></div>
<div class="line">    <span class="comment">// automatically enable writer-side filtering if any DataWriters match with</span></div>
<div class="line">    <span class="comment">// any DataReaders that are using the same filter</span></div>
<div class="line">    participant1-&gt;<a class="code" href="classdds_1_1domain_1_1DomainParticipant.html#afa6a0ef035a5cbfd1ad7def24c11dd12" title="&lt;&lt;extension&gt;&gt; Register a content filter which can be used to create a dds::topic::ContentFilteredTopi...">register_contentfilter</a>(my_custom_filter, my_filter_name);</div>
<div class="line">    participant2-&gt;<a class="code" href="classdds_1_1domain_1_1DomainParticipant.html#afa6a0ef035a5cbfd1ad7def24c11dd12" title="&lt;&lt;extension&gt;&gt; Register a content filter which can be used to create a dds::topic::ContentFilteredTopi...">register_contentfilter</a>(my_custom_filter, my_filter_name);</div>
</div><!-- fragment --> <h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_unregister"></a>
Unregistering the Filter</h2>
<p>When the filter is no longer needed, it can be unregistered from RTI Connext:</p>
<div class="fragment"><div class="line">    <span class="comment">// You do not have to unregister your content filter unless you want to </span></div>
<div class="line">    <span class="comment">// register a different filter with the same name</span></div>
<div class="line">    participant1-&gt;<a class="code" href="classdds_1_1domain_1_1DomainParticipant.html#a94c43030edf18f03e9b6c79bd5ca9c4c" title="&lt;&lt;extension&gt;&gt; Unregister a content filter previously registered with dds::domain::DomainParticipant::...">unregister_contentfilter</a>(my_filter_name);</div>
<div class="line">    participant2-&gt;<a class="code" href="classdds_1_1domain_1_1DomainParticipant.html#a94c43030edf18f03e9b6c79bd5ca9c4c" title="&lt;&lt;extension&gt;&gt; Unregister a content filter previously registered with dds::domain::DomainParticipant::...">unregister_contentfilter</a>(my_filter_name);</div>
</div><!-- fragment --> <h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_create2"></a>
Using a CustomFilter</h2>
<p>After the custom filter has been registered, you must create <a class="el" href="classdds_1_1topic_1_1Filter.html" title="Defines the filter to create a ContentFilteredTopic.">dds::topic::Filter</a> that contain the filter expressions and parameters that will be used in your filter. You must give these Filters names that match the name with which the CustomFilter was registered in order to associate the two.</p>
<p>Next, create the readers that will be using the custom filter with dds::topic::ContentFilteredTopics that have been created with the Filters you created.</p>
<p>After that, everything is set up for you. Now, your readers will only receive samples matching the filter that you have set up for them.</p>
<div class="fragment"><div class="line">    <a class="code" href="classdds_1_1topic_1_1Topic.html" title="&lt;&lt;reference-type&gt;&gt; Topic is the most basic description of the data to be published and subscribed...">dds::topic::Topic&lt;Foo&gt;</a> topic1(participant1, <span class="stringliteral">&quot;ExampleTopic&quot;</span>);</div>
<div class="line">    <a class="code" href="classdds_1_1topic_1_1Topic.html" title="&lt;&lt;reference-type&gt;&gt; Topic is the most basic description of the data to be published and subscribed...">dds::topic::Topic&lt;Foo&gt;</a> topic2(participant2, <span class="stringliteral">&quot;ExampleTopic&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create the parameter lists for the filters</span></div>
<div class="line">    std::vector&lt;std::string&gt; cft_parameters(2);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// In this example, the first parameter dictates whether or not the</span></div>
<div class="line">    <span class="comment">// writer-side filter optimization will be turned on. Parameter 2 </span></div>
<div class="line">    <span class="comment">// tells the writer_evaluate which single value of x this reader wants to </span></div>
<div class="line">    <span class="comment">// receive samples for</span></div>
<div class="line">    cft_parameters[0] = <span class="stringliteral">&quot;1&quot;</span>;</div>
<div class="line">    cft_parameters[1] = <span class="stringliteral">&quot;5&quot;</span>;</div>
<div class="line">    <a class="code" href="classdds_1_1topic_1_1Filter.html" title="Defines the filter to create a ContentFilteredTopic.">dds::topic::Filter</a> filter1(<span class="stringliteral">&quot;x = %1&quot;</span>, cft_parameters);</div>
<div class="line"></div>
<div class="line">    cft_parameters[0] = <span class="stringliteral">&quot;1&quot;</span>;</div>
<div class="line">    cft_parameters[1] = <span class="stringliteral">&quot;10&quot;</span>;</div>
<div class="line">    <a class="code" href="classdds_1_1topic_1_1Filter.html" title="Defines the filter to create a ContentFilteredTopic.">dds::topic::Filter</a> filter2(<span class="stringliteral">&quot;x = %1&quot;</span>, cft_parameters);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Any reader that is not using the writer-side filter optimization will </span></div>
<div class="line">    <span class="comment">// receive samples where x &gt; 7. The second parameter in this case is </span></div>
<div class="line">    <span class="comment">// ignored, but is set here just as a reminder</span></div>
<div class="line">    cft_parameters[0] = <span class="stringliteral">&quot;0&quot;</span>;</div>
<div class="line">    cft_parameters[1] = <span class="stringliteral">&quot;7&quot;</span>;</div>
<div class="line">    <a class="code" href="classdds_1_1topic_1_1Filter.html" title="Defines the filter to create a ContentFilteredTopic.">dds::topic::Filter</a> filter3(<span class="stringliteral">&quot;x &gt; %1&quot;</span>, cft_parameters);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create a DataWriter that will perform writer-side filtering</span></div>
<div class="line">    <a class="code" href="classdds_1_1pub_1_1DataWriter.html" title="&lt;&lt;reference-type&gt;&gt; Allows an application to publish data for a dds::topic::Topic">dds::pub::DataWriter&lt;Foo&gt;</a> writer(</div>
<div class="line">       <a class="code" href="classdds_1_1pub_1_1Publisher.html" title="&lt;&lt;reference-type&gt;&gt; A publisher is the object responsible for the actual dissemination of publications...">dds::pub::Publisher</a>(participant1), topic1, writer_qos);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Assign filters a name or else the default, DDS_SQL_FILTER will be </span></div>
<div class="line">    <span class="comment">// used </span></div>
<div class="line">    filter1-&gt;name(my_filter_name);</div>
<div class="line">    filter2-&gt;name(my_filter_name);</div>
<div class="line">    filter3-&gt;name(my_filter_name);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create the ContentFilteredTopics that will be used when creating the </span></div>
<div class="line">    <span class="comment">// DataReaders</span></div>
<div class="line">    <a class="code" href="classdds_1_1topic_1_1ContentFilteredTopic.html" title="&lt;&lt;reference-type&gt;&gt; Specialization of TopicDescription that allows for content-based subscriptions...">dds::topic::ContentFilteredTopic&lt;Foo&gt;</a> cft1(</div>
<div class="line">       topic2, <span class="stringliteral">&quot;MyContentFilteredTopic1&quot;</span>, filter1);</div>
<div class="line">    <a class="code" href="classdds_1_1topic_1_1ContentFilteredTopic.html" title="&lt;&lt;reference-type&gt;&gt; Specialization of TopicDescription that allows for content-based subscriptions...">dds::topic::ContentFilteredTopic&lt;Foo&gt;</a> cft2(</div>
<div class="line">       topic2, <span class="stringliteral">&quot;MyContentFilteredTopic2&quot;</span>, filter2);</div>
<div class="line">    <a class="code" href="classdds_1_1topic_1_1ContentFilteredTopic.html" title="&lt;&lt;reference-type&gt;&gt; Specialization of TopicDescription that allows for content-based subscriptions...">dds::topic::ContentFilteredTopic&lt;Foo&gt;</a> cft3(</div>
<div class="line">       topic2, <span class="stringliteral">&quot;MyContentFilteredTopic3&quot;</span>, filter3);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create two readers that will make use of the writer-side filter </span></div>
<div class="line">    <span class="comment">// optimization and one that won&#39;t</span></div>
<div class="line">    <a class="code" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader&lt;Foo&gt;</a> optimizedReader1(</div>
<div class="line">       <a class="code" href="classdds_1_1sub_1_1Subscriber.html" title="&lt;&lt;reference-type&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscrip...">dds::sub::Subscriber</a>(participant2), cft1, reader_qos);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader&lt;Foo&gt;</a> optimizedReader2(</div>
<div class="line">       <a class="code" href="classdds_1_1sub_1_1Subscriber.html" title="&lt;&lt;reference-type&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscrip...">dds::sub::Subscriber</a>(participant2), cft2, reader_qos);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader&lt;Foo&gt;</a> reader3(</div>
<div class="line">       <a class="code" href="classdds_1_1sub_1_1Subscriber.html" title="&lt;&lt;reference-type&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscrip...">dds::sub::Subscriber</a>(participant2), cft3, reader_qos);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Wait for the writer to match all readers before writing any samples</span></div>
<div class="line">    <a class="code" href="classdds_1_1core_1_1cond_1_1StatusCondition.html" title="&lt;&lt;reference-type&gt;&gt; A condition associated with each dds::core::Entity">dds::core::cond::StatusCondition</a> status_condition(writer);</div>
<div class="line">    int32_t <a class="code" href="classdds_1_1sub_1_1DataReader.html#a7c4dc52d235b3a6be17de6627919297e" title="Retrieve the list of publications currently &quot;associated&quot; with a DataReader.">matched_publications</a> = 0;</div>
<div class="line">    <span class="keywordflow">while</span> (matched_publications != 3) {</div>
<div class="line">        <a class="code" href="classdds_1_1core_1_1status_1_1StatusMask.html" title="A std::bitset (list) of statuses.">dds::core::status::StatusMask</a> enabled_status_list = </div>
<div class="line">            status_condition.enabled_statuses();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> ((enabled_status_list &amp; <a class="code" href="classdds_1_1core_1_1status_1_1StatusMask.html#a1849073f6348de60bddf95cac5f04e53" title="The dds::pub::DataWriter has found dds::sub::DataReader that matches the dds::topic::Topic and has co...">dds::core::status::StatusMask::publication_matched</a>()).any()) {</div>
<div class="line">            <a class="code" href="classdds_1_1core_1_1status_1_1PublicationMatchedStatus.html" title="Information about the status dds::core::status::StatusMask::publication_matched()">dds::core::status::PublicationMatchedStatus</a> status = </div>
<div class="line">                writer.publication_matched_status();</div>
<div class="line">            matched_publications = status.<a class="code" href="classdds_1_1core_1_1status_1_1PublicationMatchedStatus.html#a401e845e44241f275195c91946479ee0" title="The total cumulative number of times the concerned dds::pub::DataWriter discovered a &quot;match&quot; with a d...">total_count</a>();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Write 11 samples with x = 0 through 10</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 11; i++) {</div>
<div class="line">        writer.write(<a class="code" href="classFoo.html" title="A hypothetical topic-type.">Foo</a>(i, i));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// optimizedReader1 will only receive samples with x == 5</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;optimizedReader1&#39;s samples: &quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <a class="code" href="classdds_1_1sub_1_1LoanedSamples.html" title="&lt;&lt;move-only-type&gt;&gt; Provides temporary access to a collection of samples from a DataReader.">dds::sub::LoanedSamples&lt;Foo&gt;</a> samples = optimizedReader1.take();</div>
<div class="line">    std::copy(</div>
<div class="line">        samples.<a class="code" href="classdds_1_1sub_1_1LoanedSamples.html#a417790627e30ca877a6a556014973227" title="Gets an iterator to the first sample.">begin</a>(),</div>
<div class="line">        samples.<a class="code" href="classdds_1_1sub_1_1LoanedSamples.html#afd989c219c45584247b7715a16927fb6" title="Gets an iterator to one past the last sample.">end</a>(),</div>
<div class="line">        dds::sub::LoanedSamples&lt;Foo&gt;::ostream_iterator(std::cout, <span class="stringliteral">&quot;\n&quot;</span>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// optimizedReader2 will only receive samples with x == 10</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;optimizedReader2&#39;s samples: &quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    samples = optimizedReader2.take();</div>
<div class="line">    std::copy(</div>
<div class="line">        samples.<a class="code" href="classdds_1_1sub_1_1LoanedSamples.html#a417790627e30ca877a6a556014973227" title="Gets an iterator to the first sample.">begin</a>(),</div>
<div class="line">        samples.<a class="code" href="classdds_1_1sub_1_1LoanedSamples.html#afd989c219c45584247b7715a16927fb6" title="Gets an iterator to one past the last sample.">end</a>(),</div>
<div class="line">        dds::sub::LoanedSamples&lt;Foo&gt;::ostream_iterator(std::cout, <span class="stringliteral">&quot;\n&quot;</span>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// reader3 will receive samples with x == 8, 9, 10</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;reader3&#39;s samples: &quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    samples = reader3.take();</div>
<div class="line">    std::copy(</div>
<div class="line">        samples.<a class="code" href="classdds_1_1sub_1_1LoanedSamples.html#a417790627e30ca877a6a556014973227" title="Gets an iterator to the first sample.">begin</a>(),</div>
<div class="line">        samples.<a class="code" href="classdds_1_1sub_1_1LoanedSamples.html#afd989c219c45584247b7715a16927fb6" title="Gets an iterator to one past the last sample.">end</a>(),</div>
<div class="line">        dds::sub::LoanedSamples&lt;Foo&gt;::ostream_iterator(std::cout, <span class="stringliteral">&quot;\n&quot;</span>));</div>
<div class="line"></div>
</div><!-- fragment --> <h2><a class="anchor" id="NDDSCustomFilterExampleModuleForCpp2_lookup"></a>
Looking up the Filter</h2>
<p>A custom filter that is registered with a DomainParticipant can be looked up:</p>
<div class="fragment"><div class="line">    <a class="code" href="classrti_1_1topic_1_1CustomFilter.html" title="&lt;&lt;extension&gt;&gt; &lt;&lt;reference-type&gt;&gt; A wrapper class for the user-defined implementation of a ContentFilt...">rti::topic::CustomFilter&lt;ExampleWriterContentFilter&gt;</a> retrieved_custom_filter =</div>
<div class="line">           rti::topic::find_content_filter&lt;ExampleWriterContentFilter&gt;(</div>
<div class="line">               participant1, my_filter_name);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// You can retrieve your ContentFilter from the CustomFilter: </span></div>
<div class="line">    ExampleWriterContentFilter* retrieved_content_filter = </div>
<div class="line">              retrieved_custom_filter.<a class="code" href="classrti_1_1topic_1_1CustomFilter.html#a2c3429fa2df6585a3e1b1eeee23b5c6a" title="Get a const pointer to the underlying content filter.">get</a>();</div>
<div class="line"></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Connext Modern C++ API Version 5.2.3</A>
Copyright &copy; Wed Apr 27 2016 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
