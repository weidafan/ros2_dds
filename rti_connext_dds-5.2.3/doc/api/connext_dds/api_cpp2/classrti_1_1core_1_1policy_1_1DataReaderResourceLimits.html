<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>RTI Connext Modern C++ API: rti::core::policy::DataReaderResourceLimits Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RTI Connext Modern C++ API
   &#160;<span id="projectnumber">Version 5.2.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2-20120808 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rti::core::policy::DataReaderResourceLimits Class Reference<div class="ingroups"><a class="el" href="group__DDSDataReaderResourceLimitsQosModule.html">DATA_READER_RESOURCE_LIMITS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><em><a class="el" href="group__DDSCpp2Conventions.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Configures the memory usage of a dds::pub::DataReader  
 <a href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#details">More...</a></p>

<p><code>#include &lt;rti/core/policy/CorePolicy.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab1491c1ac182f7b49d8111a6a993aab1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#ab1491c1ac182f7b49d8111a6a993aab1">DataReaderResourceLimits</a> ()</td></tr>
<tr class="memdesc:ab1491c1ac182f7b49d8111a6a993aab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html" title="&lt;&lt;extension&gt;&gt; Configures the memory usage of a dds::pub::DataReader">DataReaderResourceLimits</a> qos policy with default values.  <a href="#ab1491c1ac182f7b49d8111a6a993aab1"></a><br/></td></tr>
<tr class="separator:ab1491c1ac182f7b49d8111a6a993aab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2c2030130fe254f09742302b6beef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#aaf2c2030130fe254f09742302b6beef6">max_remote_writers</a> (int32_t the_max_remote_writers)</td></tr>
<tr class="memdesc:aaf2c2030130fe254f09742302b6beef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of remote writers from which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may read, including all instances.  <a href="#aaf2c2030130fe254f09742302b6beef6"></a><br/></td></tr>
<tr class="separator:aaf2c2030130fe254f09742302b6beef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf50ab97e409ee2d3662b66d40d5946"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a4cf50ab97e409ee2d3662b66d40d5946">max_remote_writers</a> () const </td></tr>
<tr class="memdesc:a4cf50ab97e409ee2d3662b66d40d5946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#a4cf50ab97e409ee2d3662b66d40d5946"></a><br/></td></tr>
<tr class="separator:a4cf50ab97e409ee2d3662b66d40d5946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33466dc123f94b23eae592d664792162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a33466dc123f94b23eae592d664792162">max_remote_writers_per_instance</a> (int32_t the_max_remote_writers_per_instance)</td></tr>
<tr class="memdesc:a33466dc123f94b23eae592d664792162"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of remote writers from which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may read a single instance.  <a href="#a33466dc123f94b23eae592d664792162"></a><br/></td></tr>
<tr class="separator:a33466dc123f94b23eae592d664792162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab176c51db66353feef4beee4bb74b6b4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#ab176c51db66353feef4beee4bb74b6b4">max_remote_writers_per_instance</a> () const </td></tr>
<tr class="memdesc:ab176c51db66353feef4beee4bb74b6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#ab176c51db66353feef4beee4bb74b6b4"></a><br/></td></tr>
<tr class="separator:ab176c51db66353feef4beee4bb74b6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843b1e56a46d11df546911c7a7d929b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a843b1e56a46d11df546911c7a7d929b8">max_samples_per_remote_writer</a> (int32_t the_max_samples_per_remote_writer)</td></tr>
<tr class="memdesc:a843b1e56a46d11df546911c7a7d929b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of out-of-order samples from a given remote <a class="el" href="classdds_1_1pub_1_1DataWriter.html" title="&lt;&lt;reference-type&gt;&gt; Allows an application to publish data for a dds::topic::Topic">dds::pub::DataWriter</a> that a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may store when maintaining a reliable connection to the <a class="el" href="classdds_1_1pub_1_1DataWriter.html" title="&lt;&lt;reference-type&gt;&gt; Allows an application to publish data for a dds::topic::Topic">dds::pub::DataWriter</a>.  <a href="#a843b1e56a46d11df546911c7a7d929b8"></a><br/></td></tr>
<tr class="separator:a843b1e56a46d11df546911c7a7d929b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e9b31280a16149ef8e16e74c159d00"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a26e9b31280a16149ef8e16e74c159d00">max_samples_per_remote_writer</a> () const </td></tr>
<tr class="memdesc:a26e9b31280a16149ef8e16e74c159d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#a26e9b31280a16149ef8e16e74c159d00"></a><br/></td></tr>
<tr class="separator:a26e9b31280a16149ef8e16e74c159d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e96cfcc20fa553f8a0fa58d4b6efe7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a0e96cfcc20fa553f8a0fa58d4b6efe7a">max_infos</a> (int32_t the_max_infos)</td></tr>
<tr class="memdesc:a0e96cfcc20fa553f8a0fa58d4b6efe7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of info units that a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> can use to store <a class="el" href="classdds_1_1sub_1_1SampleInfo.html" title="&lt;&lt;value-type&gt;&gt; Information that accompanies each sample received by a DataReader">dds::sub::SampleInfo</a>.  <a href="#a0e96cfcc20fa553f8a0fa58d4b6efe7a"></a><br/></td></tr>
<tr class="separator:a0e96cfcc20fa553f8a0fa58d4b6efe7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b80b4eac2071a19c55f99cedc9adfd2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a1b80b4eac2071a19c55f99cedc9adfd2">max_infos</a> () const </td></tr>
<tr class="memdesc:a1b80b4eac2071a19c55f99cedc9adfd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#a1b80b4eac2071a19c55f99cedc9adfd2"></a><br/></td></tr>
<tr class="separator:a1b80b4eac2071a19c55f99cedc9adfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28ec118e4547d04467812c97093a3c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#ad28ec118e4547d04467812c97093a3c9">initial_remote_writers</a> (int32_t the_initial_remote_writers)</td></tr>
<tr class="memdesc:ad28ec118e4547d04467812c97093a3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of remote writers from which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may read, including all instances.  <a href="#ad28ec118e4547d04467812c97093a3c9"></a><br/></td></tr>
<tr class="separator:ad28ec118e4547d04467812c97093a3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5ab328cc3c39593d6070bc6528205f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a5f5ab328cc3c39593d6070bc6528205f">initial_remote_writers</a> () const </td></tr>
<tr class="memdesc:a5f5ab328cc3c39593d6070bc6528205f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#a5f5ab328cc3c39593d6070bc6528205f"></a><br/></td></tr>
<tr class="separator:a5f5ab328cc3c39593d6070bc6528205f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75c499b7ed7887b50d7803268196206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#ab75c499b7ed7887b50d7803268196206">initial_remote_writers_per_instance</a> (int32_t the_initial_remote_writers_per_instance)</td></tr>
<tr class="memdesc:ab75c499b7ed7887b50d7803268196206"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of remote writers from which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may read a single instance.  <a href="#ab75c499b7ed7887b50d7803268196206"></a><br/></td></tr>
<tr class="separator:ab75c499b7ed7887b50d7803268196206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0d31e9b0d588c215af96dcacc3a5dd"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#abb0d31e9b0d588c215af96dcacc3a5dd">initial_remote_writers_per_instance</a> () const </td></tr>
<tr class="memdesc:abb0d31e9b0d588c215af96dcacc3a5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#abb0d31e9b0d588c215af96dcacc3a5dd"></a><br/></td></tr>
<tr class="separator:abb0d31e9b0d588c215af96dcacc3a5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80df3c9c5f3e52193116c257d115b7f8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a80df3c9c5f3e52193116c257d115b7f8">initial_infos</a> () const </td></tr>
<tr class="memdesc:a80df3c9c5f3e52193116c257d115b7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#a80df3c9c5f3e52193116c257d115b7f8"></a><br/></td></tr>
<tr class="separator:a80df3c9c5f3e52193116c257d115b7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ab913a61a307350f4789f37387daab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a27ab913a61a307350f4789f37387daab">initial_outstanding_reads</a> (int32_t the_initial_outstanding_reads)</td></tr>
<tr class="memdesc:a27ab913a61a307350f4789f37387daab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of outstanding calls to read/take (or one of their variants) on the same <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> for which memory has not been returned by calling <a class="el" href="classdds_1_1sub_1_1LoanedSamples.html#a2ee7565b32560ab659981da69a2f4bfb" title="Returns the samples to the container // TODO.">dds::sub::LoanedSamples::return_loan()</a>.  <a href="#a27ab913a61a307350f4789f37387daab"></a><br/></td></tr>
<tr class="separator:a27ab913a61a307350f4789f37387daab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36c164a5c9df7f7939e53894a508226"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#ae36c164a5c9df7f7939e53894a508226">initial_outstanding_reads</a> () const </td></tr>
<tr class="memdesc:ae36c164a5c9df7f7939e53894a508226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#ae36c164a5c9df7f7939e53894a508226"></a><br/></td></tr>
<tr class="separator:ae36c164a5c9df7f7939e53894a508226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9502966c7115a8342683a9563541d46e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a9502966c7115a8342683a9563541d46e">max_outstanding_reads</a> (int32_t the_max_outstanding_reads)</td></tr>
<tr class="memdesc:a9502966c7115a8342683a9563541d46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of outstanding read/take calls (or one of their variants) on the same <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> for which memory has not been returned by calling <a class="el" href="classdds_1_1sub_1_1LoanedSamples.html#a2ee7565b32560ab659981da69a2f4bfb" title="Returns the samples to the container // TODO.">dds::sub::LoanedSamples::return_loan()</a>.  <a href="#a9502966c7115a8342683a9563541d46e"></a><br/></td></tr>
<tr class="separator:a9502966c7115a8342683a9563541d46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cd801f9df2b53992258a3044aa81de"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a39cd801f9df2b53992258a3044aa81de">max_outstanding_reads</a> () const </td></tr>
<tr class="memdesc:a39cd801f9df2b53992258a3044aa81de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#a39cd801f9df2b53992258a3044aa81de"></a><br/></td></tr>
<tr class="separator:a39cd801f9df2b53992258a3044aa81de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c935442b2bffb8acbdc71ae05326cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a60c935442b2bffb8acbdc71ae05326cd">max_samples_per_read</a> (int32_t the_max_samples_per_read)</td></tr>
<tr class="memdesc:a60c935442b2bffb8acbdc71ae05326cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of data samples that the application can receive from the middleware in a single call to <a class="el" href="classdds_1_1sub_1_1DataReader.html#a864f65d2246d2f854cf0b892ff6b8631" title="Read all samples using the default filter state.">dds::sub::DataReader::read</a> or <a class="el" href="classdds_1_1sub_1_1DataReader.html#aa63c8e102e4abd5446198bcfe71ebfe1" title="Take all samples using the default filter state.">dds::sub::DataReader::take</a>. If more data exists in the middleware, the application will need to issue multiple read/take calls.  <a href="#a60c935442b2bffb8acbdc71ae05326cd"></a><br/></td></tr>
<tr class="separator:a60c935442b2bffb8acbdc71ae05326cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed40e358555e1bf50ce1da98cf679e6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a1ed40e358555e1bf50ce1da98cf679e6">max_samples_per_read</a> () const </td></tr>
<tr class="memdesc:a1ed40e358555e1bf50ce1da98cf679e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#a1ed40e358555e1bf50ce1da98cf679e6"></a><br/></td></tr>
<tr class="separator:a1ed40e358555e1bf50ce1da98cf679e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402c42ca6e2d3e58f52c69887bdc480c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a402c42ca6e2d3e58f52c69887bdc480c">disable_fragmentation_support</a> (bool the_disable_fragmentation_support)</td></tr>
<tr class="memdesc:a402c42ca6e2d3e58f52c69887bdc480c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> can receive fragmented samples.  <a href="#a402c42ca6e2d3e58f52c69887bdc480c"></a><br/></td></tr>
<tr class="separator:a402c42ca6e2d3e58f52c69887bdc480c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6efa34e04e72d330437b9b9ef2d015f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#aa6efa34e04e72d330437b9b9ef2d015f">disable_fragmentation_support</a> () const </td></tr>
<tr class="memdesc:aa6efa34e04e72d330437b9b9ef2d015f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#aa6efa34e04e72d330437b9b9ef2d015f"></a><br/></td></tr>
<tr class="separator:aa6efa34e04e72d330437b9b9ef2d015f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66442e068410c27384a2cb2812b28a3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a66442e068410c27384a2cb2812b28a3e">max_fragmented_samples</a> (int32_t the_max_fragmented_samples)</td></tr>
<tr class="memdesc:a66442e068410c27384a2cb2812b28a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of samples for which the <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may store fragments at a given point in time.  <a href="#a66442e068410c27384a2cb2812b28a3e"></a><br/></td></tr>
<tr class="separator:a66442e068410c27384a2cb2812b28a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2561c9a8a1c7d37aa57cf388e8e9c69e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a2561c9a8a1c7d37aa57cf388e8e9c69e">max_fragmented_samples</a> () const </td></tr>
<tr class="memdesc:a2561c9a8a1c7d37aa57cf388e8e9c69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#a2561c9a8a1c7d37aa57cf388e8e9c69e"></a><br/></td></tr>
<tr class="separator:a2561c9a8a1c7d37aa57cf388e8e9c69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17acb17b9ef5ffb7126c7a37d860f57a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a17acb17b9ef5ffb7126c7a37d860f57a">initial_fragmented_samples</a> (int32_t the_initial_fragmented_samples)</td></tr>
<tr class="memdesc:a17acb17b9ef5ffb7126c7a37d860f57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of samples for which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may store fragments.  <a href="#a17acb17b9ef5ffb7126c7a37d860f57a"></a><br/></td></tr>
<tr class="separator:a17acb17b9ef5ffb7126c7a37d860f57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86aa80b4c9036bc842669d67c22d7e4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#aa86aa80b4c9036bc842669d67c22d7e4">initial_fragmented_samples</a> () const </td></tr>
<tr class="memdesc:aa86aa80b4c9036bc842669d67c22d7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#aa86aa80b4c9036bc842669d67c22d7e4"></a><br/></td></tr>
<tr class="separator:aa86aa80b4c9036bc842669d67c22d7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3399b71c5906902be89a4b5d5de2e762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a3399b71c5906902be89a4b5d5de2e762">max_fragmented_samples_per_remote_writer</a> (int32_t the_max_fragmented_samples_per_remote_writer)</td></tr>
<tr class="memdesc:a3399b71c5906902be89a4b5d5de2e762"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of samples per remote writer for which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may store fragments.  <a href="#a3399b71c5906902be89a4b5d5de2e762"></a><br/></td></tr>
<tr class="separator:a3399b71c5906902be89a4b5d5de2e762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab020931ddb1e21eb8975f70054a9c386"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#ab020931ddb1e21eb8975f70054a9c386">max_fragmented_samples_per_remote_writer</a> () const </td></tr>
<tr class="memdesc:ab020931ddb1e21eb8975f70054a9c386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#ab020931ddb1e21eb8975f70054a9c386"></a><br/></td></tr>
<tr class="separator:ab020931ddb1e21eb8975f70054a9c386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6daad429f29ae958e400a3d415b1dbe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a6daad429f29ae958e400a3d415b1dbe2">max_fragments_per_sample</a> (int32_t the_max_fragments_per_sample)</td></tr>
<tr class="memdesc:a6daad429f29ae958e400a3d415b1dbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of fragments for a single sample.  <a href="#a6daad429f29ae958e400a3d415b1dbe2"></a><br/></td></tr>
<tr class="separator:a6daad429f29ae958e400a3d415b1dbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1946e4336f6e667688cb061782b4155"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#ae1946e4336f6e667688cb061782b4155">max_fragments_per_sample</a> () const </td></tr>
<tr class="memdesc:ae1946e4336f6e667688cb061782b4155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#ae1946e4336f6e667688cb061782b4155"></a><br/></td></tr>
<tr class="separator:ae1946e4336f6e667688cb061782b4155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5235988e69052c6dd2441ace61359fa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a5235988e69052c6dd2441ace61359fa0">dynamically_allocate_fragmented_samples</a> (bool the_dynamically_allocate_fragmented_samples)</td></tr>
<tr class="memdesc:a5235988e69052c6dd2441ace61359fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> pre-allocates storage for storing fragmented samples.  <a href="#a5235988e69052c6dd2441ace61359fa0"></a><br/></td></tr>
<tr class="separator:a5235988e69052c6dd2441ace61359fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd01c96e13e14b08545125471e6c7d97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#acd01c96e13e14b08545125471e6c7d97">dynamically_allocate_fragmented_samples</a> () const </td></tr>
<tr class="memdesc:acd01c96e13e14b08545125471e6c7d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#acd01c96e13e14b08545125471e6c7d97"></a><br/></td></tr>
<tr class="separator:acd01c96e13e14b08545125471e6c7d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501c49e23ec86d894ebc913f532a6d99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a501c49e23ec86d894ebc913f532a6d99">max_total_instances</a> (int32_t the_max_total_instances)</td></tr>
<tr class="memdesc:a501c49e23ec86d894ebc913f532a6d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of instances for which a DataReader will keep state.  <a href="#a501c49e23ec86d894ebc913f532a6d99"></a><br/></td></tr>
<tr class="separator:a501c49e23ec86d894ebc913f532a6d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8df57cbd65d11ad1454c2151aa66de9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#ae8df57cbd65d11ad1454c2151aa66de9">max_total_instances</a> () const </td></tr>
<tr class="memdesc:ae8df57cbd65d11ad1454c2151aa66de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#ae8df57cbd65d11ad1454c2151aa66de9"></a><br/></td></tr>
<tr class="separator:ae8df57cbd65d11ad1454c2151aa66de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160fcbc5bb1c7890bd641f19bb0409fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a160fcbc5bb1c7890bd641f19bb0409fc">max_remote_virtual_writers</a> (int32_t the_max_remote_virtual_writers)</td></tr>
<tr class="memdesc:a160fcbc5bb1c7890bd641f19bb0409fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of remote virtual writers from which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may read, including all instances.  <a href="#a160fcbc5bb1c7890bd641f19bb0409fc"></a><br/></td></tr>
<tr class="separator:a160fcbc5bb1c7890bd641f19bb0409fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c1ccbfbd437c24b95eb78f860ae780"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#ad7c1ccbfbd437c24b95eb78f860ae780">max_remote_virtual_writers</a> () const </td></tr>
<tr class="memdesc:ad7c1ccbfbd437c24b95eb78f860ae780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#ad7c1ccbfbd437c24b95eb78f860ae780"></a><br/></td></tr>
<tr class="separator:ad7c1ccbfbd437c24b95eb78f860ae780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d66482197f90dd206399784e788e54d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a2d66482197f90dd206399784e788e54d">initial_remote_virtual_writers</a> (int32_t the_initial_remote_virtual_writers)</td></tr>
<tr class="memdesc:a2d66482197f90dd206399784e788e54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of remote virtual writers from which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may read, including all instances.  <a href="#a2d66482197f90dd206399784e788e54d"></a><br/></td></tr>
<tr class="separator:a2d66482197f90dd206399784e788e54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d8ba194062615ad02c132e84624220"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#ae7d8ba194062615ad02c132e84624220">initial_remote_virtual_writers</a> () const </td></tr>
<tr class="memdesc:ae7d8ba194062615ad02c132e84624220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#ae7d8ba194062615ad02c132e84624220"></a><br/></td></tr>
<tr class="separator:ae7d8ba194062615ad02c132e84624220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33ace5818469ef9273b4e181e772153"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#ab33ace5818469ef9273b4e181e772153">max_remote_virtual_writers_per_instance</a> (int32_t the_max_remote_virtual_writers_per_instance)</td></tr>
<tr class="memdesc:ab33ace5818469ef9273b4e181e772153"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of virtual remote writers that can be associated with an instance.  <a href="#ab33ace5818469ef9273b4e181e772153"></a><br/></td></tr>
<tr class="separator:ab33ace5818469ef9273b4e181e772153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39208f0ed64b04cfa8b786ea6776c4f6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a39208f0ed64b04cfa8b786ea6776c4f6">max_remote_virtual_writers_per_instance</a> () const </td></tr>
<tr class="memdesc:a39208f0ed64b04cfa8b786ea6776c4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#a39208f0ed64b04cfa8b786ea6776c4f6"></a><br/></td></tr>
<tr class="separator:a39208f0ed64b04cfa8b786ea6776c4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae817e760c2f90e4174cbd15aaa280d39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#ae817e760c2f90e4174cbd15aaa280d39">initial_remote_virtual_writers_per_instance</a> (int32_t the_initial_remote_virtual_writers_per_instance)</td></tr>
<tr class="memdesc:ae817e760c2f90e4174cbd15aaa280d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of virtual remote writers per instance.  <a href="#ae817e760c2f90e4174cbd15aaa280d39"></a><br/></td></tr>
<tr class="separator:ae817e760c2f90e4174cbd15aaa280d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3ec8eef686c4ab55191f5352214b40"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#aee3ec8eef686c4ab55191f5352214b40">initial_remote_virtual_writers_per_instance</a> () const </td></tr>
<tr class="memdesc:aee3ec8eef686c4ab55191f5352214b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#aee3ec8eef686c4ab55191f5352214b40"></a><br/></td></tr>
<tr class="separator:aee3ec8eef686c4ab55191f5352214b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac018fc863e5bc83d396e4a2e5802f313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#ac018fc863e5bc83d396e4a2e5802f313">max_remote_writers_per_sample</a> (int32_t the_max_remote_writers_per_sample)</td></tr>
<tr class="memdesc:ac018fc863e5bc83d396e4a2e5802f313"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of remote writers allowed to write the same sample.  <a href="#ac018fc863e5bc83d396e4a2e5802f313"></a><br/></td></tr>
<tr class="separator:ac018fc863e5bc83d396e4a2e5802f313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8b013b625f609628410f3c11ce84b1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#abe8b013b625f609628410f3c11ce84b1">max_remote_writers_per_sample</a> () const </td></tr>
<tr class="memdesc:abe8b013b625f609628410f3c11ce84b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#abe8b013b625f609628410f3c11ce84b1"></a><br/></td></tr>
<tr class="separator:abe8b013b625f609628410f3c11ce84b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc0b97c463fd531a1dd00d95ce180ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a5dc0b97c463fd531a1dd00d95ce180ea">max_query_condition_filters</a> (int32_t the_max_query_condition_filters)</td></tr>
<tr class="memdesc:a5dc0b97c463fd531a1dd00d95ce180ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of query condition filters a reader is allowed.  <a href="#a5dc0b97c463fd531a1dd00d95ce180ea"></a><br/></td></tr>
<tr class="separator:a5dc0b97c463fd531a1dd00d95ce180ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237895ee033e6b74aeac0b8c73b372c5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a237895ee033e6b74aeac0b8c73b372c5">max_query_condition_filters</a> () const </td></tr>
<tr class="memdesc:a237895ee033e6b74aeac0b8c73b372c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#a237895ee033e6b74aeac0b8c73b372c5"></a><br/></td></tr>
<tr class="separator:a237895ee033e6b74aeac0b8c73b372c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc77695f81cf933f693388f715997900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#abc77695f81cf933f693388f715997900">max_app_ack_response_length</a> (int32_t the_max_app_ack_response_length)</td></tr>
<tr class="memdesc:abc77695f81cf933f693388f715997900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of application-level acknowledgment response data.  <a href="#abc77695f81cf933f693388f715997900"></a><br/></td></tr>
<tr class="separator:abc77695f81cf933f693388f715997900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0e69751341b92b40ed3099ff9d4f54"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#afd0e69751341b92b40ed3099ff9d4f54">max_app_ack_response_length</a> () const </td></tr>
<tr class="memdesc:afd0e69751341b92b40ed3099ff9d4f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#afd0e69751341b92b40ed3099ff9d4f54"></a><br/></td></tr>
<tr class="separator:afd0e69751341b92b40ed3099ff9d4f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe05fabccf4e96f8acdd7397afe5f4d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#afe05fabccf4e96f8acdd7397afe5f4d8">keep_minimum_state_for_instances</a> (bool the_keep_minimum_state_for_instances)</td></tr>
<tr class="memdesc:afe05fabccf4e96f8acdd7397afe5f4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not keep a minimum instance state for up to <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a501c49e23ec86d894ebc913f532a6d99" title="Maximum number of instances for which a DataReader will keep state.">rti::core::policy::DataReaderResourceLimits::max_total_instances</a>.  <a href="#afe05fabccf4e96f8acdd7397afe5f4d8"></a><br/></td></tr>
<tr class="separator:afe05fabccf4e96f8acdd7397afe5f4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd9f44633056796d5c484b4538df8ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a9fd9f44633056796d5c484b4538df8ea">keep_minimum_state_for_instances</a> () const </td></tr>
<tr class="memdesc:a9fd9f44633056796d5c484b4538df8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#a9fd9f44633056796d5c484b4538df8ea"></a><br/></td></tr>
<tr class="separator:a9fd9f44633056796d5c484b4538df8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><em><a class="el" href="group__DDSCpp2Conventions.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Configures the memory usage of a dds::pub::DataReader </p>
<p>DataReaders must allocate internal structures to handle the maximum number of DataWriters that may connect to it, whether or not a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> handles data fragmentation and how many data fragments that it may handle (for data samples larger than the MTU of the underlying network transport), how many simultaneous outstanding loans of internal memory holding data samples can be provided to user code, as well as others. </p>
<p>Most of these internal structures start at an initial size and, by default, will grow as needed by dynamically allocating additional memory. You may set fixed, maximum sizes for these internal structures if you want to bound the amount of memory that can be used by a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a>. By setting the initial size to the maximum size, you will prevent RTI Connext from dynamically allocating any memory after the creation of the <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a>. </p>
<p>This QoS policy is an extension to the DDS standard. </p>
<dl class="section user"><dt>Entity:</dt><dd><a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> </dd></dl>
<dl class="section user"><dt>Properties:</dt><dd><a class="el" href="group__DDSQosTypesModule.html#a_prop_rxo">RxO</a> = N/A <br/>
 <a class="el" href="group__DDSQosTypesModule.html#a_prop_changeable">Changeable</a> = <a class="el" href="group__DDSQosTypesModule.html#a_prop_changeable_no">NO</a> <br/>
 </dd></dl>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab1491c1ac182f7b49d8111a6a993aab1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rti::core::policy::DataReaderResourceLimits::DataReaderResourceLimits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html" title="&lt;&lt;extension&gt;&gt; Configures the memory usage of a dds::pub::DataReader">DataReaderResourceLimits</a> qos policy with default values. </p>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="aaf2c2030130fe254f09742302b6beef6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::max_remote_writers </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_max_remote_writers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of remote writers from which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may read, including all instances. </p>
<p><b>[default]</b> <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a> <br/>
 <b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a>, &gt;= initial_remote_writers, &gt;= max_remote_writers_per_instance </p>
<p>For unkeyed types, this value has to be equal to max_remote_writers_per_instance if max_remote_writers_per_instance is not equal to <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a>. </p>
<p>Note: For efficiency, set <code>max_remote_writers</code> &gt;= <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a33466dc123f94b23eae592d664792162" title="The maximum number of remote writers from which a dds::sub::DataReader may read a single instance...">rti::core::policy::DataReaderResourceLimits::max_remote_writers_per_instance</a>. </p>

</div>
</div>
<a class="anchor" id="a4cf50ab97e409ee2d3662b66d40d5946"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::max_remote_writers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a33466dc123f94b23eae592d664792162"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::max_remote_writers_per_instance </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_max_remote_writers_per_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of remote writers from which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may read a single instance. </p>
<p><b>[default]</b> <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a> <br/>
 </p>
<p><b>[range]</b> [1, 1024] or <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a>, &lt;= max_remote_writers or <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a>, &gt;= initial_remote_writers_per_instance </p>
<p>For unkeyed types, this value has to be equal to max_remote_writers if it is not <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a>. </p>
<p>Note: For efficiency, set <code>max_remote_writers_per_instance</code> &lt;= <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#aaf2c2030130fe254f09742302b6beef6" title="The maximum number of remote writers from which a dds::sub::DataReader may read, including all instan...">rti::core::policy::DataReaderResourceLimits::max_remote_writers</a> </p>

</div>
</div>
<a class="anchor" id="ab176c51db66353feef4beee4bb74b6b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::max_remote_writers_per_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a843b1e56a46d11df546911c7a7d929b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::max_samples_per_remote_writer </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_max_samples_per_remote_writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of out-of-order samples from a given remote <a class="el" href="classdds_1_1pub_1_1DataWriter.html" title="&lt;&lt;reference-type&gt;&gt; Allows an application to publish data for a dds::topic::Topic">dds::pub::DataWriter</a> that a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may store when maintaining a reliable connection to the <a class="el" href="classdds_1_1pub_1_1DataWriter.html" title="&lt;&lt;reference-type&gt;&gt; Allows an application to publish data for a dds::topic::Topic">dds::pub::DataWriter</a>. </p>
<p><b>[default]</b> <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a> </p>
<p><b>[range]</b> [1, 100 million] or <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a>, &lt;= <a class="el" href="classdds_1_1core_1_1policy_1_1ResourceLimits.html#aae52ffb5c5774ef44b6196a323cdcd70" title="Sets the maximum number of data samples that a DataWriter or a DataReader can manage across all insta...">dds::core::policy::ResourceLimits::max_samples</a> </p>

</div>
</div>
<a class="anchor" id="a26e9b31280a16149ef8e16e74c159d00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::max_samples_per_remote_writer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a0e96cfcc20fa553f8a0fa58d4b6efe7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::max_infos </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_max_infos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of info units that a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> can use to store <a class="el" href="classdds_1_1sub_1_1SampleInfo.html" title="&lt;&lt;value-type&gt;&gt; Information that accompanies each sample received by a DataReader">dds::sub::SampleInfo</a>. </p>
<p>When read/take is called on a DataReader, the DataReader passes a sequence of data samples and an associated sample info sequence. The sample info sequence contains additional information for each data sample. </p>
<p>max_infos determines the resources allocated for storing sample info. This memory is loaned to the application when passing a sample info sequence. </p>
<p>Note that sample info is a snapshot, generated when read/take is called. </p>
<p>max_infos should not be less than max_samples. </p>
<p><b>[default]</b> <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a> </p>
<p><b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a>, &gt;= initial_infos </p>

</div>
</div>
<a class="anchor" id="a1b80b4eac2071a19c55f99cedc9adfd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::max_infos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="ad28ec118e4547d04467812c97093a3c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::initial_remote_writers </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_initial_remote_writers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of remote writers from which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may read, including all instances. </p>
<p><b>[default]</b> 2<br/>
 </p>
<p><b>[range]</b> [1, 1 million], &lt;= max_remote_writers<br/>
 </p>
<p>For unkeyed types this value has to be equal to initial_remote_writers_per_instance.<br/>
 </p>
<p>Note: For efficiency, set initial_remote_writers &gt;= <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#ab75c499b7ed7887b50d7803268196206" title="The initial number of remote writers from which a dds::sub::DataReader may read a single instance...">rti::core::policy::DataReaderResourceLimits::initial_remote_writers_per_instance</a>. </p>

</div>
</div>
<a class="anchor" id="a5f5ab328cc3c39593d6070bc6528205f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::initial_remote_writers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="ab75c499b7ed7887b50d7803268196206"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::initial_remote_writers_per_instance </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_initial_remote_writers_per_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of remote writers from which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may read a single instance. </p>
<p><b>[default]</b> 2<br/>
 </p>
<p><b>[range]</b> [1,1024], &lt;= max_remote_writers_per_instance<br/>
 </p>
<p>For unkeyed types this value has to be equal to initial_remote_writers.<br/>
 </p>
<p>Note: For efficiency, set initial_remote_writers_per_instance &lt;= <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#ad28ec118e4547d04467812c97093a3c9" title="The initial number of remote writers from which a dds::sub::DataReader may read, including all instan...">rti::core::policy::DataReaderResourceLimits::initial_remote_writers</a>. </p>

</div>
</div>
<a class="anchor" id="abb0d31e9b0d588c215af96dcacc3a5dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::initial_remote_writers_per_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a80df3c9c5f3e52193116c257d115b7f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::initial_infos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a27ab913a61a307350f4789f37387daab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::initial_outstanding_reads </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_initial_outstanding_reads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of outstanding calls to read/take (or one of their variants) on the same <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> for which memory has not been returned by calling <a class="el" href="classdds_1_1sub_1_1LoanedSamples.html#a2ee7565b32560ab659981da69a2f4bfb" title="Returns the samples to the container // TODO.">dds::sub::LoanedSamples::return_loan()</a>. </p>
<p><b>[default]</b> 2 </p>
<p><b>[range]</b> [1, 65536], &lt;= max_outstanding_reads </p>

</div>
</div>
<a class="anchor" id="ae36c164a5c9df7f7939e53894a508226"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::initial_outstanding_reads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a9502966c7115a8342683a9563541d46e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::max_outstanding_reads </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_max_outstanding_reads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of outstanding read/take calls (or one of their variants) on the same <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> for which memory has not been returned by calling <a class="el" href="classdds_1_1sub_1_1LoanedSamples.html#a2ee7565b32560ab659981da69a2f4bfb" title="Returns the samples to the container // TODO.">dds::sub::LoanedSamples::return_loan()</a>. </p>
<p><b>[default]</b> <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a> </p>
<p><b>[range]</b> [1, 65536] or <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a>, &gt;= initial_outstanding_reads </p>

</div>
</div>
<a class="anchor" id="a39cd801f9df2b53992258a3044aa81de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::max_outstanding_reads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a60c935442b2bffb8acbdc71ae05326cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::max_samples_per_read </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_max_samples_per_read</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of data samples that the application can receive from the middleware in a single call to <a class="el" href="classdds_1_1sub_1_1DataReader.html#a864f65d2246d2f854cf0b892ff6b8631" title="Read all samples using the default filter state.">dds::sub::DataReader::read</a> or <a class="el" href="classdds_1_1sub_1_1DataReader.html#aa63c8e102e4abd5446198bcfe71ebfe1" title="Take all samples using the default filter state.">dds::sub::DataReader::take</a>. If more data exists in the middleware, the application will need to issue multiple read/take calls. </p>
<p>When reading data using listeners, the expected number of samples available for delivery in a single <code>take</code> call is typically small: usually just one, in the case of unbatched data, or the number of samples in a single batch, in the case of batched data. (See <a class="el" href="classrti_1_1core_1_1policy_1_1Batch.html" title="&lt;&lt;extension&gt;&gt; Allows a dds::pub::DataWriter to batch multiple samples into a single network packet to...">rti::core::policy::Batch</a> for more information about this feature.) When polling for data or using a <a class="el" href="classdds_1_1core_1_1cond_1_1WaitSet.html" title="&lt;&lt;reference-type&gt;&gt; Allows an application to wait until one or more of the attached Condition objects ...">dds::core::cond::WaitSet</a>, however, multiple samples (or batches) could be retrieved at once, depending on the data rate. </p>
<p>A larger value for this parameter makes the API simpler to use at the expense of some additional memory consumption. </p>
<p><b>[default]</b> 1024 </p>
<p><b>[range]</b> [1,65536] </p>

</div>
</div>
<a class="anchor" id="a1ed40e358555e1bf50ce1da98cf679e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::max_samples_per_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a402c42ca6e2d3e58f52c69887bdc480c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::disable_fragmentation_support </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>the_disable_fragmentation_support</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> can receive fragmented samples. </p>
<p>When fragmentation support is not needed, disabling fragmentation support will save some memory resources. </p>
<p><b>[default]</b> false </p>

</div>
</div>
<a class="anchor" id="aa6efa34e04e72d330437b9b9ef2d015f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rti::core::policy::DataReaderResourceLimits::disable_fragmentation_support </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a66442e068410c27384a2cb2812b28a3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::max_fragmented_samples </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_max_fragmented_samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of samples for which the <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may store fragments at a given point in time. </p>
<p>At any given time, a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may store fragments for up to <code>max_fragmented_samples</code> samples while waiting for the remaining fragments. These samples need not have consecutive sequence numbers and may have been sent by different <a class="el" href="classdds_1_1pub_1_1DataWriter.html" title="&lt;&lt;reference-type&gt;&gt; Allows an application to publish data for a dds::topic::Topic">dds::pub::DataWriter</a> instances. </p>
<p>Once all fragments of a sample have been received, the sample is treated as a regular sample and becomes subject to standard QoS settings such as <a class="el" href="classdds_1_1core_1_1policy_1_1ResourceLimits.html#aae52ffb5c5774ef44b6196a323cdcd70" title="Sets the maximum number of data samples that a DataWriter or a DataReader can manage across all insta...">dds::core::policy::ResourceLimits::max_samples</a>. </p>
<p>The middleware will drop fragments if the <code>max_fragmented_samples</code> limit has been reached. For best-effort communication, the middleware will accept a fragment for a new sample, but drop the oldest fragmented sample from the same remote writer. For reliable communication, the middleware will drop fragments for any new samples until all fragments for at least one older sample from that writer have been received. </p>
<p>Only applies if <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a402c42ca6e2d3e58f52c69887bdc480c" title="Determines whether the dds::sub::DataReader can receive fragmented samples.">rti::core::policy::DataReaderResourceLimits::disable_fragmentation_support</a> is false. </p>
<p><b>[default]</b> 1024 </p>
<p><b>[range]</b> [1, 1 million] </p>

</div>
</div>
<a class="anchor" id="a2561c9a8a1c7d37aa57cf388e8e9c69e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::max_fragmented_samples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a17acb17b9ef5ffb7126c7a37d860f57a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::initial_fragmented_samples </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_initial_fragmented_samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of samples for which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may store fragments. </p>
<p>Only applies if <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a402c42ca6e2d3e58f52c69887bdc480c" title="Determines whether the dds::sub::DataReader can receive fragmented samples.">rti::core::policy::DataReaderResourceLimits::disable_fragmentation_support</a> is false. </p>
<p><b>[default]</b> 4 </p>
<p><b>[range]</b> [1,1024], &lt;= max_fragmented_samples </p>

</div>
</div>
<a class="anchor" id="aa86aa80b4c9036bc842669d67c22d7e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::initial_fragmented_samples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a3399b71c5906902be89a4b5d5de2e762"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::max_fragmented_samples_per_remote_writer </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_max_fragmented_samples_per_remote_writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of samples per remote writer for which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may store fragments. </p>
<p>Logical limit so a single remote writer cannot consume all available resources. </p>
<p>Only applies if <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a402c42ca6e2d3e58f52c69887bdc480c" title="Determines whether the dds::sub::DataReader can receive fragmented samples.">rti::core::policy::DataReaderResourceLimits::disable_fragmentation_support</a> is false. </p>
<p><b>[default]</b> 256 </p>
<p><b>[range]</b> [1, 1 million], &lt;= max_fragmented_samples </p>

</div>
</div>
<a class="anchor" id="ab020931ddb1e21eb8975f70054a9c386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::max_fragmented_samples_per_remote_writer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a6daad429f29ae958e400a3d415b1dbe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::max_fragments_per_sample </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_max_fragments_per_sample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of fragments for a single sample. </p>
<p>Only applies if <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a402c42ca6e2d3e58f52c69887bdc480c" title="Determines whether the dds::sub::DataReader can receive fragmented samples.">rti::core::policy::DataReaderResourceLimits::disable_fragmentation_support</a> is false. </p>
<p><b>[default]</b> <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a> </p>
<p><b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a> </p>

</div>
</div>
<a class="anchor" id="ae1946e4336f6e667688cb061782b4155"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::max_fragments_per_sample </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a5235988e69052c6dd2441ace61359fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::dynamically_allocate_fragmented_samples </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>the_dynamically_allocate_fragmented_samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> pre-allocates storage for storing fragmented samples. </p>
<p>By default, the middleware does not allocate memory upfront, but instead allocates memory from the heap upon receiving the first fragment of a new sample. The amount of memory allocated equals the amount of memory needed to store all fragments in the sample. Once all fragments of a sample have been received, the sample is deserialized and stored in the regular receive queue. At that time, the dynamically allocated memory is freed again. </p>
<p>This QoS setting is useful for large, but variable-sized data types where upfront memory allocation for multiple samples based on the maximum possible sample size may be expensive. The main disadvantage of not pre-allocating memory is that one can no longer guarantee the middleware will have sufficient resources at run-time. </p>
<p>If <code>dynamically_allocate_fragmented_samples</code> is set to false, the middleware will allocate memory upfront for storing fragments for up to <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a17acb17b9ef5ffb7126c7a37d860f57a" title="The initial number of samples for which a dds::sub::DataReader may store fragments.">rti::core::policy::DataReaderResourceLimits::initial_fragmented_samples</a> samples. This memory may grow up to <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a66442e068410c27384a2cb2812b28a3e" title="The maximum number of samples for which the dds::sub::DataReader may store fragments at a given point...">rti::core::policy::DataReaderResourceLimits::max_fragmented_samples</a> if needed. </p>
<p>Only applies if <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a402c42ca6e2d3e58f52c69887bdc480c" title="Determines whether the dds::sub::DataReader can receive fragmented samples.">rti::core::policy::DataReaderResourceLimits::disable_fragmentation_support</a> is false. </p>
<p><b>[default]</b> true </p>

</div>
</div>
<a class="anchor" id="acd01c96e13e14b08545125471e6c7d97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rti::core::policy::DataReaderResourceLimits::dynamically_allocate_fragmented_samples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a501c49e23ec86d894ebc913f532a6d99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::max_total_instances </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_max_total_instances</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of instances for which a DataReader will keep state. </p>
<p>The maximum number of instances actively managed by a DataReader is determined by <a class="el" href="classdds_1_1core_1_1policy_1_1ResourceLimits.html#ac6e46e8c89931e992e4dccc6f79fa52c" title="Sets the maximum number of instances that a DataWriter or a DataReader can manage.">dds::core::policy::ResourceLimits::max_instances</a>. </p>
<p>These instances have associated DataWriters or samples in the DataReader's queue and are visible to the user through operations such as <a class="el" href="classdds_1_1sub_1_1DataReader.html#aa63c8e102e4abd5446198bcfe71ebfe1" title="Take all samples using the default filter state.">dds::sub::DataReader::take</a>, <a class="el" href="classdds_1_1sub_1_1DataReader.html#a864f65d2246d2f854cf0b892ff6b8631" title="Read all samples using the default filter state.">dds::sub::DataReader::read</a>, and <a class="el" href="classdds_1_1sub_1_1DataReader.html#a44fca51d1564498fd383611e7f16a43f" title="Retrieve the instance key that corresponds to an instance handle.">dds::sub::DataReader::key_value</a>. </p>
<p>The features Durable Reader State, <a class="el" href="classrti_1_1core_1_1policy_1_1MultiChannel.html" title="&lt;&lt;extension&gt;&gt; Configures the ability of a DataWriter to send data on different multicast groups (addr...">MultiChannel</a> DataWriters and RTI Persistence <a class="el" href="classrti_1_1core_1_1policy_1_1Service.html" title="&lt;&lt;extension&gt;&gt; Indicates if an Entity is associated with a service and if so, which one...">Service</a> require RTI Connext to keep some internal state even for instances without DataWriters or samples in the DataReader's queue. The additional state is used to filter duplicate samples that could be coming from different DataWriter channels or from multiple executions of RTI Persistence <a class="el" href="classrti_1_1core_1_1policy_1_1Service.html" title="&lt;&lt;extension&gt;&gt; Indicates if an Entity is associated with a service and if so, which one...">Service</a>. </p>
<p>The total maximum number of instances that will be managed by the middleware, including instances without associated DataWriters or samples, is determined by max_total_instances. </p>
<p>When a new instance is received, RTI Connext will check the resource limit <a class="el" href="classdds_1_1core_1_1policy_1_1ResourceLimits.html#ac6e46e8c89931e992e4dccc6f79fa52c" title="Sets the maximum number of instances that a DataWriter or a DataReader can manage.">dds::core::policy::ResourceLimits::max_instances</a>. If the limit is exceeded, RTI Connext will drop the sample and report it as lost and rejected. If the limit is not exceeded, RTI Connext will check max_total_instances. If max_total_instances is exceeded, RTI Connext will replace an existing instance without DataWriters and samples with the new one. The application could receive duplicate samples for the replaced instance if it becomes alive again. </p>
<p><b>[default]</b> AUTO_MAX_TOTAL_INSTANCES </p>
<p><b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a> or AUTO_MAX_TOTAL_INSTANCES, &gt;= <a class="el" href="classdds_1_1core_1_1policy_1_1ResourceLimits.html#ac6e46e8c89931e992e4dccc6f79fa52c" title="Sets the maximum number of instances that a DataWriter or a DataReader can manage.">dds::core::policy::ResourceLimits::max_instances</a> </p>

</div>
</div>
<a class="anchor" id="ae8df57cbd65d11ad1454c2151aa66de9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::max_total_instances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a160fcbc5bb1c7890bd641f19bb0409fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::max_remote_virtual_writers </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_max_remote_virtual_writers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of remote virtual writers from which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may read, including all instances. </p>
<p>When <a class="el" href="classdds_1_1core_1_1policy_1_1Presentation.html#a2ae91cee9c9a45bb1ea189d876aa8121" title="Determines the largest scope spanning the entities for which the order and coherency of changes can b...">dds::core::policy::Presentation::access_scope</a> is set to <a class="el" href="structdds_1_1core_1_1policy_1_1PresentationAccessScopeKind__def.html#a615c3569016cb9c6702721ab2709edc7acc3047f439e1da85244cd50ebd1629d6" title="Scope spans to all instances belonging to dds::pub::DataWriter (or dds::sub::DataReader) entities wit...">dds::core::policy::PresentationAccessScopeKind_def::GROUP</a>, this value determines the maximum number of DataWriter groups that can be managed by the <a class="el" href="classdds_1_1sub_1_1Subscriber.html" title="&lt;&lt;reference-type&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscrip...">dds::sub::Subscriber</a> containing this <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a>. </p>
<p>Since the <a class="el" href="classdds_1_1sub_1_1Subscriber.html" title="&lt;&lt;reference-type&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscrip...">dds::sub::Subscriber</a> may contain more than one <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a>, only the setting of the first applies. </p>
<p><b>[default]</b> <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a> <br/>
 <b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a>, &gt;= initial_remote_virtual_writers, &gt;= max_remote_virtual_writers_per_instance </p>

</div>
</div>
<a class="anchor" id="ad7c1ccbfbd437c24b95eb78f860ae780"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::max_remote_virtual_writers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a2d66482197f90dd206399784e788e54d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::initial_remote_virtual_writers </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_initial_remote_virtual_writers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of remote virtual writers from which a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> may read, including all instances. </p>
<p><b>[default]</b> 2 <br/>
 <b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a>, &lt;= max_remote_virtual_writers </p>

</div>
</div>
<a class="anchor" id="ae7d8ba194062615ad02c132e84624220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::initial_remote_virtual_writers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="ab33ace5818469ef9273b4e181e772153"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::max_remote_virtual_writers_per_instance </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_max_remote_virtual_writers_per_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of virtual remote writers that can be associated with an instance. </p>
<p><b>[default]</b> <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a> <br/>
 </p>
<p><b>[range]</b> [1, 1024] or <a class="el" href="group__DDSCPP2SupportingTypes.html#ga7f73c3110972d4a0180c20434664f661" title="A special value indicating an unlimited quantity.">dds::core::LENGTH_UNLIMITED</a>, &gt;= initial_remote_virtual_writers_per_instance </p>
<p>For unkeyed types, this value is ignored. </p>
<p>The features of Durable Reader State and <a class="el" href="classrti_1_1core_1_1policy_1_1MultiChannel.html" title="&lt;&lt;extension&gt;&gt; Configures the ability of a DataWriter to send data on different multicast groups (addr...">MultiChannel</a> DataWriters, and RTI Persistence <a class="el" href="classrti_1_1core_1_1policy_1_1Service.html" title="&lt;&lt;extension&gt;&gt; Indicates if an Entity is associated with a service and if so, which one...">Service</a> require RTI Connext to keep some internal state per virtual writer and instance that is used to filter duplicate samples. These duplicate samples could be coming from different DataWriter channels or from multiple executions of RTI Persistence <a class="el" href="classrti_1_1core_1_1policy_1_1Service.html" title="&lt;&lt;extension&gt;&gt; Indicates if an Entity is associated with a service and if so, which one...">Service</a>. </p>
<p>Once an association between a remote virtual writer and an instance is established, it is permanent &ndash; it will not disappear even if the physical writer incarnating the virtual writer is destroyed. </p>
<p>If max_remote_virtual_writers_per_instance is exceeded for an instance, RTI Connext will not associate this instance with new virtual writers. Duplicates samples from these virtual writers will not be filtered on the reader. </p>
<p>If you are not using Durable Reader State, <a class="el" href="classrti_1_1core_1_1policy_1_1MultiChannel.html" title="&lt;&lt;extension&gt;&gt; Configures the ability of a DataWriter to send data on different multicast groups (addr...">MultiChannel</a> DataWriters or RTI Persistence <a class="el" href="classrti_1_1core_1_1policy_1_1Service.html" title="&lt;&lt;extension&gt;&gt; Indicates if an Entity is associated with a service and if so, which one...">Service</a> in your system, you can set this property to 1 to optimize resources. </p>

</div>
</div>
<a class="anchor" id="a39208f0ed64b04cfa8b786ea6776c4f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::max_remote_virtual_writers_per_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="ae817e760c2f90e4174cbd15aaa280d39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::initial_remote_virtual_writers_per_instance </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_initial_remote_virtual_writers_per_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of virtual remote writers per instance. </p>
<p><b>[default]</b> 2<br/>
 </p>
<p><b>[range]</b> [1, 1024], &lt;= max_remote_virtual_writers_per_instance<br/>
 </p>
<p>For unkeyed types, this value is ignored.<br/>
 </p>

</div>
</div>
<a class="anchor" id="aee3ec8eef686c4ab55191f5352214b40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::initial_remote_virtual_writers_per_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="ac018fc863e5bc83d396e4a2e5802f313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::max_remote_writers_per_sample </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_max_remote_writers_per_sample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of remote writers allowed to write the same sample. </p>
<p>One scenario in which two DataWriters may write the same sample is Persistence <a class="el" href="classrti_1_1core_1_1policy_1_1Service.html" title="&lt;&lt;extension&gt;&gt; Indicates if an Entity is associated with a service and if so, which one...">Service</a>. The DataReader may receive the same sample coming from the original DataWriter and from a Persistence <a class="el" href="classrti_1_1core_1_1policy_1_1Service.html" title="&lt;&lt;extension&gt;&gt; Indicates if an Entity is associated with a service and if so, which one...">Service</a> DataWriter. <b>[default]</b> 3<br/>
 </p>
<p><b>[range]</b> [1, 1024]<br/>
 </p>

</div>
</div>
<a class="anchor" id="abe8b013b625f609628410f3c11ce84b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::max_remote_writers_per_sample </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a5dc0b97c463fd531a1dd00d95ce180ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::max_query_condition_filters </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_max_query_condition_filters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of query condition filters a reader is allowed. </p>
<p><b>[default]</b> 4<br/>
 </p>
<p><b>[range]</b> [0, 32]<br/>
 </p>
<p>This value determines the maximum number of unique query condition content filters that a reader may create. </p>
<p>Each query condition content filter is comprised of both its <code>query_expression</code> and <code>query_parameters</code>. Two query conditions that have the same <code>query_expression</code> will require unique query condition filters if their <code>query_paramters</code> differ. Query conditions that differ only in their state masks will share the same query condition filter. </p>

</div>
</div>
<a class="anchor" id="a237895ee033e6b74aeac0b8c73b372c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::max_query_condition_filters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="abc77695f81cf933f693388f715997900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::max_app_ack_response_length </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>the_max_app_ack_response_length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length of application-level acknowledgment response data. </p>
<p>The maximum length of response data in an application-level acknowledgment. </p>
<p>When set to zero, no response data is sent with application-level acknowledgments. </p>
<p><b>[default]</b> 0 </p>
<p><b>[range]</b> [0, 65536] </p>

</div>
</div>
<a class="anchor" id="afd0e69751341b92b40ed3099ff9d4f54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rti::core::policy::DataReaderResourceLimits::max_app_ack_response_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="afe05fabccf4e96f8acdd7397afe5f4d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html">DataReaderResourceLimits</a>&amp; rti::core::policy::DataReaderResourceLimits::keep_minimum_state_for_instances </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>the_keep_minimum_state_for_instances</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not keep a minimum instance state for up to <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a501c49e23ec86d894ebc913f532a6d99" title="Maximum number of instances for which a DataReader will keep state.">rti::core::policy::DataReaderResourceLimits::max_total_instances</a>. </p>
<p>The features Durable Reader State, multi-channel DataWriters, and Persistence <a class="el" href="classrti_1_1core_1_1policy_1_1Service.html" title="&lt;&lt;extension&gt;&gt; Indicates if an Entity is associated with a service and if so, which one...">Service</a> require RTI Connext to keep some minimal internal state even for instances without DataWriters or DDS samples in the DataReader's queue, or that have been purged due to a dispose. The additional state is used to filter duplicate DDS samples that could be coming from different DataWriter channels or from multiple executions of Persistence <a class="el" href="classrti_1_1core_1_1policy_1_1Service.html" title="&lt;&lt;extension&gt;&gt; Indicates if an Entity is associated with a service and if so, which one...">Service</a>. The total maximum number of instances that will be managed by the middleware, including instances without associated DataWriters or DDS samples or that have been purged due to a dispose, is determined by <a class="el" href="classrti_1_1core_1_1policy_1_1DataReaderResourceLimits.html#a501c49e23ec86d894ebc913f532a6d99" title="Maximum number of instances for which a DataReader will keep state.">rti::core::policy::DataReaderResourceLimits::max_total_instances</a>. </p>
<p>This additional state will only be kept for up to max_total_instances if this field is set to true, otherwise the additional state will not be kept for any instances. </p>
<p><b>[default]</b> true </p>

</div>
</div>
<a class="anchor" id="a9fd9f44633056796d5c484b4538df8ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rti::core::policy::DataReaderResourceLimits::keep_minimum_state_for_instances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Connext Modern C++ API Version 5.2.3</A>
Copyright &copy; Wed Apr 27 2016 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
