<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>RTI Connext Modern C++ API: dds::core::policy::ReaderDataLifecycle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RTI Connext Modern C++ API
   &#160;<span id="projectnumber">Version 5.2.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2-20120808 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dds::core::policy::ReaderDataLifecycle Class Reference<div class="ingroups"><a class="el" href="group__DDSReaderDataLifecycleQosModule.html">READER_DATA_LIFECYCLE</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Controls how a DataReader manages the lifecycle of the data that it has received.  
 <a href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html#details">More...</a></p>

<p><code>#include &lt;dds/core/policy/CorePolicy.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0bf55009de27284c29a6249259ee01de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html#a0bf55009de27284c29a6249259ee01de">ReaderDataLifecycle</a> ()</td></tr>
<tr class="memdesc:a0bf55009de27284c29a6249259ee01de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the default policy.  <a href="#a0bf55009de27284c29a6249259ee01de"></a><br/></td></tr>
<tr class="separator:a0bf55009de27284c29a6249259ee01de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf3f4ee02b0c626287243b4645d027b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html#a5bf3f4ee02b0c626287243b4645d027b">ReaderDataLifecycle</a> (const <a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> &amp;the_nowriter_delay, const <a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> &amp;the_disposed_samples_delay)</td></tr>
<tr class="memdesc:a5bf3f4ee02b0c626287243b4645d027b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance with the specified nowriter and disposed-samples purge delays.  <a href="#a5bf3f4ee02b0c626287243b4645d027b"></a><br/></td></tr>
<tr class="separator:a5bf3f4ee02b0c626287243b4645d027b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ad5de52366b7eeb000b3cbffe4d173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html">ReaderDataLifecycle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html#ad8ad5de52366b7eeb000b3cbffe4d173">autopurge_nowriter_samples_delay</a> (const <a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> &amp;duration)</td></tr>
<tr class="memdesc:ad8ad5de52366b7eeb000b3cbffe4d173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum duration for which the DataReader will maintain information regarding an instance once its <code>instance_state</code> becomes InstanceStateKind::NOT_ALIVE_NO_WRITERS.  <a href="#ad8ad5de52366b7eeb000b3cbffe4d173"></a><br/></td></tr>
<tr class="separator:ad8ad5de52366b7eeb000b3cbffe4d173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f390c1f06b40a5cb84fa9b452109a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html#ab7f390c1f06b40a5cb84fa9b452109a2">autopurge_nowriter_samples_delay</a> () const </td></tr>
<tr class="memdesc:ab7f390c1f06b40a5cb84fa9b452109a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#ab7f390c1f06b40a5cb84fa9b452109a2"></a><br/></td></tr>
<tr class="separator:ab7f390c1f06b40a5cb84fa9b452109a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1a161cee5f58a25e6f8033516b98cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html">ReaderDataLifecycle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html#a8b1a161cee5f58a25e6f8033516b98cc">autopurge_disposed_samples_delay</a> (const <a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> &amp;duration)</td></tr>
<tr class="memdesc:a8b1a161cee5f58a25e6f8033516b98cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum duration for which the DataReader will maintain information regarding an instance once its <code>instance_state</code> becomes InstanceStateKind::NOT_ALIVE_DISPOSED.  <a href="#a8b1a161cee5f58a25e6f8033516b98cc"></a><br/></td></tr>
<tr class="separator:a8b1a161cee5f58a25e6f8033516b98cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d323857cde66394fcfabaec23925146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html#a9d323857cde66394fcfabaec23925146">autopurge_disposed_samples_delay</a> () const </td></tr>
<tr class="memdesc:a9d323857cde66394fcfabaec23925146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter (see setter with the same name)  <a href="#a9d323857cde66394fcfabaec23925146"></a><br/></td></tr>
<tr class="separator:a9d323857cde66394fcfabaec23925146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924223d6f76ce1360e838d8b86786076"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html">dds::core::policy::ReaderDataLifecycle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html#a924223d6f76ce1360e838d8b86786076">autopurge_disposed_instances_delay</a> (const <a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> &amp;duration)</td></tr>
<tr class="memdesc:a924223d6f76ce1360e838d8b86786076"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSCpp2Conventions.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Minimum duration for which the DataReader will maintain an instance once its <code>instance_state</code> becomes InstanceStateKind::NOT_ALIVE_DISPOSED.  <a href="#a924223d6f76ce1360e838d8b86786076"></a><br/></td></tr>
<tr class="separator:a924223d6f76ce1360e838d8b86786076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e2a652e194897caf1ae9bf9f8caae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html#ab9e2a652e194897caf1ae9bf9f8caae6">autopurge_disposed_instances_delay</a> () const</td></tr>
<tr class="memdesc:ab9e2a652e194897caf1ae9bf9f8caae6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSCpp2Conventions.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Getter (see setter with the same name)  <a href="#ab9e2a652e194897caf1ae9bf9f8caae6"></a><br/></td></tr>
<tr class="separator:ab9e2a652e194897caf1ae9bf9f8caae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2491937f78a93fca52a4c27cfad7376f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html">ReaderDataLifecycle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html#a2491937f78a93fca52a4c27cfad7376f">NoAutoPurge</a> ()</td></tr>
<tr class="memdesc:a2491937f78a93fca52a4c27cfad7376f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a policy where all purge delays are disabled (the default)  <a href="#a2491937f78a93fca52a4c27cfad7376f"></a><br/></td></tr>
<tr class="separator:a2491937f78a93fca52a4c27cfad7376f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c22be4171d97c0b808c45b9861c2b13"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html">ReaderDataLifecycle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html#a6c22be4171d97c0b808c45b9861c2b13">AutoPurgeDisposedSamples</a> (const <a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> &amp;duration)</td></tr>
<tr class="memdesc:a6c22be4171d97c0b808c45b9861c2b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a policy where only the disposed-samples purge delay is enabled with a specified duration.  <a href="#a6c22be4171d97c0b808c45b9861c2b13"></a><br/></td></tr>
<tr class="separator:a6c22be4171d97c0b808c45b9861c2b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94c41c8b3ed2d53c2bebb7cd3e16905"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html">ReaderDataLifecycle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html#ad94c41c8b3ed2d53c2bebb7cd3e16905">AutoPurgeNoWriterSamples</a> (const <a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> &amp;d)</td></tr>
<tr class="memdesc:ad94c41c8b3ed2d53c2bebb7cd3e16905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a policy where only the no-writer purge delay is enabled with a specified duration.  <a href="#ad94c41c8b3ed2d53c2bebb7cd3e16905"></a><br/></td></tr>
<tr class="separator:ad94c41c8b3ed2d53c2bebb7cd3e16905"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Controls how a DataReader manages the lifecycle of the data that it has received. </p>
<p>When a DataReader receives data, it is stored in a receive queue for the DataReader. The user application may either take the data from the queue or leave it there. </p>
<p>This QoS policy controls whether or not RTI Connext will automatically remove data from the receive queue (so that user applications cannot access it afterwards) when it detects that there are no more DataWriters alive for that data. It specifies how long a <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> must retain information regarding instances that have the instance_state <a class="el" href="classdds_1_1sub_1_1status_1_1InstanceState.html#aaaf8cee2916adfe3dce35985dc2a05f5" title="Creates a not_alive_no_writers InstanceState object.">dds::sub::status::InstanceState::not_alive_no_writers()</a>. </p>
<p>Note: This policy is not concerned with keeping reliable reader state or discovery information. </p>
<p>The <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> internally maintains the samples that have not been "taken" by the application, subject to the constraints imposed by other QoS policies such as <a class="el" href="classdds_1_1core_1_1policy_1_1History.html" title="Specifies how much historical data a dds::pub::DataWriter and a dds::sub::DataReader can store...">dds::core::policy::History</a> and <a class="el" href="classdds_1_1core_1_1policy_1_1ResourceLimits.html" title="Controls the memory usage of dds::pub::DataWriter or a dds::sub::DataReader.">dds::core::policy::ResourceLimits</a>. </p>
<p>The <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> also maintains information regarding the identity, <code>view_state</code> and <code>instance_state</code> of data instances even after all samples have been taken. This is needed to properly compute the states when future samples arrive. </p>
<p>Under normal circumstances the <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> can only reclaim all resources for instances for which there are no writers and for which all samples have been 'taken'. The last sample the <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> will have taken for that instance will have an <code>instance_state</code> of either <a class="el" href="classdds_1_1sub_1_1status_1_1InstanceState.html#aaaf8cee2916adfe3dce35985dc2a05f5" title="Creates a not_alive_no_writers InstanceState object.">dds::sub::status::InstanceState::not_alive_no_writers()</a> or <a class="el" href="classdds_1_1sub_1_1status_1_1InstanceState.html#a2e518cf3afa4fa47ad989ee81a5cb27e" title="Creates a not_alive_disposed InstanceState object.">dds::sub::status::InstanceState::not_alive_disposed()</a> depending on whether or not the last writer that had ownership of the instance disposed it. </p>
<p>In the absence of <a class="el" href="group__DDSReaderDataLifecycleQosModule.html">READER_DATA_LIFECYCLE</a>, this behavior could cause problems if the application forgets to take those samples. "Untaken" samples will prevent the <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> from reclaiming the resources and they would remain in the <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> indefinitely. </p>
<p>A DataReader can also reclaim all resources for instances that have an instance state of <a class="el" href="classdds_1_1sub_1_1status_1_1InstanceState.html#a2e518cf3afa4fa47ad989ee81a5cb27e" title="Creates a not_alive_disposed InstanceState object.">dds::sub::status::InstanceState::not_alive_disposed()</a> and for which all DDS samples have been 'taken'. DataReaders will only reclaim resources in this situation when the autopurge_disposed_instances_delay has been set to zero. </p>
<p>For keyed Topics, the consideration of removing data samples from the receive queue is done on a per instance (key) basis. Thus when RTI Connext detects that there are no longer DataWriters alive for a certain key value of a Topic (an instance of the Topic), it can be configured to remove all data samples for that instance (key). </p>
<dl class="section user"><dt>Entity:</dt><dd><a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> </dd></dl>
<dl class="section user"><dt>Properties:</dt><dd><a class="el" href="group__DDSQosTypesModule.html#a_prop_rxo">RxO</a> = N/A<br/>
 <a class="el" href="group__DDSQosTypesModule.html#a_prop_changeable">Changeable</a> = <a class="el" href="group__DDSQosTypesModule.html#a_prop_changeable_yes">YES</a> <br/>
 </dd></dl>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0bf55009de27284c29a6249259ee01de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dds::core::policy::ReaderDataLifecycle::ReaderDataLifecycle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the default policy. </p>

</div>
</div>
<a class="anchor" id="a5bf3f4ee02b0c626287243b4645d027b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dds::core::policy::ReaderDataLifecycle::ReaderDataLifecycle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> &amp;&#160;</td>
          <td class="paramname"><em>the_nowriter_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> &amp;&#160;</td>
          <td class="paramname"><em>the_disposed_samples_delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an instance with the specified nowriter and disposed-samples purge delays. </p>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="ad8ad5de52366b7eeb000b3cbffe4d173"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html">ReaderDataLifecycle</a>&amp; dds::core::policy::ReaderDataLifecycle::autopurge_nowriter_samples_delay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> &amp;&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum duration for which the DataReader will maintain information regarding an instance once its <code>instance_state</code> becomes InstanceStateKind::NOT_ALIVE_NO_WRITERS. </p>
<p>At some point after this time elapses, the <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> will purge all internal information regarding the instance, any "untaken" samples will also be lost. </p>
<p><b>[default]</b> <a class="el" href="classdds_1_1core_1_1Duration.html#a50821943ed0af78d1272886a64eb4587" title="Special value that represents an infinite Duration.">dds::core::Duration::infinite()</a> </p>
<p><b>[range]</b> [1 nanosec, 1 year] or <a class="el" href="classdds_1_1core_1_1Duration.html#a50821943ed0af78d1272886a64eb4587" title="Special value that represents an infinite Duration.">dds::core::Duration::infinite()</a> </p>

</div>
</div>
<a class="anchor" id="ab7f390c1f06b40a5cb84fa9b452109a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> dds::core::policy::ReaderDataLifecycle::autopurge_nowriter_samples_delay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a8b1a161cee5f58a25e6f8033516b98cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html">ReaderDataLifecycle</a>&amp; dds::core::policy::ReaderDataLifecycle::autopurge_disposed_samples_delay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> &amp;&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum duration for which the DataReader will maintain information regarding an instance once its <code>instance_state</code> becomes InstanceStateKind::NOT_ALIVE_DISPOSED. </p>
<p>At some point after this time elapses, the <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> will purge all samples for the instance. </p>
<p><b>[default]</b> <a class="el" href="classdds_1_1core_1_1Duration.html#a50821943ed0af78d1272886a64eb4587" title="Special value that represents an infinite Duration.">dds::core::Duration::infinite()</a> </p>
<p><b>[range]</b> [1 nanosec, 1 year] or <a class="el" href="classdds_1_1core_1_1Duration.html#a50821943ed0af78d1272886a64eb4587" title="Special value that represents an infinite Duration.">dds::core::Duration::infinite()</a> </p>

</div>
</div>
<a class="anchor" id="a9d323857cde66394fcfabaec23925146"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> dds::core::policy::ReaderDataLifecycle::autopurge_disposed_samples_delay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter (see setter with the same name) </p>

</div>
</div>
<a class="anchor" id="a2491937f78a93fca52a4c27cfad7376f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html">ReaderDataLifecycle</a> dds::core::policy::ReaderDataLifecycle::NoAutoPurge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a policy where all purge delays are disabled (the default) </p>

</div>
</div>
<a class="anchor" id="a6c22be4171d97c0b808c45b9861c2b13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html">ReaderDataLifecycle</a> dds::core::policy::ReaderDataLifecycle::AutoPurgeDisposedSamples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> &amp;&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a policy where only the disposed-samples purge delay is enabled with a specified duration. </p>

</div>
</div>
<a class="anchor" id="ad94c41c8b3ed2d53c2bebb7cd3e16905"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html">ReaderDataLifecycle</a> dds::core::policy::ReaderDataLifecycle::AutoPurgeNoWriterSamples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a policy where only the no-writer purge delay is enabled with a specified duration. </p>

</div>
</div>
<a class="anchor" id="a924223d6f76ce1360e838d8b86786076"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdds_1_1core_1_1policy_1_1ReaderDataLifecycle.html">dds::core::policy::ReaderDataLifecycle</a> &amp; autopurge_disposed_instances_delay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> &amp;&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em><a class="el" href="group__DDSCpp2Conventions.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Minimum duration for which the DataReader will maintain an instance once its <code>instance_state</code> becomes InstanceStateKind::NOT_ALIVE_DISPOSED. </p>
<p>At some point after this time elapses, the <a class="el" href="classdds_1_1sub_1_1DataReader.html" title="&lt;&lt;reference-type&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">dds::sub::DataReader</a> will purge all knowledge of the instance. </p>
<p>The only currently supported values are 0 and <a class="el" href="classdds_1_1core_1_1Duration.html#a50821943ed0af78d1272886a64eb4587" title="Special value that represents an infinite Duration.">dds::core::Duration::infinite()</a>. A value of 0 will purge an instance's state immediately after the instance state transitions to <a class="el" href="classdds_1_1sub_1_1status_1_1InstanceState.html#a2e518cf3afa4fa47ad989ee81a5cb27e" title="Creates a not_alive_disposed InstanceState object.">dds::sub::status::InstanceState::not_alive_disposed()</a>, as long as all samples, including the dispose sample, associated with that instance have been 'taken'. </p>
<p><b>[default]</b> <a class="el" href="classdds_1_1core_1_1Duration.html#a50821943ed0af78d1272886a64eb4587" title="Special value that represents an infinite Duration.">dds::core::Duration::infinite()</a> </p>

</div>
</div>
<a class="anchor" id="ab9e2a652e194897caf1ae9bf9f8caae6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdds_1_1core_1_1Duration.html">dds::core::Duration</a> autopurge_disposed_instances_delay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em><a class="el" href="group__DDSCpp2Conventions.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Getter (see setter with the same name) </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Connext Modern C++ API Version 5.2.3</A>
Copyright &copy; Wed Apr 27 2016 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
