<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>RTI Connext C API: Sequence Support</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RTI Connext C API
   &#160;<span id="projectnumber">Version 5.2.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2-20120808 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__DDSSequenceModule.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sequence Support</div>  </div>
<div class="ingroups"><a class="el" href="group__DDSInfrastructureModule.html">Infrastructure Module</a></div></div><!--header-->
<div class="contents">

<p>The <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> interface allows you to work with variable-length collections of homogeneous data.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__DDSBuiltinSequenceModule"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSBuiltinSequenceModule.html">Built-in Sequences</a></td></tr>
<tr class="memdesc:group__DDSBuiltinSequenceModule"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines sequences of primitive data type. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html">FooSeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> <em><a class="el" href="group__DDSDocGuideModule.html#a_st_generic">&lt;&lt;generic&gt;&gt;</a></em> A type-safe, ordered collection of elements. The type of these elements is referred to in this documentation as <code><a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a></code>.  <a href="structFooSeq.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga521eb819a3b85277debce55d61b08f82"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga521eb819a3b85277debce55d61b08f82">DDS_SEQUENCE_INITIALIZER</a></td></tr>
<tr class="memdesc:ga521eb819a3b85277debce55d61b08f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">An initializer for new sequence instances.  <a href="#ga521eb819a3b85277debce55d61b08f82"></a><br/></td></tr>
<tr class="separator:ga521eb819a3b85277debce55d61b08f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga247367cb6c2a478370327b3628b6ef81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga247367cb6c2a478370327b3628b6ef81">FooSeq_initialize</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self)</td></tr>
<tr class="memdesc:ga247367cb6c2a478370327b3628b6ef81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize sequence instances.  <a href="#ga247367cb6c2a478370327b3628b6ef81"></a><br/></td></tr>
<tr class="separator:ga247367cb6c2a478370327b3628b6ef81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3765cd5c745da088f3772a1a8578cef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#gab3765cd5c745da088f3772a1a8578cef">FooSeq_get_maximum</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> *self)</td></tr>
<tr class="memdesc:gab3765cd5c745da088f3772a1a8578cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current maximum number of elements that can be stored in this sequence.  <a href="#gab3765cd5c745da088f3772a1a8578cef"></a><br/></td></tr>
<tr class="separator:gab3765cd5c745da088f3772a1a8578cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf5b537079d3997b4acddc9a4af11c63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#gadf5b537079d3997b4acddc9a4af11c63">FooSeq_set_maximum</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> new_max)</td></tr>
<tr class="memdesc:gadf5b537079d3997b4acddc9a4af11c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize this sequence to a new desired maximum.  <a href="#gadf5b537079d3997b4acddc9a4af11c63"></a><br/></td></tr>
<tr class="separator:gadf5b537079d3997b4acddc9a4af11c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a45e00319eeb1ddf5c84ac68657adb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#gaf7a45e00319eeb1ddf5c84ac68657adb">FooSeq_get_length</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> *self)</td></tr>
<tr class="memdesc:gaf7a45e00319eeb1ddf5c84ac68657adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the logical length of this sequence.  <a href="#gaf7a45e00319eeb1ddf5c84ac68657adb"></a><br/></td></tr>
<tr class="separator:gaf7a45e00319eeb1ddf5c84ac68657adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6f7cf4be9012fee3ca476c69f821bc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#gaa6f7cf4be9012fee3ca476c69f821bc6">FooSeq_set_length</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> new_length)</td></tr>
<tr class="memdesc:gaa6f7cf4be9012fee3ca476c69f821bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the length of this sequence.  <a href="#gaa6f7cf4be9012fee3ca476c69f821bc6"></a><br/></td></tr>
<tr class="separator:gaa6f7cf4be9012fee3ca476c69f821bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c3c42ee1154be119266c8e6fff3659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga85c3c42ee1154be119266c8e6fff3659">FooSeq_ensure_length</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> length, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> max)</td></tr>
<tr class="memdesc:ga85c3c42ee1154be119266c8e6fff3659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sequence to the desired length, and resize the sequence if necessary.  <a href="#ga85c3c42ee1154be119266c8e6fff3659"></a><br/></td></tr>
<tr class="separator:ga85c3c42ee1154be119266c8e6fff3659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eb9a7dd63886579379aa2ac9d786c05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFoo.html">Foo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga1eb9a7dd63886579379aa2ac9d786c05">FooSeq_get</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> i)</td></tr>
<tr class="memdesc:ga1eb9a7dd63886579379aa2ac9d786c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <code>i-th</code> element for a <code>const</code> sequence.  <a href="#ga1eb9a7dd63886579379aa2ac9d786c05"></a><br/></td></tr>
<tr class="separator:ga1eb9a7dd63886579379aa2ac9d786c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae45e554a45615fedbb75398a3e3f9fea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFoo.html">Foo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#gae45e554a45615fedbb75398a3e3f9fea">FooSeq_get_reference</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> i)</td></tr>
<tr class="memdesc:gae45e554a45615fedbb75398a3e3f9fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the <code>i-th</code> element of this sequence.  <a href="#gae45e554a45615fedbb75398a3e3f9fea"></a><br/></td></tr>
<tr class="separator:gae45e554a45615fedbb75398a3e3f9fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga145a30d7e8f1a6d5c0c3c80e4b6b4e1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga145a30d7e8f1a6d5c0c3c80e4b6b4e1e">FooSeq_copy_no_alloc</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, const struct <a class="el" href="structFooSeq.html">FooSeq</a> *src_seq)</td></tr>
<tr class="memdesc:ga145a30d7e8f1a6d5c0c3c80e4b6b4e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy elements from another sequence, only if the destination sequence has enough capacity.  <a href="#ga145a30d7e8f1a6d5c0c3c80e4b6b4e1e"></a><br/></td></tr>
<tr class="separator:ga145a30d7e8f1a6d5c0c3c80e4b6b4e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1eeab81b351a4fbb79c11a85ceb485b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#gab1eeab81b351a4fbb79c11a85ceb485b">FooSeq_copy</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, const struct <a class="el" href="structFooSeq.html">FooSeq</a> *src_seq)</td></tr>
<tr class="memdesc:gab1eeab81b351a4fbb79c11a85ceb485b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy elements from another sequence, resizing the sequence if necessary.  <a href="#gab1eeab81b351a4fbb79c11a85ceb485b"></a><br/></td></tr>
<tr class="separator:gab1eeab81b351a4fbb79c11a85ceb485b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11413fcc7cc13ccfeb7d5048648ce1e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga11413fcc7cc13ccfeb7d5048648ce1e7">FooSeq_from_array</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, const <a class="el" href="structFoo.html">Foo</a> array[], <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> length)</td></tr>
<tr class="memdesc:ga11413fcc7cc13ccfeb7d5048648ce1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy elements from an array of elements, resizing the sequence if necessary. The original contents of the sequence (if any) are replaced.  <a href="#ga11413fcc7cc13ccfeb7d5048648ce1e7"></a><br/></td></tr>
<tr class="separator:ga11413fcc7cc13ccfeb7d5048648ce1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2efcc1d05bcbf4ff3054b0f0395d0922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga2efcc1d05bcbf4ff3054b0f0395d0922">FooSeq_to_array</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="structFoo.html">Foo</a> array[], <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> length)</td></tr>
<tr class="memdesc:ga2efcc1d05bcbf4ff3054b0f0395d0922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy elements to an array of elements. The original contents of the array (if any) are replaced.  <a href="#ga2efcc1d05bcbf4ff3054b0f0395d0922"></a><br/></td></tr>
<tr class="separator:ga2efcc1d05bcbf4ff3054b0f0395d0922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10d6e06dcf1653244945b0a6e73c7f53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga10d6e06dcf1653244945b0a6e73c7f53">FooSeq_loan_contiguous</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="structFoo.html">Foo</a> *buffer, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> new_length, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> new_max)</td></tr>
<tr class="memdesc:ga10d6e06dcf1653244945b0a6e73c7f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loan a contiguous buffer to this sequence.  <a href="#ga10d6e06dcf1653244945b0a6e73c7f53"></a><br/></td></tr>
<tr class="separator:ga10d6e06dcf1653244945b0a6e73c7f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71018e377836517dedb9b243bf10df05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga71018e377836517dedb9b243bf10df05">FooSeq_loan_discontiguous</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self, <a class="el" href="structFoo.html">Foo</a> **buffer, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> new_length, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> new_max)</td></tr>
<tr class="memdesc:ga71018e377836517dedb9b243bf10df05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loan a discontiguous buffer to this sequence.  <a href="#ga71018e377836517dedb9b243bf10df05"></a><br/></td></tr>
<tr class="separator:ga71018e377836517dedb9b243bf10df05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba7a2c4cf49f72627f9b445b697b2364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#gaba7a2c4cf49f72627f9b445b697b2364">FooSeq_unloan</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self)</td></tr>
<tr class="memdesc:gaba7a2c4cf49f72627f9b445b697b2364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the loaned buffer in the sequence and set the maximum to 0.  <a href="#gaba7a2c4cf49f72627f9b445b697b2364"></a><br/></td></tr>
<tr class="separator:gaba7a2c4cf49f72627f9b445b697b2364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5535ba97da0e77b45489a772759f2e83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFoo.html">Foo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#ga5535ba97da0e77b45489a772759f2e83">FooSeq_get_contiguous_buffer</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> *self)</td></tr>
<tr class="memdesc:ga5535ba97da0e77b45489a772759f2e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the contiguous buffer of the sequence.  <a href="#ga5535ba97da0e77b45489a772759f2e83"></a><br/></td></tr>
<tr class="separator:ga5535ba97da0e77b45489a772759f2e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf21100a0446978244dd3f80fa5bf922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFoo.html">Foo</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#gabf21100a0446978244dd3f80fa5bf922">FooSeq_get_discontiguous_buffer</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> *self)</td></tr>
<tr class="memdesc:gabf21100a0446978244dd3f80fa5bf922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the discontiguous buffer of the sequence.  <a href="#gabf21100a0446978244dd3f80fa5bf922"></a><br/></td></tr>
<tr class="separator:gabf21100a0446978244dd3f80fa5bf922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca64a79c4b5c96bb230cf3d5075f35aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#gaca64a79c4b5c96bb230cf3d5075f35aa">FooSeq_has_ownership</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> *self)</td></tr>
<tr class="memdesc:gaca64a79c4b5c96bb230cf3d5075f35aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the owned flag.  <a href="#gaca64a79c4b5c96bb230cf3d5075f35aa"></a><br/></td></tr>
<tr class="separator:gaca64a79c4b5c96bb230cf3d5075f35aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1a415ca306572994f50eb07476b5299"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSSequenceModule.html#gae1a415ca306572994f50eb07476b5299">FooSeq_finalize</a> (struct <a class="el" href="structFooSeq.html">FooSeq</a> *self)</td></tr>
<tr class="memdesc:gae1a415ca306572994f50eb07476b5299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate this sequence's buffer.  <a href="#gae1a415ca306572994f50eb07476b5299"></a><br/></td></tr>
<tr class="separator:gae1a415ca306572994f50eb07476b5299"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> interface allows you to work with variable-length collections of homogeneous data. </p>
<p>This interface is instantiated for each concrete element type in order to provide compile-time type safety to applications. The <a class="el" href="group__DDSBuiltinSequenceModule.html">Built-in Sequences</a> are pre-defined instantiations for the primitive data types. </p>
<p>When you use the <a class="el" href="group__DDSNddsgenModule.html">rtiddsgen</a> code generation tool, it will automatically generate concrete sequence instantiations for each of your own custom types. </p>
<h2>Macro Definition Documentation</h2>
<a class="anchor" id="ga521eb819a3b85277debce55d61b08f82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DDS_SEQUENCE_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An initializer for new sequence instances. </p>
<p>This constant will initialize a new sequence to a valid empty state. C language users should assign it to uninitialized sequence instances before using them, at the time they are declared, or use <a class="el" href="group__DDSSequenceModule.html#ga247367cb6c2a478370327b3628b6ef81" title="Initialize sequence instances.">FooSeq_initialize</a> as an alternative function to initialize new sequences. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="HelloWorld_subscriber_8c-example.html#a6">HelloWorld_subscriber.c</a>.</dd>
</dl>
</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="ga247367cb6c2a478370327b3628b6ef81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> FooSeq_initialize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize sequence instances. </p>
<p>Use this function to initialize new sequences to a valid emptu state. C users should initialize sequences before using them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSSequenceModule.html#ga521eb819a3b85277debce55d61b08f82" title="An initializer for new sequence instances.">DDS_SEQUENCE_INITIALIZER</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab3765cd5c745da088f3772a1a8578cef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> FooSeq_get_maximum </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current maximum number of elements that can be stored in this sequence. </p>
<p>The <code>maximum</code> of the sequence represents the maximum number of elements that the underlying buffer can hold. It does not represent the current number of elements. </p>
<p>The <code>maximum</code> is a non-negative number. It is initialized when the sequence is first created. </p>
<p><code>maximum</code> can only be changed with the <a class="el" href="group__DDSSequenceModule.html#gadf5b537079d3997b4acddc9a4af11c63" title="Resize this sequence to a new desired maximum.">FooSeq_set_maximum</a> operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current maximum of the sequence. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSSequenceModule.html#gaf7a45e00319eeb1ddf5c84ac68657adb" title="Get the logical length of this sequence.">FooSeq_get_length</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadf5b537079d3997b4acddc9a4af11c63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> FooSeq_set_maximum </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>new_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize this sequence to a new desired maximum. </p>
<p>This operation does nothing if the new desired maximum matches the current maximum. </p>
<p>If this sequence owns its buffer and the new maximum is not equal to the old maximum, then the existing buffer will be freed and re-allocated. </p>
<dl class="section pre"><dt>Precondition</dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </dd>
<dd>
length == MINIMUM(original length, new_max) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">new_max</td><td>Must be &gt;= 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> on success, <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> if the preconditions are not met. In that case the sequence is not modified. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf7a45e00319eeb1ddf5c84ac68657adb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> FooSeq_get_length </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the logical length of this sequence. </p>
<p>Get the length that was last set, or zero if the length has never been set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the sequence </dd></dl>

</div>
</div>
<a class="anchor" id="gaa6f7cf4be9012fee3ca476c69f821bc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> FooSeq_set_length </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>new_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the length of this sequence. </p>
<p>This function does not allocate/deallocate memory. </p>
<p>The new length must not exceed the maximum of this sequence as returned by the <a class="el" href="group__DDSSequenceModule.html#gab3765cd5c745da088f3772a1a8578cef" title="Get the current maximum number of elements that can be stored in this sequence.">FooSeq_get_maximum</a> operation. (Note that, if necessary, the maximum of this sequence can be increased manually by using the <a class="el" href="group__DDSSequenceModule.html#gadf5b537079d3997b4acddc9a4af11c63" title="Resize this sequence to a new desired maximum.">FooSeq_set_maximum</a> operation.) </p>
<p>The elements of the sequence are not modified by this operation. If the new length is larger than the original length, the new elements will be uninitialized; if the length is decreased, the old elements that are beyond the new length will physically remain in the sequence but will not be accessible. </p>
<dl class="section post"><dt>Postcondition</dt><dd>length = new_length. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">new_length</td><td>the new desired length. This value must be non-negative and cannot exceed maximum of the sequence. In other words 0 &lt;= new_length &lt;= maximum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> on sucess or <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga85c3c42ee1154be119266c8e6fff3659"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> FooSeq_ensure_length </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sequence to the desired length, and resize the sequence if necessary. </p>
<p>If the current maximum is greater than the desired length, then sequence is not resized. </p>
<p>Otherwise if this sequence owns its buffer, the sequence is resized to the new maximum by freeing and re-allocating the buffer. However, if the sequence does not own its buffer, this operation will fail. </p>
<p>This function allows user to avoid unnecessary buffer re-allocation. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>length</code> &lt;= <code>max</code> </dd>
<dd>
owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> if sequence needs to be resized </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>length == <code>length</code> </dd>
<dd>
maximum == <code>max</code> if resized </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">length</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The new length that should be set. Must be &gt;= 0. </td></tr>
    <tr><td class="paramname">max</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> If sequence need to be resized, this is the maximum that should be set. <code>max</code> &gt;= <code>length</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> on success, <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> if the preconditions are not met. In that case the sequence is not modified. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1eb9a7dd63886579379aa2ac9d786c05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFoo.html">Foo</a> FooSeq_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <code>i-th</code> element for a <code>const</code> sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">i</td><td>index of element to access, must be &gt;= 0 and less than <a class="el" href="group__DDSSequenceModule.html#gaf7a45e00319eeb1ddf5c84ac68657adb" title="Get the logical length of this sequence.">FooSeq_get_length</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code>i-th</code> element </dd></dl>

</div>
</div>
<a class="anchor" id="gae45e554a45615fedbb75398a3e3f9fea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFoo.html">Foo</a>* FooSeq_get_reference </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pointer to the <code>i-th</code> element of this sequence. </p>
<p>This operation can used to modify the elements of the sequence in place. </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structDDS__LongSeq.html" title="Instantiates FooSeq &lt; DDS_Long &gt;">DDS_LongSeq</a> my_seq = <a class="code" href="group__DDSSequenceModule.html#ga521eb819a3b85277debce55d61b08f82" title="An initializer for new sequence instances.">DDS_SEQUENCE_INITIALIZER</a>; </div>
<div class="line"> <a class="code" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6" title="Defines a long integer data type, equivalent to IDL/CDR long.">DDS_Long</a>* first_element = NULL; </div>
<div class="line"> DDS_LongSeq_ensure_length(1, 1); </div>
<div class="line"> first_element = DDS_LongSeq_get_reference(&amp;my_seq, 0); </div>
<div class="line"> *first_element = 5; </div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">i</td><td>index of element to access, must be &gt;= 0 and less than <a class="el" href="group__DDSSequenceModule.html#gaf7a45e00319eeb1ddf5c84ac68657adb" title="Get the logical length of this sequence.">FooSeq_get_length</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <code>i-th</code> element </dd></dl>

</div>
</div>
<a class="anchor" id="ga145a30d7e8f1a6d5c0c3c80e4b6b4e1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> FooSeq_copy_no_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>src_seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy elements from another sequence, only if the destination sequence has enough capacity. </p>
<p>Fill the elements in this sequence by copying the corresponding elements in <code>src_seq</code>. The original contents in this sequence are replaced via the element assignment operation (Foo_copy() function). By default, elements are discarded; 'delete' is not invoked on the discarded elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>this::maximum &gt;= src_seq::length </dd>
<dd>
this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>this::length == src_seq::length </dd>
<dd>
this[i] == src_seq[i] for 0 &lt;= i &lt; target_seq::length </dd>
<dd>
this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">src_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the sequence from which to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> if the sequence was successfully copied; <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the pre-conditions are not met, the operator will print a message to stdout and leave this sequence unchanged. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSSequenceModule.html#gab1eeab81b351a4fbb79c11a85ceb485b" title="Copy elements from another sequence, resizing the sequence if necessary.">FooSeq_copy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab1eeab81b351a4fbb79c11a85ceb485b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFooSeq.html">FooSeq</a>* FooSeq_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>src_seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy elements from another sequence, resizing the sequence if necessary. </p>
<p>This function invokes <a class="el" href="group__DDSSequenceModule.html#ga145a30d7e8f1a6d5c0c3c80e4b6b4e1e" title="Copy elements from another sequence, only if the destination sequence has enough capacity.">FooSeq_copy_no_alloc</a> after ensuring that the sequence has enough capacity to hold the elements to be copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">src_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the sequence from which to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>self</code>, this sequence </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSSequenceModule.html#ga145a30d7e8f1a6d5c0c3c80e4b6b4e1e" title="Copy elements from another sequence, only if the destination sequence has enough capacity.">FooSeq_copy_no_alloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga11413fcc7cc13ccfeb7d5048648ce1e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> FooSeq_from_array </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structFoo.html">Foo</a>&#160;</td>
          <td class="paramname"><em>array</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy elements from an array of elements, resizing the sequence if necessary. The original contents of the sequence (if any) are replaced. </p>
<p>Fill the elements in this sequence by copying the corresponding elements in <code>array</code>. The original contents in this sequence are replaced via the element assignment operation (Foo_copy() function). By default, elements are discarded; 'delete' is not invoked on the discarded elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>this::length == <code>length</code> </dd>
<dd>
this[i] == array[i] for 0 &lt;= i &lt; <code>length</code> </dd>
<dd>
this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">array</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The array of elements to be copy elements from </td></tr>
    <tr><td class="paramname">length</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The length of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> if the array was successfully copied; <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the pre-conditions are not met, the function will print a message to stdout and leave this sequence unchanged. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2efcc1d05bcbf4ff3054b0f0395d0922"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> FooSeq_to_array </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFoo.html">Foo</a>&#160;</td>
          <td class="paramname"><em>array</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy elements to an array of elements. The original contents of the array (if any) are replaced. </p>
<p>Copy the elements of this sequence to the corresponding elements in the array. The original contents of the array are replaced via the element assignment operation (Foo_copy() function). By default, elements are discarded; 'delete' is not invoked on the discarded elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">array</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The array of elements to be filled with elements from this sequence </td></tr>
    <tr><td class="paramname">length</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The number of elements to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> if the elements of the sequence were successfully copied; <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga10d6e06dcf1653244945b0a6e73c7f53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> FooSeq_loan_contiguous </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFoo.html">Foo</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>new_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>new_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loan a contiguous buffer to this sequence. </p>
<p>This operation changes the <code>owned</code> flag of the sequence to <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> and also sets the underlying buffer used by the sequence. See the <a href="../../../manuals/connext_dds/RTI_ConnextDDS_CoreLibraries_UsersManual.pdf" target="_blank">User's Manual</a> for more information about sequences and memory ownership. </p>
<p>Use this function if you want to manage the memory used by the sequence yourself. You must provide an array of elements and integers indicating how many elements are allocated in that array (i.e. the maximum) and how many elements are valid (i.e. the length). The sequence will subsequently use the memory you provide and will not permit it to be freed by a call to <a class="el" href="group__DDSSequenceModule.html#gadf5b537079d3997b4acddc9a4af11c63" title="Resize this sequence to a new desired maximum.">FooSeq_set_maximum</a>. </p>
<p>Once you have loaned a buffer to a sequence, make sure that you don't free it before calling <a class="el" href="group__DDSSequenceModule.html#gaba7a2c4cf49f72627f9b445b697b2364" title="Return the loaned buffer in the sequence and set the maximum to 0.">FooSeq_unloan</a>: the next time you access the sequence, you will be accessing freed memory! </p>
<p>You can use this function to wrap stack memory with a sequence interface, thereby avoiding dynamic memory allocation. Create a <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> and an array of type <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> and then loan the array to the sequence: </p>
<div class="fragment"><div class="line">struct ::Foo fooArray[10];</div>
<div class="line"> struct ::FooSeq fooSeq = <a class="code" href="group__DDSSequenceModule.html#ga521eb819a3b85277debce55d61b08f82" title="An initializer for new sequence instances.">::DDS_SEQUENCE_INITIALIZER</a>; </div>
<div class="line"> <a class="code" href="group__DDSSequenceModule.html#ga10d6e06dcf1653244945b0a6e73c7f53" title="Loan a contiguous buffer to this sequence.">::FooSeq_loan_contiguous</a>(&amp;fooSeq, fooArray, 0, 10); </div>
</div><!-- fragment --> <p>By default, a sequence you create owns its memory unless you explicitly loan memory of your own to it. In a very few cases, RTI Connext will return a sequence to you that has a loan; those cases are documented as such. For example, if you call <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> or <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> and pass in sequences with no loan and no memory allocated, RTI Connext will loan memory to your sequences which must be unloaned with <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>. See the documentation of those functions for more information. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__DDSSequenceModule.html#gab3765cd5c745da088f3772a1a8578cef" title="Get the current maximum number of elements that can be stored in this sequence.">FooSeq_get_maximum</a> == 0; i.e. the sequence has no memory allocated to it. </dd>
<dd>
<a class="el" href="group__DDSSequenceModule.html#gaca64a79c4b5c96bb230cf3d5075f35aa" title="Return the value of the owned flag.">FooSeq_has_ownership</a> == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a>; i.e. the sequence does not already have an outstanding loan </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The sequence will store its elements in the buffer provided. </dd>
<dd>
<a class="el" href="group__DDSSequenceModule.html#gaca64a79c4b5c96bb230cf3d5075f35aa" title="Return the value of the owned flag.">FooSeq_has_ownership</a> == <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> </dd>
<dd>
<a class="el" href="group__DDSSequenceModule.html#gaf7a45e00319eeb1ddf5c84ac68657adb" title="Get the logical length of this sequence.">FooSeq_get_length</a> == new_length </dd>
<dd>
<a class="el" href="group__DDSSequenceModule.html#gab3765cd5c745da088f3772a1a8578cef" title="Get the current maximum number of elements that can be stored in this sequence.">FooSeq_get_maximum</a> == new_max </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">buffer</td><td>The new buffer that the sequence will use. Must point to enough memory to hold new_max elements of type <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a>. It may be NULL if new_max == 0. </td></tr>
    <tr><td class="paramname">new_length</td><td>The desired new length for the sequence. It must be the case that that 0 &lt;= new_length &lt;= new_max. </td></tr>
    <tr><td class="paramname">new_max</td><td>The allocated number of elements that could fit in the loaned buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> if <code>buffer</code> is successfully loaned to this sequence or <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> otherwise. Failure only occurs due to failing to meet the pre-conditions. Upon failure the sequence remains unmodified. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSSequenceModule.html#gaba7a2c4cf49f72627f9b445b697b2364" title="Return the loaned buffer in the sequence and set the maximum to 0.">FooSeq_unloan</a>, <a class="el" href="group__DDSSequenceModule.html#ga71018e377836517dedb9b243bf10df05" title="Loan a discontiguous buffer to this sequence.">FooSeq_loan_discontiguous</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga71018e377836517dedb9b243bf10df05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> FooSeq_loan_discontiguous </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFoo.html">Foo</a> **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>new_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>new_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loan a discontiguous buffer to this sequence. </p>
<p>This function is exactly like <a class="el" href="group__DDSSequenceModule.html#ga10d6e06dcf1653244945b0a6e73c7f53" title="Loan a contiguous buffer to this sequence.">FooSeq_loan_contiguous</a> except that the buffer loaned is an array of <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> pointers, not an array of <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">buffer</td><td>The new buffer that the sequence will use. Must point to enough memory to hold new_max elements of type Foo*. It may be NULL if new_max == 0. </td></tr>
    <tr><td class="paramname">new_length</td><td>The desired new length for the sequence. It must be the case that that 0 &lt;= new_length &lt;= new_max. </td></tr>
    <tr><td class="paramname">new_max</td><td>The allocated number of elements that could fit in the loaned buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSSequenceModule.html#gaba7a2c4cf49f72627f9b445b697b2364" title="Return the loaned buffer in the sequence and set the maximum to 0.">FooSeq_unloan</a>, <a class="el" href="group__DDSSequenceModule.html#ga10d6e06dcf1653244945b0a6e73c7f53" title="Loan a contiguous buffer to this sequence.">FooSeq_loan_contiguous</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaba7a2c4cf49f72627f9b445b697b2364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> FooSeq_unloan </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the loaned buffer in the sequence and set the maximum to 0. </p>
<p>This function affects only the state of this sequence; it does not change the contents of the buffer in any way. </p>
<p>Only the user who originally loaned a buffer should return that loan, as the user may have dependencies on that memory known only to them. Unloaning someone else's buffer may cause unspecified problems. For example, suppose a sequence is loaning memory from a custom memory pool. A user of the sequence likely has no way to release the memory back into the pool, so unloaning the sequence buffer would result in a resource leak. If the user were to then re-loan a different buffer, the original creator of the sequence would have no way to discover, when freeing the sequence, that the loan no longer referred to its own memory and would thus not free the user's memory properly, exacerbating the situation and leading to undefined behavior. </p>
<dl class="section pre"><dt>Precondition</dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </dd>
<dd>
maximum == 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> if the preconditions were met. Otherwise <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a>. The function only fails if the pre-conditions are not met, in which case it leaves the sequence unmodified. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSSequenceModule.html#ga10d6e06dcf1653244945b0a6e73c7f53" title="Loan a contiguous buffer to this sequence.">FooSeq_loan_contiguous</a>, <a class="el" href="group__DDSSequenceModule.html#ga71018e377836517dedb9b243bf10df05" title="Loan a discontiguous buffer to this sequence.">FooSeq_loan_discontiguous</a>, <a class="el" href="group__DDSSequenceModule.html#gadf5b537079d3997b4acddc9a4af11c63" title="Resize this sequence to a new desired maximum.">FooSeq_set_maximum</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5535ba97da0e77b45489a772759f2e83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFoo.html">Foo</a>* FooSeq_get_contiguous_buffer </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the contiguous buffer of the sequence. </p>
<p>Get the underlying buffer where contiguous elements of the sequence are stored. The size of the buffer matches the maximum of the sequence, but only the elements up to the <a class="el" href="group__DDSSequenceModule.html#gaf7a45e00319eeb1ddf5c84ac68657adb" title="Get the logical length of this sequence.">FooSeq_get_length</a> of the sequence are valid. </p>
<p>This function provides almost no encapsulation of the sequence's underlying implementation. Certain operations, such as <a class="el" href="group__DDSSequenceModule.html#gadf5b537079d3997b4acddc9a4af11c63" title="Resize this sequence to a new desired maximum.">FooSeq_set_maximum</a>, may render the buffer invalid. In light of these caveats, this operation should be used with care. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer that stores contiguous elements in sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="gabf21100a0446978244dd3f80fa5bf922"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFoo.html">Foo</a>** FooSeq_get_discontiguous_buffer </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the discontiguous buffer of the sequence. </p>
<p>This operation returns the underlying buffer where discontiguous elements of the sequence are stored. The size of the buffer matches the maximum of this sequence, but only the elements up to the <a class="el" href="group__DDSSequenceModule.html#gaf7a45e00319eeb1ddf5c84ac68657adb" title="Get the logical length of this sequence.">FooSeq_get_length</a> of the sequence are valid. </p>
<p>The same caveats apply to this function as to ::FooSeq_get_contiguous_bufferI. </p>
<p>The sequence will dereference pointers in the discontiguous buffer to provide access to its elements by value in C and by reference in C++. If you access the discontiguous buffer directly by means of this function, do not store any NULL values into it, as acessing those values will result in a segmentation fault. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>buffer that stores discontiguous elements in sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="gaca64a79c4b5c96bb230cf3d5075f35aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> FooSeq_has_ownership </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of the owned flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> if sequence owns the underlying buffer, or <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> if it has an outstanding loan. </dd></dl>

</div>
</div>
<a class="anchor" id="gae1a415ca306572994f50eb07476b5299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> FooSeq_finalize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate this sequence's buffer. </p>
<p>Note that this function deletes this sequence's <em>buffer</em>, not this sequence itself. To avoid memory leaks, it should be called even on sequences declared on the stack. And after it has been called on a sequence located in dynamic memory, it is still necessary to call free(). </p>
<dl class="section pre"><dt>Precondition</dt><dd>(owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a>). If this precondition is not met, no memory will be freed and an error will be logged. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>maximum == 0 and the underlying buffer is freed. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSSequenceModule.html#gab3765cd5c745da088f3772a1a8578cef" title="Get the current maximum number of elements that can be stored in this sequence.">FooSeq_get_maximum</a>, <a class="el" href="group__DDSSequenceModule.html#gaba7a2c4cf49f72627f9b445b697b2364" title="Return the loaned buffer in the sequence and set the maximum to 0.">FooSeq_unloan</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Connext C API Version 5.2.3</A>
Copyright &copy; Wed Apr 27 2016 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
