<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>RTI Connext C API: DDS_DataReaderResourceLimitsQosPolicy Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RTI Connext C API
   &#160;<span id="projectnumber">Version 5.2.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2-20120808 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structDDS__DataReaderResourceLimitsQosPolicy.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">DDS_DataReaderResourceLimitsQosPolicy Struct Reference<div class="ingroups"><a class="el" href="group__DDSDataReaderResourceLimitsQosModule.html">DATA_READER_RESOURCE_LIMITS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Various settings that configure how a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> allocates and uses physical memory for internal resources.  
 <a href="structDDS__DataReaderResourceLimitsQosPolicy.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ae89be540f623745dab6b0d6379037da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#ae89be540f623745dab6b0d6379037da1">max_remote_writers</a></td></tr>
<tr class="memdesc:ae89be540f623745dab6b0d6379037da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read, including all instances.  <a href="#ae89be540f623745dab6b0d6379037da1"></a><br/></td></tr>
<tr class="separator:ae89be540f623745dab6b0d6379037da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ab710ce28f1718df9a42cd10a46b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a79ab710ce28f1718df9a42cd10a46b5d">max_remote_writers_per_instance</a></td></tr>
<tr class="memdesc:a79ab710ce28f1718df9a42cd10a46b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read a single instance.  <a href="#a79ab710ce28f1718df9a42cd10a46b5d"></a><br/></td></tr>
<tr class="separator:a79ab710ce28f1718df9a42cd10a46b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7210d8354ee1db9a55fc18ed56105d6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a7210d8354ee1db9a55fc18ed56105d6a">max_samples_per_remote_writer</a></td></tr>
<tr class="memdesc:a7210d8354ee1db9a55fc18ed56105d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of out-of-order samples from a given remote <a class="el" href="group__DDSWriterModule.html#gafb74fa54675abe1bfb2090265bf4d116" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS_To...">DDS_DataWriter</a> that a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may store when maintaining a reliable connection to the <a class="el" href="group__DDSWriterModule.html#gafb74fa54675abe1bfb2090265bf4d116" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS_To...">DDS_DataWriter</a>.  <a href="#a7210d8354ee1db9a55fc18ed56105d6a"></a><br/></td></tr>
<tr class="separator:a7210d8354ee1db9a55fc18ed56105d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f871521d0791014ee54ec70ee57cbc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a6f871521d0791014ee54ec70ee57cbc0">max_infos</a></td></tr>
<tr class="memdesc:a6f871521d0791014ee54ec70ee57cbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of info units that a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> can use to store <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a>.  <a href="#a6f871521d0791014ee54ec70ee57cbc0"></a><br/></td></tr>
<tr class="separator:a6f871521d0791014ee54ec70ee57cbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f44e7655fa6535a464b09f7e447743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a82f44e7655fa6535a464b09f7e447743">initial_remote_writers</a></td></tr>
<tr class="memdesc:a82f44e7655fa6535a464b09f7e447743"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read, including all instances.  <a href="#a82f44e7655fa6535a464b09f7e447743"></a><br/></td></tr>
<tr class="separator:a82f44e7655fa6535a464b09f7e447743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e822ed635a2ba4dc26668df7306a2ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a9e822ed635a2ba4dc26668df7306a2ff">initial_remote_writers_per_instance</a></td></tr>
<tr class="memdesc:a9e822ed635a2ba4dc26668df7306a2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read a single instance.  <a href="#a9e822ed635a2ba4dc26668df7306a2ff"></a><br/></td></tr>
<tr class="separator:a9e822ed635a2ba4dc26668df7306a2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d00e4c0128edfbd6d501e2094162c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a7d00e4c0128edfbd6d501e2094162c48">initial_infos</a></td></tr>
<tr class="memdesc:a7d00e4c0128edfbd6d501e2094162c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of info units that a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> can have, which are used to store <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a>.  <a href="#a7d00e4c0128edfbd6d501e2094162c48"></a><br/></td></tr>
<tr class="separator:a7d00e4c0128edfbd6d501e2094162c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3217a96e2ec0d7a3803adfe7c3b5cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a0e3217a96e2ec0d7a3803adfe7c3b5cf">initial_outstanding_reads</a></td></tr>
<tr class="memdesc:a0e3217a96e2ec0d7a3803adfe7c3b5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of outstanding calls to read/take (or one of their variants) on the same <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> for which memory has not been returned by calling <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>.  <a href="#a0e3217a96e2ec0d7a3803adfe7c3b5cf"></a><br/></td></tr>
<tr class="separator:a0e3217a96e2ec0d7a3803adfe7c3b5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82873fd35e4159bce6c23cc0de5fcca9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a82873fd35e4159bce6c23cc0de5fcca9">max_outstanding_reads</a></td></tr>
<tr class="memdesc:a82873fd35e4159bce6c23cc0de5fcca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of outstanding read/take calls (or one of their variants) on the same <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> for which memory has not been returned by calling <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>.  <a href="#a82873fd35e4159bce6c23cc0de5fcca9"></a><br/></td></tr>
<tr class="separator:a82873fd35e4159bce6c23cc0de5fcca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3672d889d158f8da9c2465e5ec3046c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a3672d889d158f8da9c2465e5ec3046c5">max_samples_per_read</a></td></tr>
<tr class="memdesc:a3672d889d158f8da9c2465e5ec3046c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of data samples that the application can receive from the middleware in a single call to <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> or <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a>. If more data exists in the middleware, the application will need to issue multiple read/take calls.  <a href="#a3672d889d158f8da9c2465e5ec3046c5"></a><br/></td></tr>
<tr class="separator:a3672d889d158f8da9c2465e5ec3046c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b5f1ff7b6954e38b8693eefc7e781f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#ae6b5f1ff7b6954e38b8693eefc7e781f">disable_fragmentation_support</a></td></tr>
<tr class="memdesc:ae6b5f1ff7b6954e38b8693eefc7e781f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> can receive fragmented samples.  <a href="#ae6b5f1ff7b6954e38b8693eefc7e781f"></a><br/></td></tr>
<tr class="separator:ae6b5f1ff7b6954e38b8693eefc7e781f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab829f0f900a4eb50dd796040f70afb26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#ab829f0f900a4eb50dd796040f70afb26">max_fragmented_samples</a></td></tr>
<tr class="memdesc:ab829f0f900a4eb50dd796040f70afb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of samples for which the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may store fragments at a given point in time.  <a href="#ab829f0f900a4eb50dd796040f70afb26"></a><br/></td></tr>
<tr class="separator:ab829f0f900a4eb50dd796040f70afb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af997416e8a8dab3f2e309a68ed48bb04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#af997416e8a8dab3f2e309a68ed48bb04">initial_fragmented_samples</a></td></tr>
<tr class="memdesc:af997416e8a8dab3f2e309a68ed48bb04"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of samples for which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may store fragments.  <a href="#af997416e8a8dab3f2e309a68ed48bb04"></a><br/></td></tr>
<tr class="separator:af997416e8a8dab3f2e309a68ed48bb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4afc77231d262ce0e1a320b5e6f964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a1f4afc77231d262ce0e1a320b5e6f964">max_fragmented_samples_per_remote_writer</a></td></tr>
<tr class="memdesc:a1f4afc77231d262ce0e1a320b5e6f964"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of samples per remote writer for which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may store fragments.  <a href="#a1f4afc77231d262ce0e1a320b5e6f964"></a><br/></td></tr>
<tr class="separator:a1f4afc77231d262ce0e1a320b5e6f964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67642418056ab77f7102eb1e735a5bef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a67642418056ab77f7102eb1e735a5bef">max_fragments_per_sample</a></td></tr>
<tr class="memdesc:a67642418056ab77f7102eb1e735a5bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of fragments for a single sample.  <a href="#a67642418056ab77f7102eb1e735a5bef"></a><br/></td></tr>
<tr class="separator:a67642418056ab77f7102eb1e735a5bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd03f44d9c89ebe7dd0cd8026c671129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#abd03f44d9c89ebe7dd0cd8026c671129">dynamically_allocate_fragmented_samples</a></td></tr>
<tr class="memdesc:abd03f44d9c89ebe7dd0cd8026c671129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> pre-allocates storage for storing fragmented samples.  <a href="#abd03f44d9c89ebe7dd0cd8026c671129"></a><br/></td></tr>
<tr class="separator:abd03f44d9c89ebe7dd0cd8026c671129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e66c63b7fdafccd4090792c47ec79c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a90e66c63b7fdafccd4090792c47ec79c">max_total_instances</a></td></tr>
<tr class="memdesc:a90e66c63b7fdafccd4090792c47ec79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of instances for which a DataReader will keep state.  <a href="#a90e66c63b7fdafccd4090792c47ec79c"></a><br/></td></tr>
<tr class="separator:a90e66c63b7fdafccd4090792c47ec79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1334473402f0fcd847ed0c1949a511b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a1334473402f0fcd847ed0c1949a511b4">max_remote_virtual_writers</a></td></tr>
<tr class="memdesc:a1334473402f0fcd847ed0c1949a511b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of remote virtual writers from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read, including all instances.  <a href="#a1334473402f0fcd847ed0c1949a511b4"></a><br/></td></tr>
<tr class="separator:a1334473402f0fcd847ed0c1949a511b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfb9b5fb92024e4e56ab5fe56e87140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a0dfb9b5fb92024e4e56ab5fe56e87140">initial_remote_virtual_writers</a></td></tr>
<tr class="memdesc:a0dfb9b5fb92024e4e56ab5fe56e87140"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of remote virtual writers from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read, including all instances.  <a href="#a0dfb9b5fb92024e4e56ab5fe56e87140"></a><br/></td></tr>
<tr class="separator:a0dfb9b5fb92024e4e56ab5fe56e87140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162eee845adbe96f8f40a9966a066a51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a162eee845adbe96f8f40a9966a066a51">max_remote_virtual_writers_per_instance</a></td></tr>
<tr class="memdesc:a162eee845adbe96f8f40a9966a066a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of virtual remote writers that can be associated with an instance.  <a href="#a162eee845adbe96f8f40a9966a066a51"></a><br/></td></tr>
<tr class="separator:a162eee845adbe96f8f40a9966a066a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354bb399a209e710ecc7093e77de2c95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a354bb399a209e710ecc7093e77de2c95">initial_remote_virtual_writers_per_instance</a></td></tr>
<tr class="memdesc:a354bb399a209e710ecc7093e77de2c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of virtual remote writers per instance.  <a href="#a354bb399a209e710ecc7093e77de2c95"></a><br/></td></tr>
<tr class="separator:a354bb399a209e710ecc7093e77de2c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004638f76e0cbbdd8018cedca107a34c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a004638f76e0cbbdd8018cedca107a34c">max_remote_writers_per_sample</a></td></tr>
<tr class="memdesc:a004638f76e0cbbdd8018cedca107a34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of remote writers allowed to write the same sample.  <a href="#a004638f76e0cbbdd8018cedca107a34c"></a><br/></td></tr>
<tr class="separator:a004638f76e0cbbdd8018cedca107a34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0bbad5b44d11f09cd7c4d2a738765b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#abd0bbad5b44d11f09cd7c4d2a738765b">max_query_condition_filters</a></td></tr>
<tr class="memdesc:abd0bbad5b44d11f09cd7c4d2a738765b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of query condition filters a reader is allowed.  <a href="#abd0bbad5b44d11f09cd7c4d2a738765b"></a><br/></td></tr>
<tr class="separator:abd0bbad5b44d11f09cd7c4d2a738765b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e6ff9fcd67631949d80ff737a7d514"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a22e6ff9fcd67631949d80ff737a7d514">max_app_ack_response_length</a></td></tr>
<tr class="memdesc:a22e6ff9fcd67631949d80ff737a7d514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of application-level acknowledgment response data.  <a href="#a22e6ff9fcd67631949d80ff737a7d514"></a><br/></td></tr>
<tr class="separator:a22e6ff9fcd67631949d80ff737a7d514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3642407abc792f2a8929570b870a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#abf3642407abc792f2a8929570b870a65">keep_minimum_state_for_instances</a></td></tr>
<tr class="memdesc:abf3642407abc792f2a8929570b870a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not keep a minimum instance state for up to <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a90e66c63b7fdafccd4090792c47ec79c" title="Maximum number of instances for which a DataReader will keep state.">DDS_DataReaderResourceLimitsQosPolicy::max_total_instances</a>.  <a href="#abf3642407abc792f2a8929570b870a65"></a><br/></td></tr>
<tr class="separator:abf3642407abc792f2a8929570b870a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Various settings that configure how a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> allocates and uses physical memory for internal resources. </p>
<p>DataReaders must allocate internal structures to handle the maximum number of DataWriters that may connect to it, whether or not a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> handles data fragmentation and how many data fragments that it may handle (for data samples larger than the MTU of the underlying network transport), how many simultaneous outstanding loans of internal memory holding data samples can be provided to user code, as well as others. </p>
<p>Most of these internal structures start at an initial size and, by default, will grow as needed by dynamically allocating additional memory. You may set fixed, maximum sizes for these internal structures if you want to bound the amount of memory that can be used by a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. By setting the initial size to the maximum size, you will prevent RTI Connext from dynamically allocating any memory after the creation of the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>This QoS policy is an extension to the DDS standard. </p>
<dl class="section user"><dt>Entity:</dt><dd><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> </dd></dl>
<dl class="section user"><dt>Properties:</dt><dd><a class="el" href="group__DDSQosTypesModule.html#a_prop_rxo">RxO</a> = N/A <br/>
 <a class="el" href="group__DDSQosTypesModule.html#a_prop_changeable">Changeable</a> = <a class="el" href="group__DDSQosTypesModule.html#a_prop_changeable_no">NO</a> <br/>
 </dd></dl>
</div><h2>Field Documentation</h2>
<a class="anchor" id="ae89be540f623745dab6b0d6379037da1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::max_remote_writers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read, including all instances. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> <br/>
 <b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a>, &gt;= initial_remote_writers, &gt;= max_remote_writers_per_instance </p>
<p>For unkeyed types, this value has to be equal to max_remote_writers_per_instance if max_remote_writers_per_instance is not equal to <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a>. </p>
<p>Note: For efficiency, set <code>max_remote_writers</code> &gt;= <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a79ab710ce28f1718df9a42cd10a46b5d" title="The maximum number of remote writers from which a DDS_DataReader may read a single instance...">DDS_DataReaderResourceLimitsQosPolicy::max_remote_writers_per_instance</a>. </p>

</div>
</div>
<a class="anchor" id="a79ab710ce28f1718df9a42cd10a46b5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::max_remote_writers_per_instance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read a single instance. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> <br/>
 </p>
<p><b>[range]</b> [1, 1024] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a>, &lt;= max_remote_writers or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a>, &gt;= initial_remote_writers_per_instance </p>
<p>For unkeyed types, this value has to be equal to max_remote_writers if it is not <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a>. </p>
<p>Note: For efficiency, set <code>max_remote_writers_per_instance</code> &lt;= <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#ae89be540f623745dab6b0d6379037da1" title="The maximum number of remote writers from which a DDS_DataReader may read, including all instances...">DDS_DataReaderResourceLimitsQosPolicy::max_remote_writers</a> </p>

</div>
</div>
<a class="anchor" id="a7210d8354ee1db9a55fc18ed56105d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::max_samples_per_remote_writer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of out-of-order samples from a given remote <a class="el" href="group__DDSWriterModule.html#gafb74fa54675abe1bfb2090265bf4d116" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS_To...">DDS_DataWriter</a> that a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may store when maintaining a reliable connection to the <a class="el" href="group__DDSWriterModule.html#gafb74fa54675abe1bfb2090265bf4d116" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS_To...">DDS_DataWriter</a>. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </p>
<p><b>[range]</b> [1, 100 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a>, &lt;= <a class="el" href="structDDS__ResourceLimitsQosPolicy.html#a90db906a3958146c5e22557db648e7ff" title="Represents the maximum samples the middleware can store for any one DDS_DataWriter (or DDS_DataReader...">DDS_ResourceLimitsQosPolicy::max_samples</a> </p>

</div>
</div>
<a class="anchor" id="a6f871521d0791014ee54ec70ee57cbc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::max_infos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of info units that a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> can use to store <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a>. </p>
<p>When read/take is called on a DataReader, the DataReader passes a sequence of data samples and an associated sample info sequence. The sample info sequence contains additional information for each data sample. </p>
<p>max_infos determines the resources allocated for storing sample info. This memory is loaned to the application when passing a sample info sequence. </p>
<p>Note that sample info is a snapshot, generated when read/take is called. </p>
<p>max_infos should not be less than max_samples. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </p>
<p><b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a>, &gt;= initial_infos </p>

</div>
</div>
<a class="anchor" id="a82f44e7655fa6535a464b09f7e447743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::initial_remote_writers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read, including all instances. </p>
<p><b>[default]</b> 2<br/>
 </p>
<p><b>[range]</b> [1, 1 million], &lt;= max_remote_writers<br/>
 </p>
<p>For unkeyed types this value has to be equal to initial_remote_writers_per_instance.<br/>
 </p>
<p>Note: For efficiency, set initial_remote_writers &gt;= <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a9e822ed635a2ba4dc26668df7306a2ff" title="The initial number of remote writers from which a DDS_DataReader may read a single instance...">DDS_DataReaderResourceLimitsQosPolicy::initial_remote_writers_per_instance</a>. </p>

</div>
</div>
<a class="anchor" id="a9e822ed635a2ba4dc26668df7306a2ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::initial_remote_writers_per_instance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read a single instance. </p>
<p><b>[default]</b> 2<br/>
 </p>
<p><b>[range]</b> [1,1024], &lt;= max_remote_writers_per_instance<br/>
 </p>
<p>For unkeyed types this value has to be equal to initial_remote_writers.<br/>
 </p>
<p>Note: For efficiency, set initial_remote_writers_per_instance &lt;= <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a82f44e7655fa6535a464b09f7e447743" title="The initial number of remote writers from which a DDS_DataReader may read, including all instances...">DDS_DataReaderResourceLimitsQosPolicy::initial_remote_writers</a>. </p>

</div>
</div>
<a class="anchor" id="a7d00e4c0128edfbd6d501e2094162c48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::initial_infos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of info units that a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> can have, which are used to store <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a>. </p>
<p><b>[default]</b> 32 </p>
<p><b>[range]</b> [1,1 million], &lt;= max_infos </p>

</div>
</div>
<a class="anchor" id="a0e3217a96e2ec0d7a3803adfe7c3b5cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::initial_outstanding_reads</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of outstanding calls to read/take (or one of their variants) on the same <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> for which memory has not been returned by calling <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>. </p>
<p><b>[default]</b> 2 </p>
<p><b>[range]</b> [1, 65536], &lt;= max_outstanding_reads </p>

</div>
</div>
<a class="anchor" id="a82873fd35e4159bce6c23cc0de5fcca9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::max_outstanding_reads</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of outstanding read/take calls (or one of their variants) on the same <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> for which memory has not been returned by calling <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </p>
<p><b>[range]</b> [1, 65536] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a>, &gt;= initial_outstanding_reads </p>

</div>
</div>
<a class="anchor" id="a3672d889d158f8da9c2465e5ec3046c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::max_samples_per_read</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of data samples that the application can receive from the middleware in a single call to <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> or <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a>. If more data exists in the middleware, the application will need to issue multiple read/take calls. </p>
<p>When reading data using listeners, the expected number of samples available for delivery in a single <code>take</code> call is typically small: usually just one, in the case of unbatched data, or the number of samples in a single batch, in the case of batched data. (See <a class="el" href="structDDS__BatchQosPolicy.html" title="Used to configure batching of multiple samples into a single network packet in order to increase thro...">DDS_BatchQosPolicy</a> for more information about this feature.) When polling for data or using a <a class="el" href="group__DDSConditionsModule.html#gaffdc85b9ca97eb432a2c17c52bc00f82" title="&lt;&lt;interface&gt;&gt; Allows an application to wait until one or more of the attached DDS_Condition objects h...">DDS_WaitSet</a>, however, multiple samples (or batches) could be retrieved at once, depending on the data rate. </p>
<p>A larger value for this parameter makes the API simpler to use at the expense of some additional memory consumption. </p>
<p><b>[default]</b> 1024 </p>
<p><b>[range]</b> [1,65536] </p>

</div>
</div>
<a class="anchor" id="ae6b5f1ff7b6954e38b8693eefc7e781f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> DDS_DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> can receive fragmented samples. </p>
<p>When fragmentation support is not needed, disabling fragmentation support will save some memory resources. </p>
<p><b>[default]</b> <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> </p>

</div>
</div>
<a class="anchor" id="ab829f0f900a4eb50dd796040f70afb26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::max_fragmented_samples</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of samples for which the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may store fragments at a given point in time. </p>
<p>At any given time, a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may store fragments for up to <code>max_fragmented_samples</code> samples while waiting for the remaining fragments. These samples need not have consecutive sequence numbers and may have been sent by different <a class="el" href="group__DDSWriterModule.html#gafb74fa54675abe1bfb2090265bf4d116" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS_To...">DDS_DataWriter</a> instances. </p>
<p>Once all fragments of a sample have been received, the sample is treated as a regular sample and becomes subject to standard QoS settings such as <a class="el" href="structDDS__ResourceLimitsQosPolicy.html#a90db906a3958146c5e22557db648e7ff" title="Represents the maximum samples the middleware can store for any one DDS_DataWriter (or DDS_DataReader...">DDS_ResourceLimitsQosPolicy::max_samples</a>. </p>
<p>The middleware will drop fragments if the <code>max_fragmented_samples</code> limit has been reached. For best-effort communication, the middleware will accept a fragment for a new sample, but drop the oldest fragmented sample from the same remote writer. For reliable communication, the middleware will drop fragments for any new samples until all fragments for at least one older sample from that writer have been received. </p>
<p>Only applies if <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#ae6b5f1ff7b6954e38b8693eefc7e781f" title="Determines whether the DDS_DataReader can receive fragmented samples.">DDS_DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a> is <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a>. </p>
<p><b>[default]</b> 1024 </p>
<p><b>[range]</b> [1, 1 million] </p>

</div>
</div>
<a class="anchor" id="af997416e8a8dab3f2e309a68ed48bb04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::initial_fragmented_samples</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of samples for which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may store fragments. </p>
<p>Only applies if <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#ae6b5f1ff7b6954e38b8693eefc7e781f" title="Determines whether the DDS_DataReader can receive fragmented samples.">DDS_DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a> is <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a>. </p>
<p><b>[default]</b> 4 </p>
<p><b>[range]</b> [1,1024], &lt;= max_fragmented_samples </p>

</div>
</div>
<a class="anchor" id="a1f4afc77231d262ce0e1a320b5e6f964"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::max_fragmented_samples_per_remote_writer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of samples per remote writer for which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may store fragments. </p>
<p>Logical limit so a single remote writer cannot consume all available resources. </p>
<p>Only applies if <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#ae6b5f1ff7b6954e38b8693eefc7e781f" title="Determines whether the DDS_DataReader can receive fragmented samples.">DDS_DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a> is <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a>. </p>
<p><b>[default]</b> 256 </p>
<p><b>[range]</b> [1, 1 million], &lt;= max_fragmented_samples </p>

</div>
</div>
<a class="anchor" id="a67642418056ab77f7102eb1e735a5bef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::max_fragments_per_sample</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of fragments for a single sample. </p>
<p>Only applies if <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#ae6b5f1ff7b6954e38b8693eefc7e781f" title="Determines whether the DDS_DataReader can receive fragmented samples.">DDS_DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a> is <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a>. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </p>
<p><b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </p>

</div>
</div>
<a class="anchor" id="abd03f44d9c89ebe7dd0cd8026c671129"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> DDS_DataReaderResourceLimitsQosPolicy::dynamically_allocate_fragmented_samples</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> pre-allocates storage for storing fragmented samples. </p>
<p>By default, the middleware does not allocate memory upfront, but instead allocates memory from the heap upon receiving the first fragment of a new sample. The amount of memory allocated equals the amount of memory needed to store all fragments in the sample. Once all fragments of a sample have been received, the sample is deserialized and stored in the regular receive queue. At that time, the dynamically allocated memory is freed again. </p>
<p>This QoS setting is useful for large, but variable-sized data types where upfront memory allocation for multiple samples based on the maximum possible sample size may be expensive. The main disadvantage of not pre-allocating memory is that one can no longer guarantee the middleware will have sufficient resources at run-time. </p>
<p>If <code>dynamically_allocate_fragmented_samples</code> is set to <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a>, the middleware will allocate memory upfront for storing fragments for up to <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#af997416e8a8dab3f2e309a68ed48bb04" title="The initial number of samples for which a DDS_DataReader may store fragments.">DDS_DataReaderResourceLimitsQosPolicy::initial_fragmented_samples</a> samples. This memory may grow up to <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#ab829f0f900a4eb50dd796040f70afb26" title="The maximum number of samples for which the DDS_DataReader may store fragments at a given point in ti...">DDS_DataReaderResourceLimitsQosPolicy::max_fragmented_samples</a> if needed. </p>
<p>Only applies if <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#ae6b5f1ff7b6954e38b8693eefc7e781f" title="Determines whether the DDS_DataReader can receive fragmented samples.">DDS_DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a> is <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a>. </p>
<p><b>[default]</b> <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </p>

</div>
</div>
<a class="anchor" id="a90e66c63b7fdafccd4090792c47ec79c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::max_total_instances</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of instances for which a DataReader will keep state. </p>
<p>The maximum number of instances actively managed by a DataReader is determined by <a class="el" href="structDDS__ResourceLimitsQosPolicy.html#ab7339605f314f50c7cb658426ff64cdb" title="Represents the maximum number of instances a DDS_DataWriter (or DDS_DataReader) can manage...">DDS_ResourceLimitsQosPolicy::max_instances</a>. </p>
<p>These instances have associated DataWriters or samples in the DataReader's queue and are visible to the user through operations such as <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a>, <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, and <a class="el" href="group__DDSReaderModule.html#ga434a5530ff95ee21227e5643273a85d4" title="Retrieve the instance key that corresponds to an instance handle.">FooDataReader_get_key_value</a>. </p>
<p>The features Durable Reader State, MultiChannel DataWriters and RTI Persistence Service require RTI Connext to keep some internal state even for instances without DataWriters or samples in the DataReader's queue. The additional state is used to filter duplicate samples that could be coming from different DataWriter channels or from multiple executions of RTI Persistence Service. </p>
<p>The total maximum number of instances that will be managed by the middleware, including instances without associated DataWriters or samples, is determined by max_total_instances. </p>
<p>When a new instance is received, RTI Connext will check the resource limit <a class="el" href="structDDS__ResourceLimitsQosPolicy.html#ab7339605f314f50c7cb658426ff64cdb" title="Represents the maximum number of instances a DDS_DataWriter (or DDS_DataReader) can manage...">DDS_ResourceLimitsQosPolicy::max_instances</a>. If the limit is exceeded, RTI Connext will drop the sample and report it as lost and rejected. If the limit is not exceeded, RTI Connext will check max_total_instances. If max_total_instances is exceeded, RTI Connext will replace an existing instance without DataWriters and samples with the new one. The application could receive duplicate samples for the replaced instance if it becomes alive again. </p>
<p><b>[default]</b> <a class="el" href="group__DDSDataReaderResourceLimitsQosModule.html#gabd19381203208406d882abeeb9e53d3f" title="&lt;&lt;extension&gt;&gt; This value is used to make DDS_DataReaderResourceLimitsQosPolicy::max_total_instances e...">DDS_AUTO_MAX_TOTAL_INSTANCES</a> </p>
<p><b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> or <a class="el" href="group__DDSDataReaderResourceLimitsQosModule.html#gabd19381203208406d882abeeb9e53d3f" title="&lt;&lt;extension&gt;&gt; This value is used to make DDS_DataReaderResourceLimitsQosPolicy::max_total_instances e...">DDS_AUTO_MAX_TOTAL_INSTANCES</a>, &gt;= <a class="el" href="structDDS__ResourceLimitsQosPolicy.html#ab7339605f314f50c7cb658426ff64cdb" title="Represents the maximum number of instances a DDS_DataWriter (or DDS_DataReader) can manage...">DDS_ResourceLimitsQosPolicy::max_instances</a> </p>

</div>
</div>
<a class="anchor" id="a1334473402f0fcd847ed0c1949a511b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::max_remote_virtual_writers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of remote virtual writers from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read, including all instances. </p>
<p>When <a class="el" href="structDDS__PresentationQosPolicy.html#a0d46a4e9fe04a65507153013ab542e64" title="Determines the largest scope spanning the entities for which the order and coherency of changes can b...">DDS_PresentationQosPolicy::access_scope</a> is set to <a class="el" href="group__DDSPresentationQosModule.html#gga123d979f855f637f32eb525b778175b2ae0591a04e045da1d86f25fa8bec39937" title="Scope spans to all instances belonging to DDS_DataWriter (or DDS_DataReader) entities within the same...">DDS_GROUP_PRESENTATION_QOS</a>, this value determines the maximum number of DataWriter groups that can be managed by the <a class="el" href="group__DDSSubscriberModule.html#ga2755712602505786a23baef5a42d6782" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS_Subscriber</a> containing this <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>Since the <a class="el" href="group__DDSSubscriberModule.html#ga2755712602505786a23baef5a42d6782" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS_Subscriber</a> may contain more than one <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>, only the setting of the first applies. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> <br/>
 <b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a>, &gt;= initial_remote_virtual_writers, &gt;= max_remote_virtual_writers_per_instance </p>

</div>
</div>
<a class="anchor" id="a0dfb9b5fb92024e4e56ab5fe56e87140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::initial_remote_virtual_writers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of remote virtual writers from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read, including all instances. </p>
<p><b>[default]</b> 2 <br/>
 <b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a>, &lt;= max_remote_virtual_writers </p>

</div>
</div>
<a class="anchor" id="a162eee845adbe96f8f40a9966a066a51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::max_remote_virtual_writers_per_instance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of virtual remote writers that can be associated with an instance. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> <br/>
 </p>
<p><b>[range]</b> [1, 1024] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a>, &gt;= initial_remote_virtual_writers_per_instance </p>
<p>For unkeyed types, this value is ignored. </p>
<p>The features of Durable Reader State and MultiChannel DataWriters, and RTI Persistence Service require RTI Connext to keep some internal state per virtual writer and instance that is used to filter duplicate samples. These duplicate samples could be coming from different DataWriter channels or from multiple executions of RTI Persistence Service. </p>
<p>Once an association between a remote virtual writer and an instance is established, it is permanent &ndash; it will not disappear even if the physical writer incarnating the virtual writer is destroyed. </p>
<p>If max_remote_virtual_writers_per_instance is exceeded for an instance, RTI Connext will not associate this instance with new virtual writers. Duplicates samples from these virtual writers will not be filtered on the reader. </p>
<p>If you are not using Durable Reader State, MultiChannel DataWriters or RTI Persistence Service in your system, you can set this property to 1 to optimize resources. </p>

</div>
</div>
<a class="anchor" id="a354bb399a209e710ecc7093e77de2c95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::initial_remote_virtual_writers_per_instance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of virtual remote writers per instance. </p>
<p><b>[default]</b> 2<br/>
 </p>
<p><b>[range]</b> [1, 1024], &lt;= max_remote_virtual_writers_per_instance<br/>
 </p>
<p>For unkeyed types, this value is ignored.<br/>
 </p>

</div>
</div>
<a class="anchor" id="a004638f76e0cbbdd8018cedca107a34c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::max_remote_writers_per_sample</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of remote writers allowed to write the same sample. </p>
<p>One scenario in which two DataWriters may write the same sample is Persistence Service. The DataReader may receive the same sample coming from the original DataWriter and from a Persistence Service DataWriter. <b>[default]</b> 3<br/>
 </p>
<p><b>[range]</b> [1, 1024]<br/>
 </p>

</div>
</div>
<a class="anchor" id="abd0bbad5b44d11f09cd7c4d2a738765b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::max_query_condition_filters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of query condition filters a reader is allowed. </p>
<p><b>[default]</b> 4<br/>
 </p>
<p><b>[range]</b> [0, 32]<br/>
 </p>
<p>This value determines the maximum number of unique query condition content filters that a reader may create. </p>
<p>Each query condition content filter is comprised of both its <code>query_expression</code> and <code>query_parameters</code>. Two query conditions that have the same <code>query_expression</code> will require unique query condition filters if their <code>query_paramters</code> differ. Query conditions that differ only in their state masks will share the same query condition filter. </p>

</div>
</div>
<a class="anchor" id="a22e6ff9fcd67631949d80ff737a7d514"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> DDS_DataReaderResourceLimitsQosPolicy::max_app_ack_response_length</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length of application-level acknowledgment response data. </p>
<p>The maximum length of response data in an application-level acknowledgment. </p>
<p>When set to zero, no response data is sent with application-level acknowledgments. </p>
<p><b>[default]</b> 0 </p>
<p><b>[range]</b> [0, 65536] </p>

</div>
</div>
<a class="anchor" id="abf3642407abc792f2a8929570b870a65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> DDS_DataReaderResourceLimitsQosPolicy::keep_minimum_state_for_instances</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not keep a minimum instance state for up to <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a90e66c63b7fdafccd4090792c47ec79c" title="Maximum number of instances for which a DataReader will keep state.">DDS_DataReaderResourceLimitsQosPolicy::max_total_instances</a>. </p>
<p>The features Durable Reader State, multi-channel DataWriters, and Persistence Service require RTI Connext to keep some minimal internal state even for instances without DataWriters or DDS samples in the DataReader's queue, or that have been purged due to a dispose. The additional state is used to filter duplicate DDS samples that could be coming from different DataWriter channels or from multiple executions of Persistence Service. The total maximum number of instances that will be managed by the middleware, including instances without associated DataWriters or DDS samples or that have been purged due to a dispose, is determined by <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a90e66c63b7fdafccd4090792c47ec79c" title="Maximum number of instances for which a DataReader will keep state.">DDS_DataReaderResourceLimitsQosPolicy::max_total_instances</a>. </p>
<p>This additional state will only be kept for up to max_total_instances if this field is set to <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a>, otherwise the additional state will not be kept for any instances. </p>
<p><b>[default]</b> <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Connext C API Version 5.2.3</A>
Copyright &copy; Wed Apr 27 2016 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
