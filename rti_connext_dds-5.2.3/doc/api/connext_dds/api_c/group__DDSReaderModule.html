<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>RTI Connext C API: DataReaders</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RTI Connext C API
   &#160;<span id="projectnumber">Version 5.2.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2-20120808 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__DDSReaderModule.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DataReaders</div>  </div>
<div class="ingroups"><a class="el" href="group__DDSSubscriptionModule.html">Subscription Module</a></div></div><!--header-->
<div class="contents">

<p><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> entity and associated elements  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__DDSReadConditionModule"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReadConditionModule.html">Read Conditions</a></td></tr>
<tr class="memdesc:group__DDSReadConditionModule"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> and associated elements <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__DDSQueryConditionModule"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSQueryConditionModule.html">Query Conditions</a></td></tr>
<tr class="memdesc:group__DDSQueryConditionModule"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843" title="&lt;&lt;interface&gt;&gt; These are specialised DDS_ReadCondition objects that allow the application to also spec...">DDS_QueryCondition</a> and associated elements <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooDataReader.html">FooDataReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> <em><a class="el" href="group__DDSDocGuideModule.html#a_st_generic">&lt;&lt;generic&gt;&gt;</a></em> User data type-specific data reader.  <a href="structFooDataReader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fab4c627eaeae35f65790cc564208ca2e6" title="The deadline that the DDS_DataReader was expecting through its DDS_DeadlineQosPolicy was not respecte...">DDS_REQUESTED_DEADLINE_MISSED_STATUS</a>  <a href="structDDS__RequestedDeadlineMissedStatus.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa267a5ad100a1e87c372752b6900a9965" title="The liveliness of one or more DDS_DataWriter that were writing instances read through the DDS_DataRea...">DDS_LIVELINESS_CHANGED_STATUS</a>  <a href="structDDS__LivelinessChangedStatus.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa126ff1b38cdfc905353cb2dac57b6796" title="A QosPolicy value was incompatible with what is offered.">DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS</a>  <a href="structDDS__RequestedIncompatibleQosStatus.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa0114c506e39a7fef5a42587556fc812f" title="A sample has been lost (i.e. was never received).">DDS_SAMPLE_LOST_STATUS</a>  <a href="structDDS__SampleLostStatus.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa9e9d4b8dec6fa48c37aa32aa51ad2dd0" title="A (received) sample has been rejected.">DDS_SAMPLE_REJECTED_STATUS</a>  <a href="structDDS__SampleRejectedStatus.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26faceedf0fda6d695b4fabd8ac0af807bb1" title="The DDS_DataReader has found DDS_DataWriter that matches the DDS_Topic and has compatible QoS...">DDS_SUBSCRIPTION_MATCHED_STATUS</a>  <a href="structDDS__SubscriptionMatchedStatus.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderCacheStatus.html">DDS_DataReaderCacheStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> The status of the reader's cache.  <a href="structDDS__DataReaderCacheStatus.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderProtocolStatus.html">DDS_DataReaderProtocolStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> The status of a reader's internal protocol related metrics, like the number of samples received, filtered, rejected; and status of wire protocol traffic.  <a href="structDDS__DataReaderProtocolStatus.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">QoS policies supported by a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> entity.  <a href="structDDS__DataReaderQos.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderSeq.html">DDS_DataReaderSeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares IDL <code>sequence</code> &lt; <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> &gt; .  <a href="structDDS__DataReaderSeq.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> <a class="el" href="structDDS__Listener.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all Listener interfaces.">DDS_Listener</a> for reader status.  <a href="structDDS__DataReaderListener.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga63dd5dce539e1fbfeef6aa103fe5a5c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga63dd5dce539e1fbfeef6aa103fe5a5c6">DDS_RequestedDeadlineMissedStatus_INITIALIZER</a></td></tr>
<tr class="memdesc:ga63dd5dce539e1fbfeef6aa103fe5a5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga63dd5dce539e1fbfeef6aa103fe5a5c6"></a><br/></td></tr>
<tr class="separator:ga63dd5dce539e1fbfeef6aa103fe5a5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2782ef600172b7568bbb2b63bba06579"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga2782ef600172b7568bbb2b63bba06579">DDS_LivelinessChangedStatus_INITIALIZER</a></td></tr>
<tr class="memdesc:ga2782ef600172b7568bbb2b63bba06579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga2782ef600172b7568bbb2b63bba06579"></a><br/></td></tr>
<tr class="separator:ga2782ef600172b7568bbb2b63bba06579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga921a6add7754ae8c670109f4755fd84b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga921a6add7754ae8c670109f4755fd84b">DDS_RequestedIncompatibleQosStatus_INITIALIZER</a></td></tr>
<tr class="memdesc:ga921a6add7754ae8c670109f4755fd84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga921a6add7754ae8c670109f4755fd84b"></a><br/></td></tr>
<tr class="separator:ga921a6add7754ae8c670109f4755fd84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4c1f7a879707692562cd6508d5966aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gaf4c1f7a879707692562cd6508d5966aa">DDS_SampleLostStatus_INITIALIZER</a></td></tr>
<tr class="memdesc:gaf4c1f7a879707692562cd6508d5966aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#gaf4c1f7a879707692562cd6508d5966aa"></a><br/></td></tr>
<tr class="separator:gaf4c1f7a879707692562cd6508d5966aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a4b42a43cd74020e6315ab9fec1895d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga0a4b42a43cd74020e6315ab9fec1895d">DDS_SampleRejectedStatus_INITIALIZER</a></td></tr>
<tr class="memdesc:ga0a4b42a43cd74020e6315ab9fec1895d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga0a4b42a43cd74020e6315ab9fec1895d"></a><br/></td></tr>
<tr class="separator:ga0a4b42a43cd74020e6315ab9fec1895d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c5c0e445a7d0e968129792ee3ad9403"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga6c5c0e445a7d0e968129792ee3ad9403">DDS_SubscriptionMatchedStatus_INITIALIZER</a></td></tr>
<tr class="memdesc:ga6c5c0e445a7d0e968129792ee3ad9403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga6c5c0e445a7d0e968129792ee3ad9403"></a><br/></td></tr>
<tr class="separator:ga6c5c0e445a7d0e968129792ee3ad9403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga901cbe00ad4ca398bbb2d768d2e3e856"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga901cbe00ad4ca398bbb2d768d2e3e856">DDS_DataReaderCacheStatus_INITIALIZER</a></td></tr>
<tr class="memdesc:ga901cbe00ad4ca398bbb2d768d2e3e856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga901cbe00ad4ca398bbb2d768d2e3e856"></a><br/></td></tr>
<tr class="separator:ga901cbe00ad4ca398bbb2d768d2e3e856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaab1c73ce936c2664bf5c5055f32ae9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gafaab1c73ce936c2664bf5c5055f32ae9">DDS_DataReaderProtocolStatus_INITIALIZER</a></td></tr>
<tr class="memdesc:gafaab1c73ce936c2664bf5c5055f32ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#gafaab1c73ce936c2664bf5c5055f32ae9"></a><br/></td></tr>
<tr class="separator:gafaab1c73ce936c2664bf5c5055f32ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b7aa62b41bef09a48fc43ea26d2e645"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga9b7aa62b41bef09a48fc43ea26d2e645">DDS_DataReaderQos_INITIALIZER</a></td></tr>
<tr class="memdesc:ga9b7aa62b41bef09a48fc43ea26d2e645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new QoS instances.  <a href="#ga9b7aa62b41bef09a48fc43ea26d2e645"></a><br/></td></tr>
<tr class="separator:ga9b7aa62b41bef09a48fc43ea26d2e645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73c951eb6afc00d3fccdfca2536bce2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga73c951eb6afc00d3fccdfca2536bce2b">DDS_DataReaderListener_INITIALIZER</a></td></tr>
<tr class="memdesc:ga73c951eb6afc00d3fccdfca2536bce2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a>.  <a href="#ga73c951eb6afc00d3fccdfca2536bce2b"></a><br/></td></tr>
<tr class="separator:ga73c951eb6afc00d3fccdfca2536bce2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga49ce0cab2c1b60ddee4784a1432577a4"><td class="memItemLeft" align="right" valign="top">typedef struct DDS_DataReaderImpl&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a></td></tr>
<tr class="memdesc:ga49ce0cab2c1b60ddee4784a1432577a4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> Allows the application to: (1) declare the data it wishes to receive (i.e. make a subscription) and (2) access the data received by the attached <a class="el" href="group__DDSSubscriberModule.html#ga2755712602505786a23baef5a42d6782" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS_Subscriber</a>.  <a href="#ga49ce0cab2c1b60ddee4784a1432577a4"></a><br/></td></tr>
<tr class="separator:ga49ce0cab2c1b60ddee4784a1432577a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga954dd80bd1a0d5b86f0613462454adef"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga954dd80bd1a0d5b86f0613462454adef">DDS_DataReaderListener_RequestedDeadlineMissedCallback</a> )(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *status)</td></tr>
<tr class="memdesc:ga954dd80bd1a0d5b86f0613462454adef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype of a <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> requested_deadline_missed function.  <a href="#ga954dd80bd1a0d5b86f0613462454adef"></a><br/></td></tr>
<tr class="separator:ga954dd80bd1a0d5b86f0613462454adef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d749ce83353232c9c4a914acc4afce1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga3d749ce83353232c9c4a914acc4afce1">DDS_DataReaderListener_LivelinessChangedCallback</a> )(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *status)</td></tr>
<tr class="memdesc:ga3d749ce83353232c9c4a914acc4afce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype of a <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> liveliness_changed function.  <a href="#ga3d749ce83353232c9c4a914acc4afce1"></a><br/></td></tr>
<tr class="separator:ga3d749ce83353232c9c4a914acc4afce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce87ecc8231a21ba76f0beb752314d2"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gadce87ecc8231a21ba76f0beb752314d2">DDS_DataReaderListener_RequestedIncompatibleQosCallback</a> )(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *status)</td></tr>
<tr class="memdesc:gadce87ecc8231a21ba76f0beb752314d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype of a <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> requested_incompatible_QoS function.  <a href="#gadce87ecc8231a21ba76f0beb752314d2"></a><br/></td></tr>
<tr class="separator:gadce87ecc8231a21ba76f0beb752314d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c033dbc972b3d0c4adac66170251e1a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga6c033dbc972b3d0c4adac66170251e1a">DDS_DataReaderListener_SampleRejectedCallback</a> )(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *status)</td></tr>
<tr class="memdesc:ga6c033dbc972b3d0c4adac66170251e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype of a <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> sample_rejected function.  <a href="#ga6c033dbc972b3d0c4adac66170251e1a"></a><br/></td></tr>
<tr class="separator:ga6c033dbc972b3d0c4adac66170251e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fa5b4a74f27c608ec02108ff2b248f1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga7fa5b4a74f27c608ec02108ff2b248f1">DDS_DataReaderListener_DataAvailableCallback</a> )(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *reader)</td></tr>
<tr class="memdesc:ga7fa5b4a74f27c608ec02108ff2b248f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype of a <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> data_available function.  <a href="#ga7fa5b4a74f27c608ec02108ff2b248f1"></a><br/></td></tr>
<tr class="separator:ga7fa5b4a74f27c608ec02108ff2b248f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25cb1e83a698d3c5b2dd53572b33b376"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga25cb1e83a698d3c5b2dd53572b33b376">DDS_DataReaderListener_SubscriptionMatchedCallback</a> )(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *status)</td></tr>
<tr class="memdesc:ga25cb1e83a698d3c5b2dd53572b33b376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype of a <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> subscription_match function.  <a href="#ga25cb1e83a698d3c5b2dd53572b33b376"></a><br/></td></tr>
<tr class="separator:ga25cb1e83a698d3c5b2dd53572b33b376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07f2384e3cc57a3f53dffb2b48efbab1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga07f2384e3cc57a3f53dffb2b48efbab1">DDS_DataReaderListener_SampleLostCallback</a> )(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *status)</td></tr>
<tr class="memdesc:ga07f2384e3cc57a3f53dffb2b48efbab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype of a <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> subscription_lost function.  <a href="#ga07f2384e3cc57a3f53dffb2b48efbab1"></a><br/></td></tr>
<tr class="separator:ga07f2384e3cc57a3f53dffb2b48efbab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gad50b30818f1c22476283f3dd114a1834"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gad50b30818f1c22476283f3dd114a1834">DDS_SampleLostStatusKind</a> { <br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#ggad50b30818f1c22476283f3dd114a1834a88a29dec42ddfe8b5346325eac2432e4">DDS_NOT_LOST</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#ggad50b30818f1c22476283f3dd114a1834a2764ab3932dd5f738b64d6b79208dd15">DDS_LOST_BY_WRITER</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#ggad50b30818f1c22476283f3dd114a1834a95ee9a6704748fcce62715ba272f360e">DDS_LOST_BY_INSTANCES_LIMIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#ggad50b30818f1c22476283f3dd114a1834a301989c14fc416e42d5e1327e4eacdc0">DDS_LOST_BY_REMOTE_WRITERS_PER_INSTANCE_LIMIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#ggad50b30818f1c22476283f3dd114a1834aaa89fc62dc45b57fef0794a9140b5034">DDS_LOST_BY_INCOMPLETE_COHERENT_SET</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#ggad50b30818f1c22476283f3dd114a1834a55aefe07aa3d87f04d25f13e35d6389f">DDS_LOST_BY_LARGE_COHERENT_SET</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#ggad50b30818f1c22476283f3dd114a1834a14822d440742f69e4b386006bf97717f">DDS_LOST_BY_SAMPLES_PER_REMOTE_WRITER_LIMIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#ggad50b30818f1c22476283f3dd114a1834a7c2e169e733580e9b0952677ec5ed804">DDS_LOST_BY_VIRTUAL_WRITERS_LIMIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#ggad50b30818f1c22476283f3dd114a1834a9d1aeffb37364cf20ffcae72f9a28dd6">DDS_LOST_BY_REMOTE_WRITERS_PER_SAMPLE_LIMIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#ggad50b30818f1c22476283f3dd114a1834aa44d2f74c38e1e9b5636609bc7c7944f">DDS_LOST_BY_AVAILABILITY_WAITING_TIME</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#ggad50b30818f1c22476283f3dd114a1834a7bfdbf1173b8b6b67aa2f2d51fed6091">DDS_LOST_BY_REMOTE_WRITER_SAMPLES_PER_VIRTUAL_QUEUE_LIMIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#ggad50b30818f1c22476283f3dd114a1834a0c3528b082cd0e44375323ae11500abe">DDS_LOST_BY_OUT_OF_MEMORY</a>
<br/>
 }</td></tr>
<tr class="memdesc:gad50b30818f1c22476283f3dd114a1834"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Kinds of reasons why a sample was lost.  <a href="group__DDSReaderModule.html#gad50b30818f1c22476283f3dd114a1834">More...</a><br/></td></tr>
<tr class="separator:gad50b30818f1c22476283f3dd114a1834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08df559babd09ceefcd351b2cb6876f1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga08df559babd09ceefcd351b2cb6876f1">DDS_SampleRejectedStatusKind</a> { <br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#gga08df559babd09ceefcd351b2cb6876f1ae371624e8cee89be655a853a3107fb35">DDS_NOT_REJECTED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#gga08df559babd09ceefcd351b2cb6876f1a0dab8798e087551400c60a82a42ce02a">DDS_REJECTED_BY_INSTANCES_LIMIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#gga08df559babd09ceefcd351b2cb6876f1ad17f50fcc59ea3b9decd493227f6d1ca">DDS_REJECTED_BY_SAMPLES_LIMIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#gga08df559babd09ceefcd351b2cb6876f1aab6c983268ca4dd0520e6705156197b7">DDS_REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#gga08df559babd09ceefcd351b2cb6876f1ac318063c4701ef9d3f77becafd075c6f">DDS_REJECTED_BY_REMOTE_WRITERS_LIMIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#gga08df559babd09ceefcd351b2cb6876f1a3da6690a19e97fa66a68e5c2edb4c85e">DDS_REJECTED_BY_REMOTE_WRITERS_PER_INSTANCE_LIMIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#gga08df559babd09ceefcd351b2cb6876f1a98f2efea03af4d0aecfa356b01e91789">DDS_REJECTED_BY_SAMPLES_PER_REMOTE_WRITER_LIMIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#gga08df559babd09ceefcd351b2cb6876f1a01aac2f41faf7a44e24e0d6354f8bd68">DDS_REJECTED_BY_VIRTUAL_WRITERS_LIMIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#gga08df559babd09ceefcd351b2cb6876f1a285dc1adf73ff5a401d66a684ded45f2">DDS_REJECTED_BY_REMOTE_WRITERS_PER_SAMPLE_LIMIT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__DDSReaderModule.html#gga08df559babd09ceefcd351b2cb6876f1a6f37ba9431ba961c48483d935d9e77c4">DDS_REJECTED_BY_REMOTE_WRITER_SAMPLES_PER_VIRTUAL_QUEUE_LIMIT</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga08df559babd09ceefcd351b2cb6876f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kinds of reasons for rejecting a sample.  <a href="group__DDSReaderModule.html#ga08df559babd09ceefcd351b2cb6876f1">More...</a><br/></td></tr>
<tr class="separator:ga08df559babd09ceefcd351b2cb6876f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0436d021ed263221d64cc4d072cf3b70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga0436d021ed263221d64cc4d072cf3b70">FooDataReader_narrow</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *reader)</td></tr>
<tr class="memdesc:ga0436d021ed263221d64cc4d072cf3b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Narrow the given <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> pointer to a <a class="el" href="structFooDataReader.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; User data type-specific data reader.">FooDataReader</a> pointer.  <a href="#ga0436d021ed263221d64cc4d072cf3b70"></a><br/></td></tr>
<tr class="separator:ga0436d021ed263221d64cc4d072cf3b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e8fa1f655eb6653b53a48e743aa6a86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga1e8fa1f655eb6653b53a48e743aa6a86">FooDataReader_as_datareader</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *reader)</td></tr>
<tr class="memdesc:ga1e8fa1f655eb6653b53a48e743aa6a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Widen the given <a class="el" href="structFooDataReader.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; User data type-specific data reader.">FooDataReader</a> pointer to a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> pointer.  <a href="#ga1e8fa1f655eb6653b53a48e743aa6a86"></a><br/></td></tr>
<tr class="separator:ga1e8fa1f655eb6653b53a48e743aa6a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f8ad6ee21fb024234034bbcce6d812"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812">FooDataReader_read</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> max_samples, <a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a> instance_states)</td></tr>
<tr class="memdesc:ga84f8ad6ee21fb024234034bbcce6d812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>.  <a href="#ga84f8ad6ee21fb024234034bbcce6d812"></a><br/></td></tr>
<tr class="separator:ga84f8ad6ee21fb024234034bbcce6d812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa56233023b6c95f89a9df48d16a4659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659">FooDataReader_take</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> max_samples, <a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a> instance_states)</td></tr>
<tr class="memdesc:gafa56233023b6c95f89a9df48d16a4659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a collection of data-samples from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>.  <a href="#gafa56233023b6c95f89a9df48d16a4659"></a><br/></td></tr>
<tr class="separator:gafa56233023b6c95f89a9df48d16a4659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3aa397b246f0c8e5b62940597dfa280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gab3aa397b246f0c8e5b62940597dfa280">FooDataReader_read_w_condition</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> max_samples, <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a> *condition)</td></tr>
<tr class="memdesc:gab3aa397b246f0c8e5b62940597dfa280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses via <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a>.  <a href="#gab3aa397b246f0c8e5b62940597dfa280"></a><br/></td></tr>
<tr class="separator:gab3aa397b246f0c8e5b62940597dfa280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5340c4c0e6b32c31d36688636c064657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga5340c4c0e6b32c31d36688636c064657">FooDataReader_take_w_condition</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> max_samples, <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a> *condition)</td></tr>
<tr class="memdesc:ga5340c4c0e6b32c31d36688636c064657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to <a class="el" href="group__DDSReaderModule.html#gab3aa397b246f0c8e5b62940597dfa280" title="Accesses via FooDataReader_read the samples that match the criteria specified in the DDS_ReadConditio...">FooDataReader_read_w_condition</a> except it accesses samples via the <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> operation.  <a href="#ga5340c4c0e6b32c31d36688636c064657"></a><br/></td></tr>
<tr class="separator:ga5340c4c0e6b32c31d36688636c064657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf50e7b4ea6b82cf688bd96df1dd5ab4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gacf50e7b4ea6b82cf688bd96df1dd5ab4">FooDataReader_read_next_sample</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFoo.html">Foo</a> *received_data, struct <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> *sample_info)</td></tr>
<tr class="memdesc:gacf50e7b4ea6b82cf688bd96df1dd5ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the next not-previously-accessed data value from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>.  <a href="#gacf50e7b4ea6b82cf688bd96df1dd5ab4"></a><br/></td></tr>
<tr class="separator:gacf50e7b4ea6b82cf688bd96df1dd5ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5f37ece5465c3e64077e8191c328d87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gac5f37ece5465c3e64077e8191c328d87">FooDataReader_take_next_sample</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFoo.html">Foo</a> *received_data, struct <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> *sample_info)</td></tr>
<tr class="memdesc:gac5f37ece5465c3e64077e8191c328d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the next not-previously-accessed data value from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>.  <a href="#gac5f37ece5465c3e64077e8191c328d87"></a><br/></td></tr>
<tr class="separator:gac5f37ece5465c3e64077e8191c328d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c41d6ff208c71f13ff7593d32c50a56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga0c41d6ff208c71f13ff7593d32c50a56">FooDataReader_read_instance</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> max_samples, const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *a_handle, <a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a> instance_states)</td></tr>
<tr class="memdesc:ga0c41d6ff208c71f13ff7593d32c50a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>.  <a href="#ga0c41d6ff208c71f13ff7593d32c50a56"></a><br/></td></tr>
<tr class="separator:ga0c41d6ff208c71f13ff7593d32c50a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab2b14c7a98d1cabdc446b543161668c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gaab2b14c7a98d1cabdc446b543161668c">FooDataReader_take_instance</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> max_samples, const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *a_handle, <a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a> instance_states)</td></tr>
<tr class="memdesc:gaab2b14c7a98d1cabdc446b543161668c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>.  <a href="#gaab2b14c7a98d1cabdc446b543161668c"></a><br/></td></tr>
<tr class="separator:gaab2b14c7a98d1cabdc446b543161668c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga404ce36a7c67a75702d92a29a44039b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga404ce36a7c67a75702d92a29a44039b1">FooDataReader_read_instance_w_condition</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> max_samples, const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *a_handle, <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a> *condition)</td></tr>
<tr class="memdesc:ga404ce36a7c67a75702d92a29a44039b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses via <a class="el" href="group__DDSReaderModule.html#ga0c41d6ff208c71f13ff7593d32c50a56" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_instance</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a>.  <a href="#ga404ce36a7c67a75702d92a29a44039b1"></a><br/></td></tr>
<tr class="separator:ga404ce36a7c67a75702d92a29a44039b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad16b635d874f45e81db59325b280c6fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gad16b635d874f45e81db59325b280c6fb">FooDataReader_take_instance_w_condition</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> max_samples, const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *a_handle, <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a> *condition)</td></tr>
<tr class="memdesc:gad16b635d874f45e81db59325b280c6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses via <a class="el" href="group__DDSReaderModule.html#gaab2b14c7a98d1cabdc446b543161668c" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_take_instance</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a>.  <a href="#gad16b635d874f45e81db59325b280c6fb"></a><br/></td></tr>
<tr class="separator:gad16b635d874f45e81db59325b280c6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga010154c1c20c87500b6068d65c16cdd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9">FooDataReader_read_next_instance</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> max_samples, const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *previous_handle, <a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a> instance_states)</td></tr>
<tr class="memdesc:ga010154c1c20c87500b6068d65c16cdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>.  <a href="#ga010154c1c20c87500b6068d65c16cdd9"></a><br/></td></tr>
<tr class="separator:ga010154c1c20c87500b6068d65c16cdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08724909c0ad0d49f60956f358134adf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga08724909c0ad0d49f60956f358134adf">FooDataReader_take_next_instance</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> max_samples, const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *previous_handle, <a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a> instance_states)</td></tr>
<tr class="memdesc:ga08724909c0ad0d49f60956f358134adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>.  <a href="#ga08724909c0ad0d49f60956f358134adf"></a><br/></td></tr>
<tr class="separator:ga08724909c0ad0d49f60956f358134adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55910a020e513e170ec432db8eda4899"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga55910a020e513e170ec432db8eda4899">FooDataReader_read_next_instance_w_condition</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> max_samples, const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *previous_handle, <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a> *condition)</td></tr>
<tr class="memdesc:ga55910a020e513e170ec432db8eda4899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses via <a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_next_instance</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a>.  <a href="#ga55910a020e513e170ec432db8eda4899"></a><br/></td></tr>
<tr class="separator:ga55910a020e513e170ec432db8eda4899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7d499fba202bd3613c705d53c034a1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gab7d499fba202bd3613c705d53c034a1c">FooDataReader_take_next_instance_w_condition</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, struct <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> max_samples, const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *previous_handle, <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a> *condition)</td></tr>
<tr class="memdesc:gab7d499fba202bd3613c705d53c034a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses via <a class="el" href="group__DDSReaderModule.html#ga08724909c0ad0d49f60956f358134adf" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_take_next_instance</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a>.  <a href="#gab7d499fba202bd3613c705d53c034a1c"></a><br/></td></tr>
<tr class="separator:gab7d499fba202bd3613c705d53c034a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2188ce7cd1b7bed39451833b91f1f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6">FooDataReader_return_loan</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, <a class="el" href="structFooSeq.html">FooSeq</a> *received_data, struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *info_seq)</td></tr>
<tr class="memdesc:gadf2188ce7cd1b7bed39451833b91f1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> that the application is done accessing the collection of <code>received_data</code> and <code>info_seq</code> obtained by some earlier invocation of read or take on the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>.  <a href="#gadf2188ce7cd1b7bed39451833b91f1f6"></a><br/></td></tr>
<tr class="separator:gadf2188ce7cd1b7bed39451833b91f1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga434a5530ff95ee21227e5643273a85d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga434a5530ff95ee21227e5643273a85d4">FooDataReader_get_key_value</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, <a class="el" href="structFoo.html">Foo</a> *key_holder, const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *handle)</td></tr>
<tr class="memdesc:ga434a5530ff95ee21227e5643273a85d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the instance <code>key</code> that corresponds to an instance <code>handle</code>.  <a href="#ga434a5530ff95ee21227e5643273a85d4"></a><br/></td></tr>
<tr class="separator:ga434a5530ff95ee21227e5643273a85d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fd320620045206555b1205574e20424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga2fd320620045206555b1205574e20424">FooDataReader_lookup_instance</a> (<a class="el" href="structFooDataReader.html">FooDataReader</a> *self, const <a class="el" href="structFoo.html">Foo</a> *key_holder)</td></tr>
<tr class="memdesc:ga2fd320620045206555b1205574e20424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the instance <code>handle</code> that corresponds to an instance <code>key_holder</code>.  <a href="#ga2fd320620045206555b1205574e20424"></a><br/></td></tr>
<tr class="separator:ga2fd320620045206555b1205574e20424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae42864b6d0bba9133c02edb8499bebc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gae42864b6d0bba9133c02edb8499bebc7">DDS_RequestedDeadlineMissedStatus_initialize</a> (struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *self)</td></tr>
<tr class="memdesc:gae42864b6d0bba9133c02edb8499bebc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#gae42864b6d0bba9133c02edb8499bebc7"></a><br/></td></tr>
<tr class="separator:gae42864b6d0bba9133c02edb8499bebc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e09cac0e2af80edb94b57272196619"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga24e09cac0e2af80edb94b57272196619">DDS_RequestedDeadlineMissedStatus_copy</a> (struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *self, const struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *source)</td></tr>
<tr class="memdesc:ga24e09cac0e2af80edb94b57272196619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the given status into this status.  <a href="#ga24e09cac0e2af80edb94b57272196619"></a><br/></td></tr>
<tr class="separator:ga24e09cac0e2af80edb94b57272196619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3fba000e337f5b1b3a7aa3eebb0e01d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gab3fba000e337f5b1b3a7aa3eebb0e01d">DDS_RequestedDeadlineMissedStatus_finalize</a> (struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *self)</td></tr>
<tr class="memdesc:gab3fba000e337f5b1b3a7aa3eebb0e01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free any dynamic memory allocated by status instances.  <a href="#gab3fba000e337f5b1b3a7aa3eebb0e01d"></a><br/></td></tr>
<tr class="separator:gab3fba000e337f5b1b3a7aa3eebb0e01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5271a563774a9f2a72809b3735405cd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga5271a563774a9f2a72809b3735405cd8">DDS_LivelinessChangedStatus_initialize</a> (struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *self)</td></tr>
<tr class="memdesc:ga5271a563774a9f2a72809b3735405cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga5271a563774a9f2a72809b3735405cd8"></a><br/></td></tr>
<tr class="separator:ga5271a563774a9f2a72809b3735405cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2e560fe3c0dc385b8f051e39a3b8369"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gaf2e560fe3c0dc385b8f051e39a3b8369">DDS_LivelinessChangedStatus_copy</a> (struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *self, const struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *source)</td></tr>
<tr class="memdesc:gaf2e560fe3c0dc385b8f051e39a3b8369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the given status into this status.  <a href="#gaf2e560fe3c0dc385b8f051e39a3b8369"></a><br/></td></tr>
<tr class="separator:gaf2e560fe3c0dc385b8f051e39a3b8369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab27cc8ce42069622afae27f49b373e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gaab27cc8ce42069622afae27f49b373e0">DDS_LivelinessChangedStatus_finalize</a> (struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *self)</td></tr>
<tr class="memdesc:gaab27cc8ce42069622afae27f49b373e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free any dynamic memory allocated by status instances.  <a href="#gaab27cc8ce42069622afae27f49b373e0"></a><br/></td></tr>
<tr class="separator:gaab27cc8ce42069622afae27f49b373e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420c632bdc10f20b21a9c9ba9ae3b0e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga420c632bdc10f20b21a9c9ba9ae3b0e8">DDS_RequestedIncompatibleQosStatus_initialize</a> (struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *self)</td></tr>
<tr class="memdesc:ga420c632bdc10f20b21a9c9ba9ae3b0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga420c632bdc10f20b21a9c9ba9ae3b0e8"></a><br/></td></tr>
<tr class="separator:ga420c632bdc10f20b21a9c9ba9ae3b0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga683ac618feceb34ab55fe7893c1cc18d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga683ac618feceb34ab55fe7893c1cc18d">DDS_RequestedIncompatibleQosStatus_copy</a> (struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *self, const struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *source)</td></tr>
<tr class="memdesc:ga683ac618feceb34ab55fe7893c1cc18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the given status into this status.  <a href="#ga683ac618feceb34ab55fe7893c1cc18d"></a><br/></td></tr>
<tr class="separator:ga683ac618feceb34ab55fe7893c1cc18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab52ada6e4480cd8d1b296baa2c64ad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gaab52ada6e4480cd8d1b296baa2c64ad9">DDS_RequestedIncompatibleQosStatus_finalize</a> (struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *self)</td></tr>
<tr class="memdesc:gaab52ada6e4480cd8d1b296baa2c64ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free any dynamic memory allocated by status instances.  <a href="#gaab52ada6e4480cd8d1b296baa2c64ad9"></a><br/></td></tr>
<tr class="separator:gaab52ada6e4480cd8d1b296baa2c64ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad9f77fd4d243ffa3c459aa8c436b8ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gaad9f77fd4d243ffa3c459aa8c436b8ff">DDS_SampleLostStatus_initialize</a> (struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *self)</td></tr>
<tr class="memdesc:gaad9f77fd4d243ffa3c459aa8c436b8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#gaad9f77fd4d243ffa3c459aa8c436b8ff"></a><br/></td></tr>
<tr class="separator:gaad9f77fd4d243ffa3c459aa8c436b8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb526d90fdc6fe5dd3e2d7c20868a2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gaaeb526d90fdc6fe5dd3e2d7c20868a2a">DDS_SampleLostStatus_copy</a> (struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *self, const struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *source)</td></tr>
<tr class="memdesc:gaaeb526d90fdc6fe5dd3e2d7c20868a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the given status into this status.  <a href="#gaaeb526d90fdc6fe5dd3e2d7c20868a2a"></a><br/></td></tr>
<tr class="separator:gaaeb526d90fdc6fe5dd3e2d7c20868a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga757dc31c9b9344362cd483f6b3790384"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga757dc31c9b9344362cd483f6b3790384">DDS_SampleLostStatus_finalize</a> (struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *self)</td></tr>
<tr class="memdesc:ga757dc31c9b9344362cd483f6b3790384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free any dynamic memory allocated by status instances.  <a href="#ga757dc31c9b9344362cd483f6b3790384"></a><br/></td></tr>
<tr class="separator:ga757dc31c9b9344362cd483f6b3790384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b8755d6dc935138cc715d5b975202d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gaa8b8755d6dc935138cc715d5b975202d">DDS_SampleRejectedStatus_initialize</a> (struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *self)</td></tr>
<tr class="memdesc:gaa8b8755d6dc935138cc715d5b975202d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#gaa8b8755d6dc935138cc715d5b975202d"></a><br/></td></tr>
<tr class="separator:gaa8b8755d6dc935138cc715d5b975202d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43f3b0fd14443908d67fda7b45d8ea5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga43f3b0fd14443908d67fda7b45d8ea5e">DDS_SampleRejectedStatus_copy</a> (struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *self, const struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *source)</td></tr>
<tr class="memdesc:ga43f3b0fd14443908d67fda7b45d8ea5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the given status into this status.  <a href="#ga43f3b0fd14443908d67fda7b45d8ea5e"></a><br/></td></tr>
<tr class="separator:ga43f3b0fd14443908d67fda7b45d8ea5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f324b1b1b20b914cb0c8422e1003ae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga8f324b1b1b20b914cb0c8422e1003ae9">DDS_SampleRejectedStatus_finalize</a> (struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *self)</td></tr>
<tr class="memdesc:ga8f324b1b1b20b914cb0c8422e1003ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free any dynamic memory allocated by status instances.  <a href="#ga8f324b1b1b20b914cb0c8422e1003ae9"></a><br/></td></tr>
<tr class="separator:ga8f324b1b1b20b914cb0c8422e1003ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54fc534d7b91199b73430c2d43ac1755"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga54fc534d7b91199b73430c2d43ac1755">DDS_SubscriptionMatchedStatus_initialize</a> (struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *self)</td></tr>
<tr class="memdesc:ga54fc534d7b91199b73430c2d43ac1755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#ga54fc534d7b91199b73430c2d43ac1755"></a><br/></td></tr>
<tr class="separator:ga54fc534d7b91199b73430c2d43ac1755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga107f1a93f438655b3a01196a8359a21f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga107f1a93f438655b3a01196a8359a21f">DDS_SubscriptionMatchedStatus_copy</a> (struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *self, const struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *source)</td></tr>
<tr class="memdesc:ga107f1a93f438655b3a01196a8359a21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the given status into this status.  <a href="#ga107f1a93f438655b3a01196a8359a21f"></a><br/></td></tr>
<tr class="separator:ga107f1a93f438655b3a01196a8359a21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae97dae72e3d6f58afd3f6a058bb73b66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gae97dae72e3d6f58afd3f6a058bb73b66">DDS_SubscriptionMatchedStatus_finalize</a> (struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *self)</td></tr>
<tr class="memdesc:gae97dae72e3d6f58afd3f6a058bb73b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free any dynamic memory allocated by status instances.  <a href="#gae97dae72e3d6f58afd3f6a058bb73b66"></a><br/></td></tr>
<tr class="separator:gae97dae72e3d6f58afd3f6a058bb73b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9c14b59e151d9dbdbf940cdc7804bee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gad9c14b59e151d9dbdbf940cdc7804bee">DDS_DataReaderCacheStatus_initialize</a> (struct <a class="el" href="structDDS__DataReaderCacheStatus.html">DDS_DataReaderCacheStatus</a> *self)</td></tr>
<tr class="memdesc:gad9c14b59e151d9dbdbf940cdc7804bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#gad9c14b59e151d9dbdbf940cdc7804bee"></a><br/></td></tr>
<tr class="separator:gad9c14b59e151d9dbdbf940cdc7804bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab70f6bd2a67e9eee11643bfad487ed52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gab70f6bd2a67e9eee11643bfad487ed52">DDS_DataReaderCacheStatus_copy</a> (struct <a class="el" href="structDDS__DataReaderCacheStatus.html">DDS_DataReaderCacheStatus</a> *self, const struct <a class="el" href="structDDS__DataReaderCacheStatus.html">DDS_DataReaderCacheStatus</a> *source)</td></tr>
<tr class="memdesc:gab70f6bd2a67e9eee11643bfad487ed52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the given status into this status.  <a href="#gab70f6bd2a67e9eee11643bfad487ed52"></a><br/></td></tr>
<tr class="separator:gab70f6bd2a67e9eee11643bfad487ed52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45a17706bc1673a4d90a7b190301bd9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga45a17706bc1673a4d90a7b190301bd9c">DDS_DataReaderCacheStatus_finalize</a> (struct <a class="el" href="structDDS__DataReaderCacheStatus.html">DDS_DataReaderCacheStatus</a> *self)</td></tr>
<tr class="memdesc:ga45a17706bc1673a4d90a7b190301bd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free any dynamic memory allocated by status instances.  <a href="#ga45a17706bc1673a4d90a7b190301bd9c"></a><br/></td></tr>
<tr class="separator:ga45a17706bc1673a4d90a7b190301bd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad81b4ada2f2c61fb2a6130951b400400"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gad81b4ada2f2c61fb2a6130951b400400">DDS_DataReaderProtocolStatus_initialize</a> (struct <a class="el" href="structDDS__DataReaderProtocolStatus.html">DDS_DataReaderProtocolStatus</a> *self)</td></tr>
<tr class="memdesc:gad81b4ada2f2c61fb2a6130951b400400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new status instances.  <a href="#gad81b4ada2f2c61fb2a6130951b400400"></a><br/></td></tr>
<tr class="separator:gad81b4ada2f2c61fb2a6130951b400400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac510a168ae4aa5b0dda50839f4506b53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gac510a168ae4aa5b0dda50839f4506b53">DDS_DataReaderProtocolStatus_copy</a> (struct <a class="el" href="structDDS__DataReaderProtocolStatus.html">DDS_DataReaderProtocolStatus</a> *self, const struct <a class="el" href="structDDS__DataReaderProtocolStatus.html">DDS_DataReaderProtocolStatus</a> *source)</td></tr>
<tr class="memdesc:gac510a168ae4aa5b0dda50839f4506b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the given status into this status.  <a href="#gac510a168ae4aa5b0dda50839f4506b53"></a><br/></td></tr>
<tr class="separator:gac510a168ae4aa5b0dda50839f4506b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga418d64947735d8dfd8000d9bcaa7b982"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga418d64947735d8dfd8000d9bcaa7b982">DDS_DataReaderProtocolStatus_finalize</a> (struct <a class="el" href="structDDS__DataReaderProtocolStatus.html">DDS_DataReaderProtocolStatus</a> *self)</td></tr>
<tr class="memdesc:ga418d64947735d8dfd8000d9bcaa7b982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free any dynamic memory allocated by status instances.  <a href="#ga418d64947735d8dfd8000d9bcaa7b982"></a><br/></td></tr>
<tr class="separator:ga418d64947735d8dfd8000d9bcaa7b982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab31248e90a8e3e031540a62dc991f424"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gab31248e90a8e3e031540a62dc991f424">DDS_DataReaderQos_equals</a> (const struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *self, const struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *other)</td></tr>
<tr class="memdesc:gab31248e90a8e3e031540a62dc991f424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a> for equality.  <a href="#gab31248e90a8e3e031540a62dc991f424"></a><br/></td></tr>
<tr class="separator:gab31248e90a8e3e031540a62dc991f424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e821e20642157dc567e18dc7a63346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga45e821e20642157dc567e18dc7a63346">DDS_DataReaderQos_initialize</a> (struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *self)</td></tr>
<tr class="memdesc:ga45e821e20642157dc567e18dc7a63346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for new QoS instances.  <a href="#ga45e821e20642157dc567e18dc7a63346"></a><br/></td></tr>
<tr class="separator:ga45e821e20642157dc567e18dc7a63346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca08c0dd978d76072b4bbfab89299f83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gaca08c0dd978d76072b4bbfab89299f83">DDS_DataReaderQos_copy</a> (struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *self, const struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *source)</td></tr>
<tr class="memdesc:gaca08c0dd978d76072b4bbfab89299f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of the given QoS into this QoS.  <a href="#gaca08c0dd978d76072b4bbfab89299f83"></a><br/></td></tr>
<tr class="separator:gaca08c0dd978d76072b4bbfab89299f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09dfd320506e72b6236c939caba93887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga09dfd320506e72b6236c939caba93887">DDS_DataReaderQos_finalize</a> (struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *self)</td></tr>
<tr class="memdesc:ga09dfd320506e72b6236c939caba93887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free any dynamic memory allocated by the policies in this <a class="el" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a>.  <a href="#ga09dfd320506e72b6236c939caba93887"></a><br/></td></tr>
<tr class="separator:ga09dfd320506e72b6236c939caba93887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f5ee779d32b78d5255ca41ae3b521ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSEntityModule.html#ga928b59d917d674720975f0581149b905">DDS_Entity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga6f5ee779d32b78d5255ca41ae3b521ec">DDS_DataReader_as_entity</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *dataReader)</td></tr>
<tr class="memdesc:ga6f5ee779d32b78d5255ca41ae3b521ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>'s supertype instance.  <a href="#ga6f5ee779d32b78d5255ca41ae3b521ec"></a><br/></td></tr>
<tr class="separator:ga6f5ee779d32b78d5255ca41ae3b521ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6e48531c43261208a355211da9395e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gab6e48531c43261208a355211da9395e0">DDS_DataReader_create_readcondition</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, <a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a> instance_states)</td></tr>
<tr class="memdesc:gab6e48531c43261208a355211da9395e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a>.  <a href="#gab6e48531c43261208a355211da9395e0"></a><br/></td></tr>
<tr class="separator:gab6e48531c43261208a355211da9395e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc22d119a497a8e2359f6cb2ebcfd0fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843">DDS_QueryCondition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gadc22d119a497a8e2359f6cb2ebcfd0fd">DDS_DataReader_create_querycondition</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, <a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a> sample_states, <a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a> view_states, <a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a> instance_states, const char *query_expression, const struct <a class="el" href="structDDS__StringSeq.html">DDS_StringSeq</a> *query_parameters)</td></tr>
<tr class="memdesc:gadc22d119a497a8e2359f6cb2ebcfd0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843" title="&lt;&lt;interface&gt;&gt; These are specialised DDS_ReadCondition objects that allow the application to also spec...">DDS_QueryCondition</a>.  <a href="#gadc22d119a497a8e2359f6cb2ebcfd0fd"></a><br/></td></tr>
<tr class="separator:gadc22d119a497a8e2359f6cb2ebcfd0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47b1ae37d4e2eb9070f8df5b5aa1446b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga47b1ae37d4e2eb9070f8df5b5aa1446b">DDS_DataReader_delete_readcondition</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a> *condition)</td></tr>
<tr class="memdesc:ga47b1ae37d4e2eb9070f8df5b5aa1446b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> or <a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843" title="&lt;&lt;interface&gt;&gt; These are specialised DDS_ReadCondition objects that allow the application to also spec...">DDS_QueryCondition</a> attached to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>.  <a href="#ga47b1ae37d4e2eb9070f8df5b5aa1446b"></a><br/></td></tr>
<tr class="separator:ga47b1ae37d4e2eb9070f8df5b5aa1446b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga605cd53958cf2919c345c76259123650"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga605cd53958cf2919c345c76259123650">DDS_DataReader_delete_contained_entities</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self)</td></tr>
<tr class="memdesc:ga605cd53958cf2919c345c76259123650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all the entities that were created by means of the "create" operations on the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>.  <a href="#ga605cd53958cf2919c345c76259123650"></a><br/></td></tr>
<tr class="separator:ga605cd53958cf2919c345c76259123650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab116e48bb072f448fbf531bf9fd98cc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gab116e48bb072f448fbf531bf9fd98cc8">DDS_DataReader_wait_for_historical_data</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, const struct <a class="el" href="structDDS__Duration__t.html">DDS_Duration_t</a> *max_wait)</td></tr>
<tr class="memdesc:gab116e48bb072f448fbf531bf9fd98cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until all "historical" data is received for <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> entities that have a non-VOLATILE Durability Qos kind.  <a href="#gab116e48bb072f448fbf531bf9fd98cc8"></a><br/></td></tr>
<tr class="separator:gab116e48bb072f448fbf531bf9fd98cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2117c288ee652696be268cad4931b4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gae2117c288ee652696be268cad4931b4b">DDS_DataReader_acknowledge_sample_w_response</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, const struct <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> *sample_info, const struct <a class="el" href="structDDS__AckResponseData__t.html">DDS_AckResponseData_t</a> *response_data)</td></tr>
<tr class="memdesc:gae2117c288ee652696be268cad4931b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledge a single sample explicitly.  <a href="#gae2117c288ee652696be268cad4931b4b"></a><br/></td></tr>
<tr class="separator:gae2117c288ee652696be268cad4931b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ce922a98455ffb9dd25a95ed29f1f8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga5ce922a98455ffb9dd25a95ed29f1f8f">DDS_DataReader_acknowledge_all_w_response</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, const struct <a class="el" href="structDDS__AckResponseData__t.html">DDS_AckResponseData_t</a> *response_data)</td></tr>
<tr class="memdesc:ga5ce922a98455ffb9dd25a95ed29f1f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledge all previously accessed samples.  <a href="#ga5ce922a98455ffb9dd25a95ed29f1f8f"></a><br/></td></tr>
<tr class="separator:ga5ce922a98455ffb9dd25a95ed29f1f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b7f1b1f22a95d3292c85ea3babfeb62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga0b7f1b1f22a95d3292c85ea3babfeb62">DDS_DataReader_acknowledge_sample</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, const struct <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> *sample_info)</td></tr>
<tr class="memdesc:ga0b7f1b1f22a95d3292c85ea3babfeb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledge a single sample explicitly.  <a href="#ga0b7f1b1f22a95d3292c85ea3babfeb62"></a><br/></td></tr>
<tr class="separator:ga0b7f1b1f22a95d3292c85ea3babfeb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e92cfc011f888dd4c03c0a6883a0de7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga5e92cfc011f888dd4c03c0a6883a0de7">DDS_DataReader_acknowledge_all</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self)</td></tr>
<tr class="memdesc:ga5e92cfc011f888dd4c03c0a6883a0de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledge all previously accessed samples.  <a href="#ga5e92cfc011f888dd4c03c0a6883a0de7"></a><br/></td></tr>
<tr class="separator:ga5e92cfc011f888dd4c03c0a6883a0de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2b1864f15a7ffa34859e6eff826c499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gac2b1864f15a7ffa34859e6eff826c499">DDS_DataReader_get_matched_publications</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__InstanceHandleSeq.html">DDS_InstanceHandleSeq</a> *publication_handles)</td></tr>
<tr class="memdesc:gac2b1864f15a7ffa34859e6eff826c499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the list of publications currently "associated" with this <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>.  <a href="#gac2b1864f15a7ffa34859e6eff826c499"></a><br/></td></tr>
<tr class="separator:gac2b1864f15a7ffa34859e6eff826c499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7403be049e90ede89f8a8c1b3a5f4e06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga7403be049e90ede89f8a8c1b3a5f4e06">DDS_DataReader_get_matched_publication_data</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__PublicationBuiltinTopicData.html">DDS_PublicationBuiltinTopicData</a> *publication_data, const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *publication_handle)</td></tr>
<tr class="memdesc:ga7403be049e90ede89f8a8c1b3a5f4e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operation retrieves the information on a publication that is currently "associated" with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>.  <a href="#ga7403be049e90ede89f8a8c1b3a5f4e06"></a><br/></td></tr>
<tr class="separator:ga7403be049e90ede89f8a8c1b3a5f4e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c2a5ee697d6c73a68196a566708abeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga2c2a5ee697d6c73a68196a566708abeb">DDS_DataReader_get_matched_publication_participant_data</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__ParticipantBuiltinTopicData.html">DDS_ParticipantBuiltinTopicData</a> *participant_data, const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *publication_handle)</td></tr>
<tr class="memdesc:ga2c2a5ee697d6c73a68196a566708abeb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> This operation retrieves the information on the discovered <a class="el" href="group__DDSDomainParticipantModule.html#ga1964274885335d5bcea6855f66b0bfe1" title="&lt;&lt;interface&gt;&gt; Container for all DDS_DomainEntity objects.">DDS_DomainParticipant</a> associated with the publication that is currently matching with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>.  <a href="#ga2c2a5ee697d6c73a68196a566708abeb"></a><br/></td></tr>
<tr class="separator:ga2c2a5ee697d6c73a68196a566708abeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098faba88f06eb848d0229a37cc608e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSTopicEntityModule.html#ga89cd495d744b91edd5d6af4b276322c4">DDS_TopicDescription</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga098faba88f06eb848d0229a37cc608e9">DDS_DataReader_get_topicdescription</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self)</td></tr>
<tr class="memdesc:ga098faba88f06eb848d0229a37cc608e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__DDSTopicEntityModule.html#ga89cd495d744b91edd5d6af4b276322c4" title="&lt;&lt;interface&gt;&gt; Base class for DDS_Topic, DDS_ContentFilteredTopic, and DDS_MultiTopic.">DDS_TopicDescription</a> associated with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>.  <a href="#ga098faba88f06eb848d0229a37cc608e9"></a><br/></td></tr>
<tr class="separator:ga098faba88f06eb848d0229a37cc608e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87dc984879b87f0271016e826b26ee31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSSubscriberModule.html#ga2755712602505786a23baef5a42d6782">DDS_Subscriber</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga87dc984879b87f0271016e826b26ee31">DDS_DataReader_get_subscriber</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self)</td></tr>
<tr class="memdesc:ga87dc984879b87f0271016e826b26ee31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__DDSSubscriberModule.html#ga2755712602505786a23baef5a42d6782" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS_Subscriber</a> to which the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> belongs.  <a href="#ga87dc984879b87f0271016e826b26ee31"></a><br/></td></tr>
<tr class="separator:ga87dc984879b87f0271016e826b26ee31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a7bcba6875d06440998cf577e8aec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gac1a7bcba6875d06440998cf577e8aec4">DDS_DataReader_get_sample_rejected_status</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *status)</td></tr>
<tr class="memdesc:gac1a7bcba6875d06440998cf577e8aec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa9e9d4b8dec6fa48c37aa32aa51ad2dd0" title="A (received) sample has been rejected.">DDS_SAMPLE_REJECTED_STATUS</a> communication status.  <a href="#gac1a7bcba6875d06440998cf577e8aec4"></a><br/></td></tr>
<tr class="separator:gac1a7bcba6875d06440998cf577e8aec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceda17acaead9acca331d3902f8da17c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gaceda17acaead9acca331d3902f8da17c">DDS_DataReader_get_liveliness_changed_status</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *status)</td></tr>
<tr class="memdesc:gaceda17acaead9acca331d3902f8da17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa267a5ad100a1e87c372752b6900a9965" title="The liveliness of one or more DDS_DataWriter that were writing instances read through the DDS_DataRea...">DDS_LIVELINESS_CHANGED_STATUS</a> communication status.  <a href="#gaceda17acaead9acca331d3902f8da17c"></a><br/></td></tr>
<tr class="separator:gaceda17acaead9acca331d3902f8da17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad02eeca6be023a820a682dd1f93b9d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gad02eeca6be023a820a682dd1f93b9d3d">DDS_DataReader_get_requested_deadline_missed_status</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *status)</td></tr>
<tr class="memdesc:gad02eeca6be023a820a682dd1f93b9d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fab4c627eaeae35f65790cc564208ca2e6" title="The deadline that the DDS_DataReader was expecting through its DDS_DeadlineQosPolicy was not respecte...">DDS_REQUESTED_DEADLINE_MISSED_STATUS</a> communication status.  <a href="#gad02eeca6be023a820a682dd1f93b9d3d"></a><br/></td></tr>
<tr class="separator:gad02eeca6be023a820a682dd1f93b9d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga590d7b383341749ed2b819252c89c945"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga590d7b383341749ed2b819252c89c945">DDS_DataReader_get_requested_incompatible_qos_status</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *status)</td></tr>
<tr class="memdesc:ga590d7b383341749ed2b819252c89c945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa126ff1b38cdfc905353cb2dac57b6796" title="A QosPolicy value was incompatible with what is offered.">DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS</a> communication status.  <a href="#ga590d7b383341749ed2b819252c89c945"></a><br/></td></tr>
<tr class="separator:ga590d7b383341749ed2b819252c89c945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab74b4f6cabb251f17587cd57a42139e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gab74b4f6cabb251f17587cd57a42139e3">DDS_DataReader_get_subscription_matched_status</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *status)</td></tr>
<tr class="memdesc:gab74b4f6cabb251f17587cd57a42139e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26faceedf0fda6d695b4fabd8ac0af807bb1" title="The DDS_DataReader has found DDS_DataWriter that matches the DDS_Topic and has compatible QoS...">DDS_SUBSCRIPTION_MATCHED_STATUS</a> communication status.  <a href="#gab74b4f6cabb251f17587cd57a42139e3"></a><br/></td></tr>
<tr class="separator:gab74b4f6cabb251f17587cd57a42139e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef247058f61fe47bcb621fd33bf98d83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gaef247058f61fe47bcb621fd33bf98d83">DDS_DataReader_get_sample_lost_status</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *status)</td></tr>
<tr class="memdesc:gaef247058f61fe47bcb621fd33bf98d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa0114c506e39a7fef5a42587556fc812f" title="A sample has been lost (i.e. was never received).">DDS_SAMPLE_LOST_STATUS</a> communication status.  <a href="#gaef247058f61fe47bcb621fd33bf98d83"></a><br/></td></tr>
<tr class="separator:gaef247058f61fe47bcb621fd33bf98d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93a94e1fd1aafc39f3c7e806d1d10f0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga93a94e1fd1aafc39f3c7e806d1d10f0f">DDS_DataReader_get_datareader_cache_status</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__DataReaderCacheStatus.html">DDS_DataReaderCacheStatus</a> *status)</td></tr>
<tr class="memdesc:ga93a94e1fd1aafc39f3c7e806d1d10f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Get the datareader cache status for this reader.  <a href="#ga93a94e1fd1aafc39f3c7e806d1d10f0f"></a><br/></td></tr>
<tr class="separator:ga93a94e1fd1aafc39f3c7e806d1d10f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7a347d2add85ece49739512970972c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gac7a347d2add85ece49739512970972c8">DDS_DataReader_get_datareader_protocol_status</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__DataReaderProtocolStatus.html">DDS_DataReaderProtocolStatus</a> *status)</td></tr>
<tr class="memdesc:gac7a347d2add85ece49739512970972c8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Get the datareader protocol status for this reader.  <a href="#gac7a347d2add85ece49739512970972c8"></a><br/></td></tr>
<tr class="separator:gac7a347d2add85ece49739512970972c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91424a08c0885e7e82802b8f0f59d552"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga91424a08c0885e7e82802b8f0f59d552">DDS_DataReader_get_matched_publication_datareader_protocol_status</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__DataReaderProtocolStatus.html">DDS_DataReaderProtocolStatus</a> *status, const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *publication_handle)</td></tr>
<tr class="memdesc:ga91424a08c0885e7e82802b8f0f59d552"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Get the datareader protocol status for this reader, per matched publication identified by the publication_handle.  <a href="#ga91424a08c0885e7e82802b8f0f59d552"></a><br/></td></tr>
<tr class="separator:ga91424a08c0885e7e82802b8f0f59d552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6edf6c1cb03f06c3647ee838b279de8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gac6edf6c1cb03f06c3647ee838b279de8">DDS_DataReader_set_qos</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, const struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *qos)</td></tr>
<tr class="memdesc:gac6edf6c1cb03f06c3647ee838b279de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reader QoS.  <a href="#gac6edf6c1cb03f06c3647ee838b279de8"></a><br/></td></tr>
<tr class="separator:gac6edf6c1cb03f06c3647ee838b279de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d9dd690919ee72be4c26d59e66a567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga82d9dd690919ee72be4c26d59e66a567">DDS_DataReader_set_qos_with_profile</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, const char *library_name, const char *profile_name)</td></tr>
<tr class="memdesc:ga82d9dd690919ee72be4c26d59e66a567"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Change the QoS of this reader using the input XML QoS profile.  <a href="#ga82d9dd690919ee72be4c26d59e66a567"></a><br/></td></tr>
<tr class="separator:ga82d9dd690919ee72be4c26d59e66a567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b1cfff484564089701bc91eb3edafe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gae5b1cfff484564089701bc91eb3edafe">DDS_DataReader_get_qos</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *qos)</td></tr>
<tr class="memdesc:gae5b1cfff484564089701bc91eb3edafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reader QoS.  <a href="#gae5b1cfff484564089701bc91eb3edafe"></a><br/></td></tr>
<tr class="separator:gae5b1cfff484564089701bc91eb3edafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6af5ac237d6c16988546befcbbc53a27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga6af5ac237d6c16988546befcbbc53a27">DDS_DataReader_set_listener</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, const struct <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> *l, <a class="el" href="group__DDSStatusTypesModule.html#ga4d99a5cbe5e3451400717c8358be6377">DDS_StatusMask</a> mask)</td></tr>
<tr class="memdesc:ga6af5ac237d6c16988546befcbbc53a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reader listener.  <a href="#ga6af5ac237d6c16988546befcbbc53a27"></a><br/></td></tr>
<tr class="separator:ga6af5ac237d6c16988546befcbbc53a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade4c138c7861e56d4fd03372031c9ae3"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#gade4c138c7861e56d4fd03372031c9ae3">DDS_DataReader_get_listener</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self)</td></tr>
<tr class="memdesc:gade4c138c7861e56d4fd03372031c9ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reader listener.  <a href="#gade4c138c7861e56d4fd03372031c9ae3"></a><br/></td></tr>
<tr class="separator:gade4c138c7861e56d4fd03372031c9ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c40a4095755948fc68b0cb906dd5dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSReaderModule.html#ga39c40a4095755948fc68b0cb906dd5dd">DDS_DataReader_get_listenerX</a> (<a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *self, struct <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> *listener)</td></tr>
<tr class="memdesc:ga39c40a4095755948fc68b0cb906dd5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Get the reader listener.  <a href="#ga39c40a4095755948fc68b0cb906dd5dd"></a><br/></td></tr>
<tr class="separator:ga39c40a4095755948fc68b0cb906dd5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<p><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> entity and associated elements </p>
<h2>Macro Definition Documentation</h2>
<a class="anchor" id="ga63dd5dce539e1fbfeef6aa103fe5a5c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DDS_RequestedDeadlineMissedStatus_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html" title="DDS_REQUESTED_DEADLINE_MISSED_STATUS">DDS_RequestedDeadlineMissedStatus</a> instances that are stored on the stack should be initialized with this value before they are passed to any methods. This step ensures that those fields that use dynamic memory are properly initialized. This does not allocate memory. </p>
<p>The simplest way to create a status structure is to initialize it on the stack at the time of its creation. <a class="el" href="group__DDSTopicEntityModule.html#gac3a243ae5a2f2909cf44f9eb7c7b54e0" title="Free any dynamic memory allocated by status instances.">DDS_InconsistentTopicStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structDDS__RequestedDeadlineMissedStatus.html" title="DDS_REQUESTED_DEADLINE_MISSED_STATUS">DDS_RequestedDeadlineMissedStatus</a> myStatus = <a class="code" href="group__DDSReaderModule.html#ga63dd5dce539e1fbfeef6aa103fe5a5c6" title="Initializer for new status instances.">DDS_RequestedDeadlineMissedStatus_INITIALIZER</a>; </div>
<div class="line"> ... </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#gab3fba000e337f5b1b3a7aa3eebb0e01d" title="Free any dynamic memory allocated by status instances.">DDS_RequestedDeadlineMissedStatus_finalize</a>(&amp;myStatus);                     </div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#gae42864b6d0bba9133c02edb8499bebc7" title="Initializer for new status instances.">DDS_RequestedDeadlineMissedStatus_initialize</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gab3fba000e337f5b1b3a7aa3eebb0e01d" title="Free any dynamic memory allocated by status instances.">DDS_RequestedDeadlineMissedStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2782ef600172b7568bbb2b63bba06579"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DDS_LivelinessChangedStatus_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__LivelinessChangedStatus.html" title="DDS_LIVELINESS_CHANGED_STATUS">DDS_LivelinessChangedStatus</a> instances that are stored on the stack should be initialized with this value before they are passed to any function. This step ensures that those fields that use dynamic memory are properly initialized. This does not allocate memory. </p>
<p>The simplest way to create a status structure is to initialize it on the stack at the time of its creation. <a class="el" href="group__DDSReaderModule.html#gaab27cc8ce42069622afae27f49b373e0" title="Free any dynamic memory allocated by status instances.">DDS_LivelinessChangedStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structDDS__LivelinessChangedStatus.html" title="DDS_LIVELINESS_CHANGED_STATUS">DDS_LivelinessChangedStatus</a> myStatus = <a class="code" href="group__DDSReaderModule.html#ga2782ef600172b7568bbb2b63bba06579" title="Initializer for new status instances.">DDS_LivelinessChangedStatus_INITIALIZER</a>; </div>
<div class="line"> ... </div>
<div class="line"> DDS_LivelinessChangedStatuss_finalize(&amp;myStatus);                     </div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga5271a563774a9f2a72809b3735405cd8" title="Initializer for new status instances.">DDS_LivelinessChangedStatus_initialize</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gaab27cc8ce42069622afae27f49b373e0" title="Free any dynamic memory allocated by status instances.">DDS_LivelinessChangedStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga921a6add7754ae8c670109f4755fd84b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DDS_RequestedIncompatibleQosStatus_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html" title="DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS">DDS_RequestedIncompatibleQosStatus</a> instances that are stored on the stack should be initialized with this value before they are passed to any function. This step ensures that those fields that use dynamic memory are properly initialized. This does not allocate memory. </p>
<p>The simplest way to create a status structure is to initialize it on the stack at the time of its creation. <a class="el" href="group__DDSReaderModule.html#gaab52ada6e4480cd8d1b296baa2c64ad9" title="Free any dynamic memory allocated by status instances.">DDS_RequestedIncompatibleQosStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structDDS__RequestedIncompatibleQosStatus.html" title="DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS">DDS_RequestedIncompatibleQosStatus</a> myStatus = <a class="code" href="group__DDSReaderModule.html#ga921a6add7754ae8c670109f4755fd84b" title="Initializer for new status instances.">DDS_RequestedIncompatibleQosStatus_INITIALIZER</a>; </div>
<div class="line"> ... </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#gaab52ada6e4480cd8d1b296baa2c64ad9" title="Free any dynamic memory allocated by status instances.">DDS_RequestedIncompatibleQosStatus_finalize</a>(&amp;myStatus);                     </div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga420c632bdc10f20b21a9c9ba9ae3b0e8" title="Initializer for new status instances.">DDS_RequestedIncompatibleQosStatus_initialize</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gaab52ada6e4480cd8d1b296baa2c64ad9" title="Free any dynamic memory allocated by status instances.">DDS_RequestedIncompatibleQosStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf4c1f7a879707692562cd6508d5966aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DDS_SampleLostStatus_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__SampleLostStatus.html" title="DDS_SAMPLE_LOST_STATUS">DDS_SampleLostStatus</a> instances that are stored on the stack should be initialized with this value before they are passed to any function. This step ensures that those fields that use dynamic memory are properly initialized. This does not allocate memory. </p>
<p>The simplest way to create a status structure is to initialize it on the stack at the time of its creation. <a class="el" href="group__DDSReaderModule.html#ga757dc31c9b9344362cd483f6b3790384" title="Free any dynamic memory allocated by status instances.">DDS_SampleLostStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structDDS__SampleLostStatus.html" title="DDS_SAMPLE_LOST_STATUS">DDS_SampleLostStatus</a> myStatus = <a class="code" href="group__DDSReaderModule.html#gaf4c1f7a879707692562cd6508d5966aa" title="Initializer for new status instances.">DDS_SampleLostStatus_INITIALIZER</a>; </div>
<div class="line"> ... </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#ga757dc31c9b9344362cd483f6b3790384" title="Free any dynamic memory allocated by status instances.">DDS_SampleLostStatus_finalize</a>(&amp;myStatus);                     </div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#gaad9f77fd4d243ffa3c459aa8c436b8ff" title="Initializer for new status instances.">DDS_SampleLostStatus_initialize</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#ga757dc31c9b9344362cd483f6b3790384" title="Free any dynamic memory allocated by status instances.">DDS_SampleLostStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a4b42a43cd74020e6315ab9fec1895d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DDS_SampleRejectedStatus_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__SampleRejectedStatus.html" title="DDS_SAMPLE_REJECTED_STATUS">DDS_SampleRejectedStatus</a> instances that are stored on the stack should be initialized with this value before they are passed to any function. This step ensures that those fields that use dynamic memory are properly initialized. This does not allocate memory. </p>
<p>The simplest way to create a status structure is to initialize it on the stack at the time of its creation. <a class="el" href="group__DDSReaderModule.html#ga8f324b1b1b20b914cb0c8422e1003ae9" title="Free any dynamic memory allocated by status instances.">DDS_SampleRejectedStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structDDS__SampleRejectedStatus.html" title="DDS_SAMPLE_REJECTED_STATUS">DDS_SampleRejectedStatus</a> myStatus = <a class="code" href="group__DDSReaderModule.html#ga0a4b42a43cd74020e6315ab9fec1895d" title="Initializer for new status instances.">DDS_SampleRejectedStatus_INITIALIZER</a>; </div>
<div class="line"> ... </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#ga8f324b1b1b20b914cb0c8422e1003ae9" title="Free any dynamic memory allocated by status instances.">DDS_SampleRejectedStatus_finalize</a>(&amp;myStatus);                     </div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#gaa8b8755d6dc935138cc715d5b975202d" title="Initializer for new status instances.">DDS_SampleRejectedStatus_initialize</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#ga8f324b1b1b20b914cb0c8422e1003ae9" title="Free any dynamic memory allocated by status instances.">DDS_SampleRejectedStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c5c0e445a7d0e968129792ee3ad9403"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DDS_SubscriptionMatchedStatus_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__SubscriptionMatchedStatus.html" title="DDS_SUBSCRIPTION_MATCHED_STATUS">DDS_SubscriptionMatchedStatus</a> instances that are stored on the stack should be initialized with this value before they are passed to any function. This step ensures that those fields that use dynamic memory are properly initialized. This does not allocate memory. </p>
<p>The simplest way to create a status structure is to initialize it on the stack at the time of its creation. <a class="el" href="group__DDSReaderModule.html#gae97dae72e3d6f58afd3f6a058bb73b66" title="Free any dynamic memory allocated by status instances.">DDS_SubscriptionMatchedStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structDDS__SubscriptionMatchedStatus.html" title="DDS_SUBSCRIPTION_MATCHED_STATUS">DDS_SubscriptionMatchedStatus</a> myStatus = <a class="code" href="group__DDSReaderModule.html#ga6c5c0e445a7d0e968129792ee3ad9403" title="Initializer for new status instances.">DDS_SubscriptionMatchedStatus_INITIALIZER</a>; </div>
<div class="line"> ... </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#gae97dae72e3d6f58afd3f6a058bb73b66" title="Free any dynamic memory allocated by status instances.">DDS_SubscriptionMatchedStatus_finalize</a>(&amp;myStatus);                     </div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga54fc534d7b91199b73430c2d43ac1755" title="Initializer for new status instances.">DDS_SubscriptionMatchedStatus_initialize</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gae97dae72e3d6f58afd3f6a058bb73b66" title="Free any dynamic memory allocated by status instances.">DDS_SubscriptionMatchedStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga901cbe00ad4ca398bbb2d768d2e3e856"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DDS_DataReaderCacheStatus_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__DataReaderCacheStatus.html" title="&lt;&lt;extension&gt;&gt; The status of the reader&#39;s cache.">DDS_DataReaderCacheStatus</a> instances stored on the stack should be initialized with this value before they are passed to any function. This step ensures that those fields that use dynamic memory are properly initialized. This does not allocate memory. </p>
<p>The simplest way to create a status structure is to initialize it on the stack at the time of its creation. <a class="el" href="group__DDSReaderModule.html#ga45a17706bc1673a4d90a7b190301bd9c" title="Free any dynamic memory allocated by status instances.">DDS_DataReaderCacheStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structDDS__DataReaderCacheStatus.html" title="&lt;&lt;extension&gt;&gt; The status of the reader&#39;s cache.">DDS_DataReaderCacheStatus</a> myStatus = <a class="code" href="group__DDSReaderModule.html#ga901cbe00ad4ca398bbb2d768d2e3e856" title="Initializer for new status instances.">DDS_DataReaderCacheStatus_INITIALIZER</a>; </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#ga93a94e1fd1aafc39f3c7e806d1d10f0f" title="&lt;&lt;extension&gt;&gt; Get the datareader cache status for this reader.">DDS_DataReader_get_datareader_cache_status</a>(myDataReader, &amp;myStatus); </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#ga45a17706bc1673a4d90a7b190301bd9c" title="Free any dynamic memory allocated by status instances.">DDS_DataReaderCacheStatus_finalize</a>(&amp;myStatus);                     </div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga93a94e1fd1aafc39f3c7e806d1d10f0f" title="&lt;&lt;extension&gt;&gt; Get the datareader cache status for this reader.">DDS_DataReader_get_datareader_cache_status</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#ga45a17706bc1673a4d90a7b190301bd9c" title="Free any dynamic memory allocated by status instances.">DDS_DataReaderCacheStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafaab1c73ce936c2664bf5c5055f32ae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DDS_DataReaderProtocolStatus_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__DataReaderProtocolStatus.html" title="&lt;&lt;extension&gt;&gt; The status of a reader&#39;s internal protocol related metrics, like the number of samp...">DDS_DataReaderProtocolStatus</a> instances stored on the stack should be initialized with this value before they are passed to any function. This step ensures that those fields that use dynamic memory are properly initialized. This does not allocate memory. </p>
<p>The simplest way to create a status structure is to initialize it on the stack at the time of its creation. <a class="el" href="group__DDSReaderModule.html#ga418d64947735d8dfd8000d9bcaa7b982" title="Free any dynamic memory allocated by status instances.">DDS_DataReaderProtocolStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structDDS__DataReaderProtocolStatus.html" title="&lt;&lt;extension&gt;&gt; The status of a reader&#39;s internal protocol related metrics, like the number of samp...">DDS_DataReaderProtocolStatus</a> myStatus = <a class="code" href="group__DDSReaderModule.html#gafaab1c73ce936c2664bf5c5055f32ae9" title="Initializer for new status instances.">DDS_DataReaderProtocolStatus_INITIALIZER</a>; </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#gac7a347d2add85ece49739512970972c8" title="&lt;&lt;extension&gt;&gt; Get the datareader protocol status for this reader.">DDS_DataReader_get_datareader_protocol_status</a>(myDataReader, &amp;myStatus); </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#ga418d64947735d8dfd8000d9bcaa7b982" title="Free any dynamic memory allocated by status instances.">DDS_DataReaderProtocolStatus_finalize</a>(&amp;myStatus);                     </div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#gac7a347d2add85ece49739512970972c8" title="&lt;&lt;extension&gt;&gt; Get the datareader protocol status for this reader.">DDS_DataReader_get_datareader_protocol_status</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#ga418d64947735d8dfd8000d9bcaa7b982" title="Free any dynamic memory allocated by status instances.">DDS_DataReaderProtocolStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b7aa62b41bef09a48fc43ea26d2e645"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DDS_DataReaderQos_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new QoS instances. </p>
<p>New <a class="el" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a> instances that are stored in the stack should be initialized with this value before they are passed to any function. This step ensures that those contained QoS policies that use dynamic memory are properly initialized. </p>
<p>The simplest way to create a new QoS structure is to initialize it on the stack at the time of its creation: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a> myQos = <a class="code" href="group__DDSReaderModule.html#ga9b7aa62b41bef09a48fc43ea26d2e645" title="Initializer for new QoS instances.">DDS_DataReaderQos_INITIALIZER</a>;                     </div>
</div><!-- fragment --> <p>Note that the above assignment is not a substitute for calling <a class="el" href="group__DDSSubscriberModule.html#gab34681872803713ab97a63be91794fbd" title="Copies the default DDS_DataReaderQos values into the provided DDS_DataReaderQos instance.">DDS_Subscriber_get_default_datareader_qos</a> or <a class="el" href="group__DDSReaderModule.html#gae5b1cfff484564089701bc91eb3edafe" title="Gets the reader QoS.">DDS_DataReader_get_qos</a>; one of those should be called subsequently to setting the QoS of a new or existing entity: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a> myQos = <a class="code" href="group__DDSReaderModule.html#ga9b7aa62b41bef09a48fc43ea26d2e645" title="Initializer for new QoS instances.">DDS_DataReaderQos_INITIALIZER</a>;</div>
<div class="line"> <a class="code" href="group__DDSSubscriberModule.html#gab34681872803713ab97a63be91794fbd" title="Copies the default DDS_DataReaderQos values into the provided DDS_DataReaderQos instance.">DDS_Subscriber_get_default_datareader_qos</a>(mySub, &amp;myQos);</div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#gae5b1cfff484564089701bc91eb3edafe" title="Gets the reader QoS.">DDS_DataReader_get_qos</a>(myReader, &amp;myQos);</div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga45e821e20642157dc567e18dc7a63346" title="Initializer for new QoS instances.">DDS_DataReaderQos_initialize</a> </dd>
<dd>
<a class="el" href="group__DDSSubscriberModule.html#gab34681872803713ab97a63be91794fbd" title="Copies the default DDS_DataReaderQos values into the provided DDS_DataReaderQos instance.">DDS_Subscriber_get_default_datareader_qos</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#ga09dfd320506e72b6236c939caba93887" title="Free any dynamic memory allocated by the policies in this DDS_DataReaderQos.">DDS_DataReaderQos_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga73c951eb6afc00d3fccdfca2536bce2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DDS_DataReaderListener_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a>. </p>
<p>All the new instances allocated in the stack should be initialized to this value.No memory is allocated. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="HelloWorld_subscriber_8c-example.html#a18">HelloWorld_subscriber.c</a>.</dd>
</dl>
</div>
</div>
<h2>Typedef Documentation</h2>
<a class="anchor" id="ga49ce0cab2c1b60ddee4784a1432577a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct DDS_DataReaderImpl <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> Allows the application to: (1) declare the data it wishes to receive (i.e. make a subscription) and (2) access the data received by the attached <a class="el" href="group__DDSSubscriberModule.html#ga2755712602505786a23baef5a42d6782" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS_Subscriber</a>. </p>
<dl class="section user"><dt>QoS:</dt><dd><a class="el" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a> </dd></dl>
<dl class="section user"><dt>Status:</dt><dd><a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa9d2d926d515abd0ddd0b537efd42f03e" title="One or more new data samples have been received.">DDS_DATA_AVAILABLE_STATUS</a>;<br/>
 <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa267a5ad100a1e87c372752b6900a9965" title="The liveliness of one or more DDS_DataWriter that were writing instances read through the DDS_DataRea...">DDS_LIVELINESS_CHANGED_STATUS</a>, <a class="el" href="structDDS__LivelinessChangedStatus.html" title="DDS_LIVELINESS_CHANGED_STATUS">DDS_LivelinessChangedStatus</a>;<br/>
 <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fab4c627eaeae35f65790cc564208ca2e6" title="The deadline that the DDS_DataReader was expecting through its DDS_DeadlineQosPolicy was not respecte...">DDS_REQUESTED_DEADLINE_MISSED_STATUS</a>, <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html" title="DDS_REQUESTED_DEADLINE_MISSED_STATUS">DDS_RequestedDeadlineMissedStatus</a>;<br/>
 <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa126ff1b38cdfc905353cb2dac57b6796" title="A QosPolicy value was incompatible with what is offered.">DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS</a>, <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html" title="DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS">DDS_RequestedIncompatibleQosStatus</a>;<br/>
 <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa0114c506e39a7fef5a42587556fc812f" title="A sample has been lost (i.e. was never received).">DDS_SAMPLE_LOST_STATUS</a>, <a class="el" href="structDDS__SampleLostStatus.html" title="DDS_SAMPLE_LOST_STATUS">DDS_SampleLostStatus</a>;<br/>
 <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa9e9d4b8dec6fa48c37aa32aa51ad2dd0" title="A (received) sample has been rejected.">DDS_SAMPLE_REJECTED_STATUS</a>, <a class="el" href="structDDS__SampleRejectedStatus.html" title="DDS_SAMPLE_REJECTED_STATUS">DDS_SampleRejectedStatus</a>;<br/>
 <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26faceedf0fda6d695b4fabd8ac0af807bb1" title="The DDS_DataReader has found DDS_DataWriter that matches the DDS_Topic and has compatible QoS...">DDS_SUBSCRIPTION_MATCHED_STATUS</a>, <a class="el" href="structDDS__SubscriptionMatchedStatus.html" title="DDS_SUBSCRIPTION_MATCHED_STATUS">DDS_SubscriptionMatchedStatus</a>;<br/>
 </dd></dl>
<dl class="section user"><dt>Listener:</dt><dd><a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> </dd></dl>
<p>A <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> refers to exactly one <a class="el" href="group__DDSTopicEntityModule.html#ga89cd495d744b91edd5d6af4b276322c4" title="&lt;&lt;interface&gt;&gt; Base class for DDS_Topic, DDS_ContentFilteredTopic, and DDS_MultiTopic.">DDS_TopicDescription</a> (either a <a class="el" href="group__DDSTopicEntityModule.html#ga7f615cc63381c78f535904e370cf1356" title="&lt;&lt;interface&gt;&gt; The most basic description of the data to be published and subscribed.">DDS_Topic</a>, a <a class="el" href="group__DDSTopicEntityModule.html#ga84a9ecf9064ecc6b3fb4d8dcc5bda0a6" title="&lt;&lt;interface&gt;&gt; Specialization of DDS_TopicDescription that allows for content-based subscriptions...">DDS_ContentFilteredTopic</a> or a <a class="el" href="group__DDSTopicEntityModule.html#ga6b0bc43fd1b002f8c3e6d94efa708c98" title="[Not supported (optional)] &lt;&lt;interface&gt;&gt; A specialization of DDS_TopicDescription that allows subscri...">DDS_MultiTopic</a>) that identifies the data to be read. </p>
<p>The subscription has a unique resulting type. The data-reader may give access to several instances of the resulting type, which can be distinguished from each other by their <code>key</code>. </p>
<p><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> is an abstract class. It must be specialised for each particular application data-type (see <a class="el" href="group__DDSUserDataQosModule.html">USER_DATA</a>). The additional methods or functions that must be defined in the auto-generated class for a hypothetical application type <code><a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a></code> are specified in the generic type <a class="el" href="structFooDataReader.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; User data type-specific data reader.">FooDataReader</a>. </p>
<p>The following operations may be called even if the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> is not enabled. Other operations will fail with the value <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a> if called on a disabled <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>: </p>
<ul>
<li>The base-class operations <a class="el" href="group__DDSReaderModule.html#gac6edf6c1cb03f06c3647ee838b279de8" title="Sets the reader QoS.">DDS_DataReader_set_qos</a>, <a class="el" href="group__DDSReaderModule.html#gae5b1cfff484564089701bc91eb3edafe" title="Gets the reader QoS.">DDS_DataReader_get_qos</a>, <a class="el" href="group__DDSReaderModule.html#ga6af5ac237d6c16988546befcbbc53a27" title="Sets the reader listener.">DDS_DataReader_set_listener</a>, <a class="el" href="group__DDSReaderModule.html#gade4c138c7861e56d4fd03372031c9ae3" title="Get the reader listener.">DDS_DataReader_get_listener</a>, <a class="el" href="group__DDSEntityModule.html#ga892fed8d9375b7c3c5f1f610f87e18da" title="Enables the DDS_Entity.">DDS_Entity_enable</a>, <a class="el" href="group__DDSEntityModule.html#ga6b87d4852f75de23efabe17207d42bfd" title="Allows access to the DDS_StatusCondition associated with the DDS_Entity.">DDS_Entity_get_statuscondition</a>, <a class="el" href="group__DDSEntityModule.html#ga5fc8d3d98ea83e405673e1797521ccca" title="Retrieves the list of communication statuses in the DDS_Entity that are triggered.">DDS_Entity_get_status_changes</a>, </li>
<li><a class="el" href="group__DDSReaderModule.html#gaceda17acaead9acca331d3902f8da17c" title="Accesses the DDS_LIVELINESS_CHANGED_STATUS communication status.">DDS_DataReader_get_liveliness_changed_status</a>, <a class="el" href="group__DDSReaderModule.html#gad02eeca6be023a820a682dd1f93b9d3d" title="Accesses the DDS_REQUESTED_DEADLINE_MISSED_STATUS communication status.">DDS_DataReader_get_requested_deadline_missed_status</a>, <a class="el" href="group__DDSReaderModule.html#ga590d7b383341749ed2b819252c89c945" title="Accesses the DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS communication status.">DDS_DataReader_get_requested_incompatible_qos_status</a>, <a class="el" href="group__DDSReaderModule.html#gaef247058f61fe47bcb621fd33bf98d83" title="Accesses the DDS_SAMPLE_LOST_STATUS communication status.">DDS_DataReader_get_sample_lost_status</a>, <a class="el" href="group__DDSReaderModule.html#gac1a7bcba6875d06440998cf577e8aec4" title="Accesses the DDS_SAMPLE_REJECTED_STATUS communication status.">DDS_DataReader_get_sample_rejected_status</a>, <a class="el" href="group__DDSReaderModule.html#gab74b4f6cabb251f17587cd57a42139e3" title="Accesses the DDS_SUBSCRIPTION_MATCHED_STATUS communication status.">DDS_DataReader_get_subscription_matched_status</a> </li>
</ul>
<p>All sample-accessing operations, namely: <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a>, <a class="el" href="group__DDSReaderModule.html#gab3aa397b246f0c8e5b62940597dfa280" title="Accesses via FooDataReader_read the samples that match the criteria specified in the DDS_ReadConditio...">FooDataReader_read_w_condition</a>, and <a class="el" href="group__DDSReaderModule.html#ga5340c4c0e6b32c31d36688636c064657" title="Analogous to FooDataReader_read_w_condition except it accesses samples via the FooDataReader_take ope...">FooDataReader_take_w_condition</a> may fail with the error <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a> as described in <a class="el" href="group__DDSSubscriberModule.html#ga0ad1e6a4e43dcbf08f9807019bb5588a" title="Indicates that the application is about to access the data samples in any of the DDS_DataReader objec...">DDS_Subscriber_begin_access</a>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__Listener.html#SharedEACallbackRules">Operations Allowed in Listener Callbacks</a> </dd>
<dd>
<a class="el" href="group__DDSSubscriptionModule.html#Subscription_access_samples">Access to data samples</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga954dd80bd1a0d5b86f0613462454adef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* DDS_DataReaderListener_RequestedDeadlineMissedCallback)(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype of a <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> requested_deadline_missed function. </p>

</div>
</div>
<a class="anchor" id="ga3d749ce83353232c9c4a914acc4afce1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* DDS_DataReaderListener_LivelinessChangedCallback)(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype of a <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> liveliness_changed function. </p>

</div>
</div>
<a class="anchor" id="gadce87ecc8231a21ba76f0beb752314d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* DDS_DataReaderListener_RequestedIncompatibleQosCallback)(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype of a <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> requested_incompatible_QoS function. </p>

</div>
</div>
<a class="anchor" id="ga6c033dbc972b3d0c4adac66170251e1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* DDS_DataReaderListener_SampleRejectedCallback)(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype of a <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> sample_rejected function. </p>

</div>
</div>
<a class="anchor" id="ga7fa5b4a74f27c608ec02108ff2b248f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* DDS_DataReaderListener_DataAvailableCallback)(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *reader)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype of a <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> data_available function. </p>

</div>
</div>
<a class="anchor" id="ga25cb1e83a698d3c5b2dd53572b33b376"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* DDS_DataReaderListener_SubscriptionMatchedCallback)(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype of a <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> subscription_match function. </p>

</div>
</div>
<a class="anchor" id="ga07f2384e3cc57a3f53dffb2b48efbab1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* DDS_DataReaderListener_SampleLostCallback)(void *listener_data, <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *reader, const struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype of a <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> subscription_lost function. </p>

</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gad50b30818f1c22476283f3dd114a1834"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DDSReaderModule.html#gad50b30818f1c22476283f3dd114a1834">DDS_SampleLostStatusKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Kinds of reasons why a sample was lost. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggad50b30818f1c22476283f3dd114a1834a88a29dec42ddfe8b5346325eac2432e4"></a>DDS_NOT_LOST</em>&nbsp;</td><td>
<p>The sample was not lost. </p>
<p>This constant is an extension to the DDS standard. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__ResourceLimitsQosPolicy.html" title="Controls the amount of physical memory allocated for DDS entities, if dynamic allocations are allowed...">DDS_ResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad50b30818f1c22476283f3dd114a1834a2764ab3932dd5f738b64d6b79208dd15"></a>DDS_LOST_BY_WRITER</em>&nbsp;</td><td>
<p>A <a class="el" href="group__DDSWriterModule.html#gafb74fa54675abe1bfb2090265bf4d116" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS_To...">DDS_DataWriter</a> removed the sample before being received by the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>This constant is an extension to the DDS standard. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad50b30818f1c22476283f3dd114a1834a95ee9a6704748fcce62715ba272f360e"></a>DDS_LOST_BY_INSTANCES_LIMIT</em>&nbsp;</td><td>
<p>A resource limit on the number of instances was reached. </p>
<p>This constant is an extension to the DDS standard. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__ResourceLimitsQosPolicy.html" title="Controls the amount of physical memory allocated for DDS entities, if dynamic allocations are allowed...">DDS_ResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad50b30818f1c22476283f3dd114a1834a301989c14fc416e42d5e1327e4eacdc0"></a>DDS_LOST_BY_REMOTE_WRITERS_PER_INSTANCE_LIMIT</em>&nbsp;</td><td>
<p>A resource limit on the number of remote writers for a single instance from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read was reached. </p>
<p>This constant is an extension to the DDS standard. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad50b30818f1c22476283f3dd114a1834aaa89fc62dc45b57fef0794a9140b5034"></a>DDS_LOST_BY_INCOMPLETE_COHERENT_SET</em>&nbsp;</td><td>
<p>A sample is lost because it is part of an incomplete coherent set. </p>
<p>This constant is an extension to the DDS standard. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad50b30818f1c22476283f3dd114a1834a55aefe07aa3d87f04d25f13e35d6389f"></a>DDS_LOST_BY_LARGE_COHERENT_SET</em>&nbsp;</td><td>
<p>A sample is lost because it is part of a large coherent set. </p>
<p>This constant is an extension to the DDS standard. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad50b30818f1c22476283f3dd114a1834a14822d440742f69e4b386006bf97717f"></a>DDS_LOST_BY_SAMPLES_PER_REMOTE_WRITER_LIMIT</em>&nbsp;</td><td>
<p>A resource limit on the number of samples from a given remote writer that a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may store was reached. </p>
<p>This constant is an extension to the DDS standard. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad50b30818f1c22476283f3dd114a1834a7c2e169e733580e9b0952677ec5ed804"></a>DDS_LOST_BY_VIRTUAL_WRITERS_LIMIT</em>&nbsp;</td><td>
<p>A resource limit on the number of virtual writers from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read was reached. </p>
<p>This constant is an extension to the DDS standard. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad50b30818f1c22476283f3dd114a1834a9d1aeffb37364cf20ffcae72f9a28dd6"></a>DDS_LOST_BY_REMOTE_WRITERS_PER_SAMPLE_LIMIT</em>&nbsp;</td><td>
<p>A resource limit on the number of remote writers per sample was reached. </p>
<p>This constant is an extension to the DDS standard. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad50b30818f1c22476283f3dd114a1834aa44d2f74c38e1e9b5636609bc7c7944f"></a>DDS_LOST_BY_AVAILABILITY_WAITING_TIME</em>&nbsp;</td><td>
<p><a class="el" href="structDDS__AvailabilityQosPolicy.html#a58852863451f739852b39a13c6b8dcb6" title="Defines how much time to wait before delivering a sample to the application without having received s...">DDS_AvailabilityQosPolicy::max_data_availability_waiting_time</a> expired. </p>
<p>This constant is an extension to the DDS standard. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad50b30818f1c22476283f3dd114a1834a7bfdbf1173b8b6b67aa2f2d51fed6091"></a>DDS_LOST_BY_REMOTE_WRITER_SAMPLES_PER_VIRTUAL_QUEUE_LIMIT</em>&nbsp;</td><td>
<p>A resource limit on the number of samples published by a remote writer on behalf of a virtual writer that a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may store was reached. </p>
<p>This constant is an extension to the DDS standard. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad50b30818f1c22476283f3dd114a1834a0c3528b082cd0e44375323ae11500abe"></a>DDS_LOST_BY_OUT_OF_MEMORY</em>&nbsp;</td><td>
<p>A sample was lost because there was not enough memory to store the sample. </p>
<p>This constant is an extension to the DDS standard. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga08df559babd09ceefcd351b2cb6876f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DDSReaderModule.html#ga08df559babd09ceefcd351b2cb6876f1">DDS_SampleRejectedStatusKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Kinds of reasons for rejecting a sample. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga08df559babd09ceefcd351b2cb6876f1ae371624e8cee89be655a853a3107fb35"></a>DDS_NOT_REJECTED</em>&nbsp;</td><td>
<p>Samples are never rejected. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga08df559babd09ceefcd351b2cb6876f1a0dab8798e087551400c60a82a42ce02a"></a>DDS_REJECTED_BY_INSTANCES_LIMIT</em>&nbsp;</td><td>
<p>A resource limit on the number of instances was reached. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga08df559babd09ceefcd351b2cb6876f1ad17f50fcc59ea3b9decd493227f6d1ca"></a>DDS_REJECTED_BY_SAMPLES_LIMIT</em>&nbsp;</td><td>
<p>A resource limit on the number of samples was reached. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga08df559babd09ceefcd351b2cb6876f1aab6c983268ca4dd0520e6705156197b7"></a>DDS_REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT</em>&nbsp;</td><td>
<p>A resource limit on the number of samples per instance was reached. </p>
<dl class="section see"><dt>See Also</dt><dd>ResourceLimitsQosPolicy </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga08df559babd09ceefcd351b2cb6876f1ac318063c4701ef9d3f77becafd075c6f"></a>DDS_REJECTED_BY_REMOTE_WRITERS_LIMIT</em>&nbsp;</td><td>
<p>A resource limit on the number of remote writers from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read was reached. </p>
<p>This constant is an extension to the DDS standard. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga08df559babd09ceefcd351b2cb6876f1a3da6690a19e97fa66a68e5c2edb4c85e"></a>DDS_REJECTED_BY_REMOTE_WRITERS_PER_INSTANCE_LIMIT</em>&nbsp;</td><td>
<p>A resource limit on the number of remote writers for a single instance from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read was reached. </p>
<p>This constant is an extension to the DDS standard. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga08df559babd09ceefcd351b2cb6876f1a98f2efea03af4d0aecfa356b01e91789"></a>DDS_REJECTED_BY_SAMPLES_PER_REMOTE_WRITER_LIMIT</em>&nbsp;</td><td>
<p>A resource limit on the number of samples from a given remote writer that a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may store was reached. </p>
<p>This constant is an extension to the DDS standard. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga08df559babd09ceefcd351b2cb6876f1a01aac2f41faf7a44e24e0d6354f8bd68"></a>DDS_REJECTED_BY_VIRTUAL_WRITERS_LIMIT</em>&nbsp;</td><td>
<p>A resource limit on the number of virtual writers from which a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may read was reached. </p>
<p>This constant is an extension to the DDS standard. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga08df559babd09ceefcd351b2cb6876f1a285dc1adf73ff5a401d66a684ded45f2"></a>DDS_REJECTED_BY_REMOTE_WRITERS_PER_SAMPLE_LIMIT</em>&nbsp;</td><td>
<p>A resource limit on the number of remote writers per sample was reached. </p>
<p>This constant is an extension to the DDS standard. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga08df559babd09ceefcd351b2cb6876f1a6f37ba9431ba961c48483d935d9e77c4"></a>DDS_REJECTED_BY_REMOTE_WRITER_SAMPLES_PER_VIRTUAL_QUEUE_LIMIT</em>&nbsp;</td><td>
<p>A resource limit on the number of samples published by a remote writer on behalf of a virtual writer that a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> may store was reached. </p>
<p>This constant is an extension to the DDS standard. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> </dd></dl>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="ga0436d021ed263221d64cc4d072cf3b70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFooDataReader.html">FooDataReader</a>* FooDataReader_narrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Narrow the given <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> pointer to a <a class="el" href="structFooDataReader.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; User data type-specific data reader.">FooDataReader</a> pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1e8fa1f655eb6653b53a48e743aa6a86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a>* FooDataReader_as_datareader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Widen the given <a class="el" href="structFooDataReader.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; User data type-specific data reader.">FooDataReader</a> pointer to a <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga84f8ad6ee21fb024234034bbcce6d812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&#160;</td>
          <td class="paramname"><em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a>&#160;</td>
          <td class="paramname"><em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a>&#160;</td>
          <td class="paramname"><em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a>&#160;</td>
          <td class="paramname"><em>instance_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>This operation offers the same functionality and API as <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> except that the samples returned remain in the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> such that they can be retrieved again by means of a read or take operation. </p>
<p>Please refer to the documentation of <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take()</a> for details on the number of samples returned within the received_data and info_seq as well as the order in which the samples appear in these sequences. </p>
<p>The act of reading a sample changes its <code>sample_state</code> to <a class="el" href="group__DDSSampleStateModule.html#ggadb6d36e7c796da27519b6bf7f8f187e5a4435d5fd0a36806ebd1c67210345a70b" title="Sample has been read.">DDS_READ_SAMPLE_STATE</a>. If the sample belongs to the most recent generation of the instance, it will also set the <code>view_state</code> of the instance to be <a class="el" href="group__DDSViewStateModule.html#ggab7a8a4ae44a2c00f411a4461135b45f1ad0a3502068e5e66e20a873a0aaa881be" title="Not a new instance. This latest generation of the instance has previously been accessed.">DDS_NOT_NEW_VIEW_STATE</a>. It will not affect the <code>instance_state</code> of the instance. </p>
<p>Once the application completes its use of the samples, it must 'return the loan' to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> by calling the <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a> operation. </p>
<p><em><b>Important</b></em>: When you loan data from the middleware, you <em>must not</em> keep any pointers to any part of the data samples or the <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> objects after the call to <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>. Returning the loan places the objects back into a pool, allowing the middleware to overwrite them with new data. </p>
<p><em>Note:</em> While you must call <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a> at some point, you do <em>not</em> have to do so before the next <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> call. However, failure to return the loan will eventually deplete the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> of the buffers it needs to receive new samples and eventually samples will start to be lost. The total number of buffers available to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> is specified by the <a class="el" href="structDDS__ResourceLimitsQosPolicy.html" title="Controls the amount of physical memory allocated for DDS entities, if dynamic allocations are allowed...">DDS_ResourceLimitsQosPolicy</a> and the <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a>. </p>
<p><em>Important:</em> If the samples "returned" by this function are loaned from RTI Connext (see <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> for more information on memory loaning), it is important that their contents not be changed. Because the memory in which the data is stored belongs to the middleware, any modifications made to the data will be seen the next time the same samples are read or taken; the samples will no longer reflect the state that was received from the network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">received_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> User data type-specific <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">info_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> A <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">max_samples</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available, up to the limits described in the documentation for <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take()</a>. </td></tr>
    <tr><td class="paramname">sample_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Data samples matching one of these <code>sample_states</code> are returned. See the valid values for this parameter here: <a class="el" href="group__DDSSampleStateModule.html#gadb6d36e7c796da27519b6bf7f8f187e5" title="Indicates whether or not a sample has ever been read.">DDS_SampleStateKind</a>. </td></tr>
    <tr><td class="paramname">view_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Data samples matching one of these <code>view_state</code> are returned. See the valid values for this parameter here: <a class="el" href="group__DDSViewStateModule.html#gab7a8a4ae44a2c00f411a4461135b45f1" title="Indicates whether or not an instance is new.">DDS_ViewStateKind</a>. </td></tr>
    <tr><td class="paramname">instance_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Data samples matching ones of these <code>instance_state</code> are returned. See the valid values for this parameter here: <a class="el" href="group__DDSInstanceStateModule.html#gaf2264cae1aa8cd66490debfdc5e0c360" title="Indicates if the samples are from a live DDS_DataWriter or not.">DDS_InstanceStateKind</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gab3aa397b246f0c8e5b62940597dfa280" title="Accesses via FooDataReader_read the samples that match the criteria specified in the DDS_ReadConditio...">FooDataReader_read_w_condition</a>, </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#ga5340c4c0e6b32c31d36688636c064657" title="Analogous to FooDataReader_read_w_condition except it accesses samples via the FooDataReader_take ope...">FooDataReader_take_w_condition</a> </dd>
<dd>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafa56233023b6c95f89a9df48d16a4659"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_take </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&#160;</td>
          <td class="paramname"><em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a>&#160;</td>
          <td class="paramname"><em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a>&#160;</td>
          <td class="paramname"><em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a>&#160;</td>
          <td class="paramname"><em>instance_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a collection of data-samples from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>The operation will return the list of samples received by the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> since the last <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> operation that matches the specified <a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5" title="A bit-mask (list) of sample states, i.e. DDS_SampleStateKind.">DDS_SampleStateMask</a>, <a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c" title="A bit-mask (list) of view states, i.e. DDS_ViewStateKind.">DDS_ViewStateMask</a> and <a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f" title="A bit-mask (list) of instance states, i.e. DDS_InstanceStateKind.">DDS_InstanceStateMask</a>. </p>
<p>This operation may fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ac47a8e813f6e5d652f67dbc551b9f62e" title="Generic, unspecified error.">DDS_RETCODE_ERROR</a> if the <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a82873fd35e4159bce6c23cc0de5fcca9" title="The maximum number of outstanding read/take calls (or one of their variants) on the same DDS_DataRead...">DDS_DataReaderResourceLimitsQosPolicy::max_outstanding_reads</a> limit has been exceeded. </p>
<p>The actual number of samples returned depends on the information that has been received by the middleware as well as the <a class="el" href="structDDS__HistoryQosPolicy.html" title="Specifies the behavior of RTI Connext in the case where the value of a sample changes (one or more ti...">DDS_HistoryQosPolicy</a>, <a class="el" href="structDDS__ResourceLimitsQosPolicy.html" title="Controls the amount of physical memory allocated for DDS entities, if dynamic allocations are allowed...">DDS_ResourceLimitsQosPolicy</a>, <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a> and the characteristics of the data-type that is associated with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>: </p>
<ul>
<li>In the case where the <a class="el" href="structDDS__HistoryQosPolicy.html#a3cb2743cd13a81614bcc4f314cd640ab" title="Specifies the kind of history to be kept.">DDS_HistoryQosPolicy::kind</a> is <a class="el" href="group__DDSHistoryQosModule.html#gga96c54dadb2beb87b23776e766e282185a993d3120b7bbb347ce11e0e6f68b29ff" title="[default] Keep the last depth samples.">DDS_KEEP_LAST_HISTORY_QOS</a>, the call will return at most <a class="el" href="structDDS__HistoryQosPolicy.html#aef0fb3fd3579866be17d1a936f5e3729" title="Specifies the number of samples to be kept, when the kind is DDS_KEEP_LAST_HISTORY_QOS.">DDS_HistoryQosPolicy::depth</a> samples per instance. </li>
</ul>
<ul>
<li>The maximum number of samples returned is limited by <a class="el" href="structDDS__ResourceLimitsQosPolicy.html#a90db906a3958146c5e22557db648e7ff" title="Represents the maximum samples the middleware can store for any one DDS_DataWriter (or DDS_DataReader...">DDS_ResourceLimitsQosPolicy::max_samples</a>, and by <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a3672d889d158f8da9c2465e5ec3046c5" title="The maximum number of data samples that the application can receive from the middleware in a single c...">DDS_DataReaderResourceLimitsQosPolicy::max_samples_per_read</a>. </li>
</ul>
<ul>
<li>For multiple instances, the number of samples returned is additionally limited by the product (<a class="el" href="structDDS__ResourceLimitsQosPolicy.html#ae3d9339bebf4c7163cf6dff82882cbef" title="Represents the maximum number of samples of any one instance a DDS_DataWriter (or DDS_DataReader) can...">DDS_ResourceLimitsQosPolicy::max_samples_per_instance</a> * <a class="el" href="structDDS__ResourceLimitsQosPolicy.html#ab7339605f314f50c7cb658426ff64cdb" title="Represents the maximum number of instances a DDS_DataWriter (or DDS_DataReader) can manage...">DDS_ResourceLimitsQosPolicy::max_instances</a>) </li>
</ul>
<ul>
<li>If <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a6f871521d0791014ee54ec70ee57cbc0" title="The maximum number of info units that a DDS_DataReader can use to store DDS_SampleInfo.">DDS_DataReaderResourceLimitsQosPolicy::max_infos</a> is limited, the number of samples returned may also be limited if insufficient <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> resources are available. </li>
</ul>
<p>If the read or take succeeds and the number of samples returned has been limited (by means of a maximum limit, as listed above, or insufficient <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> resources), the call will complete successfully and provide those samples the reader is able to return. The user may need to make additional calls, or return outstanding loaned buffers in the case of insufficient resources, in order to access remaining samples. </p>
<p>Note that in the case where the <a class="el" href="group__DDSTopicEntityModule.html#ga7f615cc63381c78f535904e370cf1356" title="&lt;&lt;interface&gt;&gt; The most basic description of the data to be published and subscribed.">DDS_Topic</a> associated with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> is bound to a data-type that has no key definition, then there will be at most one instance in the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. So the per-sample limits will apply. </p>
<p>The act of <em>taking</em> a sample removes it from RTI Connext so it cannot be read or taken again. If the sample belongs to the most recent generation of the instance, it will also set the <code>view_state</code> of the sample's instance to <a class="el" href="group__DDSViewStateModule.html#ggab7a8a4ae44a2c00f411a4461135b45f1ad0a3502068e5e66e20a873a0aaa881be" title="Not a new instance. This latest generation of the instance has previously been accessed.">DDS_NOT_NEW_VIEW_STATE</a>. It will not affect the <code>instance_state</code> of the sample's instance. </p>
<p>After <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> completes, <code>received_data</code> and <code>info_seq</code> will be of the same length and contain the received data. </p>
<p>If the sequences are empty (maximum size equals 0) when the <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> is called, the samples returned in the <code>received_data</code> and the corresponding <code>info_seq</code> are 'loaned' to the application from buffers provided by the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. The application can use them as desired and has guaranteed exclusive access to them. </p>
<p>Once the application completes its use of the samples it must 'return the loan' to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> by calling the <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a> operation. </p>
<p><em><b>Important</b></em>: When you loan data from the middleware, you <em>must not</em> keep any pointers to any part of the data samples or the <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> objects after the call to <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>. Returning the loan places the objects back into a pool, allowing the middleware to overwrite them with new data. </p>
<p><em>Note:</em> While you must call <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a> at some point, you do <em>not</em> have to do so before the next <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> call. However, failure to return the loan will eventually deplete the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> of the buffers it needs to receive new samples and eventually samples will start to be lost. The total number of buffers available to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> is specified by the <a class="el" href="structDDS__ResourceLimitsQosPolicy.html" title="Controls the amount of physical memory allocated for DDS entities, if dynamic allocations are allowed...">DDS_ResourceLimitsQosPolicy</a> and the <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DataReader allocates and uses physical memory for internal ...">DDS_DataReaderResourceLimitsQosPolicy</a>. </p>
<p>If the sequences are not empty (maximum size not equal to 0 and length not equal to 0) when <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> is called, samples are copied to received_data and info_seq. The application will not need to call <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>. </p>
<p>The order of the samples returned to the caller depends on the <a class="el" href="structDDS__PresentationQosPolicy.html" title="Specifies how the samples representing changes to data instances are presented to a subscribing appli...">DDS_PresentationQosPolicy</a>. </p>
<ul>
<li>If <a class="el" href="structDDS__PresentationQosPolicy.html#a0d46a4e9fe04a65507153013ab542e64" title="Determines the largest scope spanning the entities for which the order and coherency of changes can b...">DDS_PresentationQosPolicy::access_scope</a> is <a class="el" href="group__DDSPresentationQosModule.html#gga123d979f855f637f32eb525b778175b2ab7e8c01f13b9c46013094fdee7d6af36" title="[default] Scope spans only a single instance.">DDS_INSTANCE_PRESENTATION_QOS</a>, the returned collection is a list where samples belonging to the same data instance are consecutive. </li>
</ul>
<ul>
<li>If <a class="el" href="structDDS__PresentationQosPolicy.html#a0d46a4e9fe04a65507153013ab542e64" title="Determines the largest scope spanning the entities for which the order and coherency of changes can b...">DDS_PresentationQosPolicy::access_scope</a> is <a class="el" href="group__DDSPresentationQosModule.html#gga123d979f855f637f32eb525b778175b2a6d21a371adc6e10a62c2739171f5c22f" title="Scope spans to all instances within the same DDS_DataWriter (or DDS_DataReader), but not across insta...">DDS_TOPIC_PRESENTATION_QOS</a> and <a class="el" href="structDDS__PresentationQosPolicy.html#a7a534396ec3b27a902ef4b6fe95ae454" title="Specifies support for ordered access to the samples received at the subscription end. Controls whether ordered access is supported within the scope access_scope.">DDS_PresentationQosPolicy::ordered_access</a> is set to <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a>, then returned collection is a list where samples belonging to the same data instance are consecutive. </li>
</ul>
<ul>
<li>If <a class="el" href="structDDS__PresentationQosPolicy.html#a0d46a4e9fe04a65507153013ab542e64" title="Determines the largest scope spanning the entities for which the order and coherency of changes can b...">DDS_PresentationQosPolicy::access_scope</a> is <a class="el" href="group__DDSPresentationQosModule.html#gga123d979f855f637f32eb525b778175b2a6d21a371adc6e10a62c2739171f5c22f" title="Scope spans to all instances within the same DDS_DataWriter (or DDS_DataReader), but not across insta...">DDS_TOPIC_PRESENTATION_QOS</a> and <a class="el" href="structDDS__PresentationQosPolicy.html#a7a534396ec3b27a902ef4b6fe95ae454" title="Specifies support for ordered access to the samples received at the subscription end. Controls whether ordered access is supported within the scope access_scope.">DDS_PresentationQosPolicy::ordered_access</a> is set to <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a>, then the returned collection is a list were the relative order of samples is preserved also accross different instances. Note that samples belonging to the same instance may or may not be consecutive. This is because to preserve order it may be necessary to mix samples from different instances. </li>
</ul>
<ul>
<li>If <a class="el" href="structDDS__PresentationQosPolicy.html#a0d46a4e9fe04a65507153013ab542e64" title="Determines the largest scope spanning the entities for which the order and coherency of changes can b...">DDS_PresentationQosPolicy::access_scope</a> is <a class="el" href="group__DDSPresentationQosModule.html#gga123d979f855f637f32eb525b778175b2ae0591a04e045da1d86f25fa8bec39937" title="Scope spans to all instances belonging to DDS_DataWriter (or DDS_DataReader) entities within the same...">DDS_GROUP_PRESENTATION_QOS</a> and <a class="el" href="structDDS__PresentationQosPolicy.html#a7a534396ec3b27a902ef4b6fe95ae454" title="Specifies support for ordered access to the samples received at the subscription end. Controls whether ordered access is supported within the scope access_scope.">DDS_PresentationQosPolicy::ordered_access</a> is set to <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a>, then returned collection is a list where samples belonging to the same data instance are consecutive. [<b>Not supported (optional)</b>] </li>
</ul>
<ul>
<li>If <a class="el" href="structDDS__PresentationQosPolicy.html#a0d46a4e9fe04a65507153013ab542e64" title="Determines the largest scope spanning the entities for which the order and coherency of changes can b...">DDS_PresentationQosPolicy::access_scope</a> is <a class="el" href="group__DDSPresentationQosModule.html#gga123d979f855f637f32eb525b778175b2ae0591a04e045da1d86f25fa8bec39937" title="Scope spans to all instances belonging to DDS_DataWriter (or DDS_DataReader) entities within the same...">DDS_GROUP_PRESENTATION_QOS</a> and <a class="el" href="structDDS__PresentationQosPolicy.html#a7a534396ec3b27a902ef4b6fe95ae454" title="Specifies support for ordered access to the samples received at the subscription end. Controls whether ordered access is supported within the scope access_scope.">DDS_PresentationQosPolicy::ordered_access</a> is set to <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a>, then the returned collection contains at most one sample. The difference in this case is due to the fact that is required that the application is able to read samples belonging to different <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> objects in a specific order. [<b>Not supported (optional)</b>] </li>
</ul>
<p>In any case, the relative order between the samples of one instance is consistent with the <a class="el" href="group__DDSDestinationOrderQosModule.html">DESTINATION_ORDER</a> policy: </p>
<ul>
<li>If <a class="el" href="structDDS__DestinationOrderQosPolicy.html#a6b16d4602f9b8dde684f8dd737958bd1" title="Specifies the desired kind of destination order.">DDS_DestinationOrderQosPolicy::kind</a> is <a class="el" href="group__DDSDestinationOrderQosModule.html#gga8f1c0c2b179c6281aa9e92d5ea88cbfeaa718dc1f974fc792af552d293986bb26" title="[default] Indicates that data is ordered based on the reception time at each DDS_Subscriber.">DDS_BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</a>, samples belonging to the same instances will appear in the relative order in which there were received (FIFO, earlier samples ahead of the later samples). </li>
</ul>
<ul>
<li>If <a class="el" href="structDDS__DestinationOrderQosPolicy.html#a6b16d4602f9b8dde684f8dd737958bd1" title="Specifies the desired kind of destination order.">DDS_DestinationOrderQosPolicy::kind</a> is <a class="el" href="group__DDSDestinationOrderQosModule.html#gga8f1c0c2b179c6281aa9e92d5ea88cbfeac7a65745504a7d4ccbc41299154fe67b" title="Indicates that data is ordered based on a time-stamp placed at the source (by RTI Connext or by the a...">DDS_BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS</a>, samples belonging to the same instances will appear in the relative order implied by the <code>source_timestamp</code> (FIFO, smaller values of <code>source_timestamp</code> ahead of the larger values). </li>
</ul>
<p>If the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> has no samples that meet the constraints, the function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a>. </p>
<p>In addition to the collection of samples, the read and take operations also use a collection of <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> structures. </p>
<h1><a class="anchor" id="Data_and_sampleinfo_sequence"></a>
SEQUENCES USAGE IN TAKE AND READ</h1>
<p>The initial (input) properties of the <code>received_data</code> and <code>info_seq</code> collections will determine the precise behavior of the read or take operation. For the purposes of this description, the collections are modeled as having these properties: </p>
<ul>
<li>whether the collection container owns the memory of the elements within (<code>owns</code>, see <a class="el" href="group__DDSSequenceModule.html#gaca64a79c4b5c96bb230cf3d5075f35aa" title="Return the value of the owned flag.">FooSeq_has_ownership</a>) </li>
<li>the current-length (<code>len</code>, see <a class="el" href="group__DDSSequenceModule.html#gaf7a45e00319eeb1ddf5c84ac68657adb" title="Get the logical length of this sequence.">FooSeq_get_length</a>) </li>
<li>the maximum length (<code>max_len</code>, see <a class="el" href="group__DDSSequenceModule.html#gab3765cd5c745da088f3772a1a8578cef" title="Get the current maximum number of elements that can be stored in this sequence.">FooSeq_get_maximum</a>) </li>
</ul>
<p>The initial values of the <code>owns</code>, <code>len</code> and <code>max_len</code> properties for the <code>received_data</code> and <code>info_seq</code> collections govern the behavior of the read and take operations as specified by the following rules: </p>
<ol>
<li>
<p class="startli">The values of <code>owns</code>, <code>len</code> and <code>max_len</code> properties for the two collections must be identical. Otherwise read/take will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">On successful output, the values of <code>owns</code>, <code>len</code> and <code>max_len</code> will be the same for both collections. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If the initial <code>max_len==0</code>, then the <code>received_data</code> and <code>info_seq</code> collections will be filled with elements that are loaned by the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. On output, <code>owns</code> will be FALSE, <code>len</code> will be set to the number of values returned, and <code>max_len</code> will be set to a value verifying <code>max_len</code> &gt;= <code>len</code>. The use of this variant allows for zero-copy access to the data and the application will need to return the loan to the <a class="el" href="group__DDSWriterModule.html#gafb74fa54675abe1bfb2090265bf4d116" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS_To...">DDS_DataWriter</a> using <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If the initial <code>max_len&gt;0</code> and <code>owns==FALSE</code>, then the read or take operation will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>. This avoids the potential hard-to-detect memory leaks caused by an application forgetting to return the loan. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If initial <code>max_len&gt;0</code> and <code>owns==TRUE</code>, then the read or take operation will copy the <code>received_data</code> values and <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> values into the elements already inside the collections. On output, <code>owns</code> will be TRUE, <code>len</code> will be set to the number of values copied and <code>max_len</code> will remain unchanged. The use of this variant forces a copy but the application can control where the copy is placed and the application will not need to return the loan. The number of samples copied depends on the relative values of <code>max_len</code> and <code>max_samples:</code> </p>
<ul>
<li>
<p class="startli">If <code>max_samples</code> == LENGTH_UNLIMITED, then at most <code>max_len</code> values will be copied. The use of this variant lets the application limit the number of samples returned to what the sequence can accommodate. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If <code>max_samples</code> &lt;= <code>max_len</code>, then at most <code>max_samples</code> values will be copied. The use of this variant lets the application limit the number of samples returned to fewer that what the sequence can accommodate.  </p>
<p class="endli"></p>
</li>
<li>
If <code>max_samples</code> &gt; <code>max_len</code>, then the read or take operation will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>. This avoids the potential confusion where the application expects to be able to access up to <code>max_samples</code>, but that number can never be returned, even if they are available in the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>, because the output sequence cannot accommodate them. </li>
</ul>
</li>
</ol>
<p>As described above, upon completion, the <code>received_data</code> and <code>info_seq</code> collections may contain elements loaned from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. If this is the case, the application will need to use <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a> to return the loan once it is no longer using the <code>received_data</code> in the collection. When <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a> completes, the collection will have <code>owns=FALSE</code> and <code>max_len=0</code>. The application can determine whether it is necessary to return the loan or not based on how the state of the collections when the read/take operation was called or by accessing the <code>owns</code> property. However, in many cases it may be simpler to always call <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>, as this operation is harmless (i.e., it leaves all elements unchanged) if the collection does not have a loan. To avoid potential memory leaks, the implementation of the <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> and <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> collections should disallow changing the length of a collection for which <code>owns==FALSE</code>. Furthermore, deleting a collection for which <code>owns==FALSE</code> should be considered an error. </p>
<p>On output, the collection of <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> values and the collection of <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> structures are of the same length and are in a one-to-one correspondence. Each <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> provides information, such as the source_timestamp, the sample_state, view_state, and instance_state, etc., about the corresponding sample. Some elements in the returned collection may not have valid data. If the instance_state in the <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> is <a class="el" href="group__DDSInstanceStateModule.html#ggaf2264cae1aa8cd66490debfdc5e0c360a51e7b0651e135e656327002e41787dbf" title="Not alive disposed instance. The instance has been disposed by a DataWriter.">DDS_NOT_ALIVE_DISPOSED_INSTANCE_STATE</a> or <a class="el" href="group__DDSInstanceStateModule.html#ggaf2264cae1aa8cd66490debfdc5e0c360a72ebdc6f53c9a7588458b48e3ea66507" title="Not alive no writers for instance. None of the DDS_DataWriter objects that are currently alive (accor...">DDS_NOT_ALIVE_NO_WRITERS_INSTANCE_STATE</a>, then the last sample for that instance in the collection (that is, the one whose <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> has sample_rank==0) does not contain valid data. </p>
<p>Samples that contain no data do not count towards the limits imposed by the <a class="el" href="structDDS__ResourceLimitsQosPolicy.html" title="Controls the amount of physical memory allocated for DDS entities, if dynamic allocations are allowed...">DDS_ResourceLimitsQosPolicy</a>. The act of reading/taking a sample sets its sample_state to <a class="el" href="group__DDSSampleStateModule.html#ggadb6d36e7c796da27519b6bf7f8f187e5a4435d5fd0a36806ebd1c67210345a70b" title="Sample has been read.">DDS_READ_SAMPLE_STATE</a>. </p>
<p>If the sample belongs to the most recent generation of the instance, it will also set the view_state of the instance to <a class="el" href="group__DDSViewStateModule.html#ggab7a8a4ae44a2c00f411a4461135b45f1ad0a3502068e5e66e20a873a0aaa881be" title="Not a new instance. This latest generation of the instance has previously been accessed.">DDS_NOT_NEW_VIEW_STATE</a>. It will not affect the instance_state of the instance. </p>
<p>This operation must be provided on the specialized class that is generated for the particular application data-type that is being read (<a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a>). </p>
<p>If the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> has no samples that meet the constraints, the operations fails with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a>. For an example on how <code>take</code> can be used, please refer to the <a class="el" href="group__DDSReaderExampleModule.html#DDSReaderExampleModule_receive">receive example</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">received_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> User data type-specific <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">info_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> A <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">max_samples</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available, up to the limits described above. </td></tr>
    <tr><td class="paramname">sample_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Data samples matching one of these <code>sample_states</code> are returned. See the valid values for this parameter here: <a class="el" href="group__DDSSampleStateModule.html#gadb6d36e7c796da27519b6bf7f8f187e5" title="Indicates whether or not a sample has ever been read.">DDS_SampleStateKind</a>. </td></tr>
    <tr><td class="paramname">view_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Data samples matching one of these <code>view_state</code> are returned. See the valid values for this parameter here: <a class="el" href="group__DDSViewStateModule.html#gab7a8a4ae44a2c00f411a4461135b45f1" title="Indicates whether or not an instance is new.">DDS_ViewStateKind</a>. </td></tr>
    <tr><td class="paramname">instance_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Data samples matching one of these <code>instance_state</code> are returned. See the valid values for this parameter here: <a class="el" href="group__DDSInstanceStateModule.html#gaf2264cae1aa8cd66490debfdc5e0c360" title="Indicates if the samples are from a live DDS_DataWriter or not.">DDS_InstanceStateKind</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gab3aa397b246f0c8e5b62940597dfa280" title="Accesses via FooDataReader_read the samples that match the criteria specified in the DDS_ReadConditio...">FooDataReader_read_w_condition</a>, <a class="el" href="group__DDSReaderModule.html#ga5340c4c0e6b32c31d36688636c064657" title="Analogous to FooDataReader_read_w_condition except it accesses samples via the FooDataReader_take ope...">FooDataReader_take_w_condition</a> </dd>
<dd>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab3aa397b246f0c8e5b62940597dfa280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_read_w_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&#160;</td>
          <td class="paramname"><em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a> *&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses via <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a>. </p>
<p>This operation is especially useful in combination with <a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843" title="&lt;&lt;interface&gt;&gt; These are specialised DDS_ReadCondition objects that allow the application to also spec...">DDS_QueryCondition</a> to filter data samples based on the content. </p>
<p>The specified <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> must be attached to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>; otherwise the operation will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>. </p>
<p>In case the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> is a plain <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> and not the specialized <a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843" title="&lt;&lt;interface&gt;&gt; These are specialised DDS_ReadCondition objects that allow the application to also spec...">DDS_QueryCondition</a>, the operation is equivalent to calling <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> and passing as <code>sample_states</code>, <code>view_states</code> and <code>instance_states</code> the value of the corresponding attributes in the <code>read_condition</code>. Using this operation, the application can avoid repeating the same parameters specified when creating the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a>. </p>
<p>The samples are accessed with the same semantics as <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>. </p>
<p>If the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> has no samples that meet the constraints, the operation will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">received_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">info_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">max_samples</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available, up to the limits described in the documentation for <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take()</a>. </td></tr>
    <tr><td class="paramname">condition</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> to select samples of interest. Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a>, <a class="el" href="group__DDSReaderModule.html#ga5340c4c0e6b32c31d36688636c064657" title="Analogous to FooDataReader_read_w_condition except it accesses samples via the FooDataReader_take ope...">FooDataReader_take_w_condition</a> </dd>
<dd>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5340c4c0e6b32c31d36688636c064657"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_take_w_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&#160;</td>
          <td class="paramname"><em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a> *&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analogous to <a class="el" href="group__DDSReaderModule.html#gab3aa397b246f0c8e5b62940597dfa280" title="Accesses via FooDataReader_read the samples that match the criteria specified in the DDS_ReadConditio...">FooDataReader_read_w_condition</a> except it accesses samples via the <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> operation. </p>
<p>This operation is analogous to <a class="el" href="group__DDSReaderModule.html#gab3aa397b246f0c8e5b62940597dfa280" title="Accesses via FooDataReader_read the samples that match the criteria specified in the DDS_ReadConditio...">FooDataReader_read_w_condition</a> except that it accesses samples via the <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> operation. </p>
<p>The specified <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> must be attached to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>; otherwise the operation will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>. </p>
<p>The samples are accessed with the same semantics as <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a>. </p>
<p>This operation is especially useful in combination with <a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843" title="&lt;&lt;interface&gt;&gt; These are specialised DDS_ReadCondition objects that allow the application to also spec...">DDS_QueryCondition</a> to filter data samples based on the content. </p>
<p>If the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> has no samples that meet the constraints, the function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">received_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">info_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">max_samples</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available, up to the limits described in the documentation for <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take()</a>. </td></tr>
    <tr><td class="paramname">condition</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> to select samples of interest. Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#gab3aa397b246f0c8e5b62940597dfa280" title="Accesses via FooDataReader_read the samples that match the criteria specified in the DDS_ReadConditio...">FooDataReader_read_w_condition</a>, <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> </dd>
<dd>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacf50e7b4ea6b82cf688bd96df1dd5ab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_read_next_sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structFoo.html">Foo</a> *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> *&#160;</td>
          <td class="paramname"><em>sample_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the next not-previously-accessed data value from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>This operation copies the next not-previously-accessed data value from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. This operation also copies the corresponding <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a>. The implied order among the samples stored in the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> is the same as for the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> operation. </p>
<p>The <a class="el" href="group__DDSReaderModule.html#gacf50e7b4ea6b82cf688bd96df1dd5ab4" title="Copies the next not-previously-accessed data value from the DDS_DataReader.">FooDataReader_read_next_sample</a> operation is semantically equivalent to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> operation, where the input data sequences has max_len=1, the sample_states=NOT_READ, the view_states=ANY_VIEW_STATE, and the instance_states=ANY_INSTANCE_STATE. </p>
<p>The <a class="el" href="group__DDSReaderModule.html#gacf50e7b4ea6b82cf688bd96df1dd5ab4" title="Copies the next not-previously-accessed data value from the DDS_DataReader.">FooDataReader_read_next_sample</a> operation provides a simplified API to 'read' samples, avoiding the need for the application to manage sequences and specify states. </p>
<p>If there is no unread data in the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>, the operation will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a> and nothing is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">received_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> object where the next received data sample will be returned. The received_data must have been fully allocated. Otherwise, this operation may fail. Must be a valid non-NULL <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">sample_info</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> object where the next received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac5f37ece5465c3e64077e8191c328d87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_take_next_sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structFoo.html">Foo</a> *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> *&#160;</td>
          <td class="paramname"><em>sample_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the next not-previously-accessed data value from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>This operation copies the next not-previously-accessed data value from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> and 'removes' it from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> so that it is no longer accessible. This operation also copies the corresponding <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a>. This operation is analogous to the <a class="el" href="group__DDSReaderModule.html#gacf50e7b4ea6b82cf688bd96df1dd5ab4" title="Copies the next not-previously-accessed data value from the DDS_DataReader.">FooDataReader_read_next_sample</a> except for the fact that the sample is removed from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>The <a class="el" href="group__DDSReaderModule.html#gac5f37ece5465c3e64077e8191c328d87" title="Copies the next not-previously-accessed data value from the DDS_DataReader.">FooDataReader_take_next_sample</a> operation is semantically equivalent to the <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> operation, where the input data sequences has max_len=1, the sample_states=NOT_READ, the view_states=ANY_VIEW_STATE, and the instance_states=ANY_INSTANCE_STATE. </p>
<p>The <a class="el" href="group__DDSReaderModule.html#gac5f37ece5465c3e64077e8191c328d87" title="Copies the next not-previously-accessed data value from the DDS_DataReader.">FooDataReader_take_next_sample</a> operation provides a simplified API to 'take' samples, avoiding the need for the application to manage sequences and specify states. </p>
<p>If there is no unread data in the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>, the operation will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a> and nothing is copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">received_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> object where the next received data sample will be returned. The received_data must have been fully allocated. Otherwise, this operation may fail. Must be a valid non-NULL <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">sample_info</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> object where the next received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, </dd></dl>
<p><a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c41d6ff208c71f13ff7593d32c50a56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_read_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&#160;</td>
          <td class="paramname"><em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *&#160;</td>
          <td class="paramname"><em>a_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a>&#160;</td>
          <td class="paramname"><em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a>&#160;</td>
          <td class="paramname"><em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a>&#160;</td>
          <td class="paramname"><em>instance_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>This operation accesses a collection of data values from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. The behavior is identical to <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, except that all samples returned belong to the single specified instance whose handle is <code>a_handle</code>. </p>
<p>Upon successful completion, the data collection will contain samples all belonging to the same instance. The corresponding <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> verifies <a class="el" href="structDDS__SampleInfo.html#a38bca53647cd2be8c1dff9054126f360" title="Identifies locally the corresponding instance.">DDS_SampleInfo::instance_handle</a> == <code>a_handle</code>. </p>
<p>The <a class="el" href="group__DDSReaderModule.html#ga0c41d6ff208c71f13ff7593d32c50a56" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_instance</a> operation is semantically equivalent to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> operation, except in building the collection, the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> will check that the sample belongs to the specified instance and otherwise it will not place the sample in the returned collection. </p>
<p>The behavior of the <a class="el" href="group__DDSReaderModule.html#ga0c41d6ff208c71f13ff7593d32c50a56" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_instance</a> operation follows the same rules as the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> operation regarding the pre-conditions and post-conditions for the <code>received_data</code> and <code>sample_info</code>. Similar to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, the <a class="el" href="group__DDSReaderModule.html#ga0c41d6ff208c71f13ff7593d32c50a56" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_instance</a> operation may 'loan' elements to the output collections, which must then be returned by means of <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>. </p>
<p>Similar to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. </p>
<p>If the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> has no samples that meet the constraints, the function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a>. </p>
<p>This operation may fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if the <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b" title="Type definition for an instance handle.">DDS_InstanceHandle_t</a> <code>a_handle</code> does not correspond to an existing data-object known to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">received_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">info_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">max_samples</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available, up to the limits described in the documentation for <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take()</a>. </td></tr>
    <tr><td class="paramname">a_handle</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The specified instance to return samples for. Must be a valid non-NULL <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b" title="Type definition for an instance handle.">DDS_InstanceHandle_t</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if the <code>handle</code> does not correspond to an existing data-object known to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </td></tr>
    <tr><td class="paramname">sample_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>sample_states</code> are returned. </td></tr>
    <tr><td class="paramname">view_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>view_state</code> are returned. </td></tr>
    <tr><td class="paramname">instance_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>instance_state</code> are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> </dd>
<dd>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaab2b14c7a98d1cabdc446b543161668c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_take_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&#160;</td>
          <td class="paramname"><em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *&#160;</td>
          <td class="paramname"><em>a_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a>&#160;</td>
          <td class="paramname"><em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a>&#160;</td>
          <td class="paramname"><em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a>&#160;</td>
          <td class="paramname"><em>instance_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>This operation accesses a collection of data values from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. The behavior is identical to <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a>, except for that all samples returned belong to the single specified instance whose handle is <code>a_handle</code>. </p>
<p>The semantics are the same for the <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> operation, except in building the collection, the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> will check that the sample belongs to the specified instance, and otherwise it will not place the sample in the returned collection. </p>
<p>The behavior of the <a class="el" href="group__DDSReaderModule.html#gaab2b14c7a98d1cabdc446b543161668c" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_take_instance</a> operation follows the same rules as the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> operation regarding the pre-conditions and post-conditions for the <code>received_data</code> and <code>sample_info</code>. Similar to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, the <a class="el" href="group__DDSReaderModule.html#gaab2b14c7a98d1cabdc446b543161668c" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_take_instance</a> operation may 'loan' elements to the output collections, which must then be returned by means of <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>. </p>
<p>Similar to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. </p>
<p>If the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> has no samples that meet the constraints, the function fails with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a>. </p>
<p>This operation may fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if the <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b" title="Type definition for an instance handle.">DDS_InstanceHandle_t</a> <code>a_handle</code> does not correspond to an existing data-object known to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">received_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">info_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">max_samples</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available, up to the limits described in the documentation for <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take()</a>. </td></tr>
    <tr><td class="paramname">a_handle</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The specified instance to return samples for. Must be a valid non-NULL <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b" title="Type definition for an instance handle.">DDS_InstanceHandle_t</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if the <code>handle</code> does not correspond to an existing data-object known to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </td></tr>
    <tr><td class="paramname">sample_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>sample_states</code> are returned. </td></tr>
    <tr><td class="paramname">view_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>view_state</code> are returned. </td></tr>
    <tr><td class="paramname">instance_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>instance_state</code> are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> </dd>
<dd>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga404ce36a7c67a75702d92a29a44039b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_read_instance_w_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&#160;</td>
          <td class="paramname"><em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *&#160;</td>
          <td class="paramname"><em>a_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a> *&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses via <a class="el" href="group__DDSReaderModule.html#ga0c41d6ff208c71f13ff7593d32c50a56" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_instance</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a>. </p>
<p>This operation accesses a collection of data values from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. The behavior is identical to <a class="el" href="group__DDSReaderModule.html#ga0c41d6ff208c71f13ff7593d32c50a56" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_instance</a>, except that all returned samples satisfy the specified condition. In other words, on success, all returned samples belong to belong the single specified instance whose handle is <code>a_handle</code>, and for which the specified <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> evaluates to TRUE. </p>
<p>The behavior of the <a class="el" href="group__DDSReaderModule.html#ga404ce36a7c67a75702d92a29a44039b1" title="Accesses via FooDataReader_read_instance the samples that match the criteria specified in the DDS_Rea...">FooDataReader_read_instance_w_condition</a> operation follows the same rules as the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> operation regarding the pre-conditions and post-conditions for the <code>received_data</code> and <code>sample_info</code>. Similar to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, the <a class="el" href="group__DDSReaderModule.html#ga404ce36a7c67a75702d92a29a44039b1" title="Accesses via FooDataReader_read_instance the samples that match the criteria specified in the DDS_Rea...">FooDataReader_read_instance_w_condition</a> operation may 'loan' elements to the output collections, which must then be returned by means of <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>. </p>
<p>Similar to <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. </p>
<p>If the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> has no samples that meet the constraints, the function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">received_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">info_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">max_samples</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available, up to the limits described in the documentation for <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take()</a>. </td></tr>
    <tr><td class="paramname">a_handle</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The 'next smallest' instance with a value greater than this value that has available samples will be returned. Must be a valid non-NULL <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b" title="Type definition for an instance handle.">DDS_InstanceHandle_t</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">condition</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> to select samples of interest. Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a> <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_next_instance</a> </dd>
<dd>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad16b635d874f45e81db59325b280c6fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_take_instance_w_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&#160;</td>
          <td class="paramname"><em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *&#160;</td>
          <td class="paramname"><em>a_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a> *&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses via <a class="el" href="group__DDSReaderModule.html#gaab2b14c7a98d1cabdc446b543161668c" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_take_instance</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a>. </p>
<p>This operation accesses a collection of data values from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> and 'removes' them from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. The behavior is identical to <a class="el" href="group__DDSReaderModule.html#gaab2b14c7a98d1cabdc446b543161668c" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_take_instance</a>, except that all returned samples satisfy the specified condition. In other words, on success, all returned samples belong to belong the single specified instance whose handle is <code>a_handle</code>, and for which the specified <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> evaluates to TRUE. </p>
<p>The operation has the same behavior as <a class="el" href="group__DDSReaderModule.html#ga404ce36a7c67a75702d92a29a44039b1" title="Accesses via FooDataReader_read_instance the samples that match the criteria specified in the DDS_Rea...">FooDataReader_read_instance_w_condition</a>, except that the samples are 'taken' from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> such that they are no longer accessible via subsequent 'read' or 'take' operations. </p>
<p>The behavior of the <a class="el" href="group__DDSReaderModule.html#gad16b635d874f45e81db59325b280c6fb" title="Accesses via FooDataReader_take_instance the samples that match the criteria specified in the DDS_Rea...">FooDataReader_take_instance_w_condition</a> operation follows the same rules as the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> operation regarding the pre-conditions and post-conditions for the <code>received_data</code> and <code>sample_info</code>. Similar to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, the <a class="el" href="group__DDSReaderModule.html#gad16b635d874f45e81db59325b280c6fb" title="Accesses via FooDataReader_take_instance the samples that match the criteria specified in the DDS_Rea...">FooDataReader_take_instance_w_condition</a> operation may 'loan' elements to the output collections, which must then be returned by means of <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>. </p>
<p>Similar to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. </p>
<p>If the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> has no samples that meet the constraints, the function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">received_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">info_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">max_samples</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available, up to the limits described in the documentation for <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take()</a>. </td></tr>
    <tr><td class="paramname">a_handle</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The 'next smallest' instance with a value greater than this value that has available samples will be returned. Must be a valid non-NULL <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b" title="Type definition for an instance handle.">DDS_InstanceHandle_t</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">condition</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> to select samples of interest. Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>, or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga08724909c0ad0d49f60956f358134adf" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_take_next_instance</a> </dd>
<dd>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga010154c1c20c87500b6068d65c16cdd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_read_next_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&#160;</td>
          <td class="paramname"><em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *&#160;</td>
          <td class="paramname"><em>previous_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a>&#160;</td>
          <td class="paramname"><em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a>&#160;</td>
          <td class="paramname"><em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a>&#160;</td>
          <td class="paramname"><em>instance_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>This operation accesses a collection of data values from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> where all the samples belong to a single instance. The behavior is similar to <a class="el" href="group__DDSReaderModule.html#ga0c41d6ff208c71f13ff7593d32c50a56" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_instance</a>, except that the actual instance is not directly specified. Rather, the samples will all belong to the 'next' instance with <code>instance_handle</code> 'greater' than the specified 'previous_handle' that has available samples. </p>
<p>This operation implies the existence of a total order 'greater-than' relationship between the instance handles. The specifics of this relationship are not all important and are implementation specific. The important thing is that, according to the middleware, all instances are ordered relative to each other. This ordering is between the instance handles; It should not depend on the state of the instance (e.g. whether it has data or not) and must be defined even for instance handles that do not correspond to instances currently managed by the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. For the purposes of the ordering, it should be 'as if' each instance handle was represented as unique integer. </p>
<p>The behavior of <a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_next_instance</a> is 'as if' the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> invoked <a class="el" href="group__DDSReaderModule.html#ga0c41d6ff208c71f13ff7593d32c50a56" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_instance</a>, passing the smallest <code>instance_handle</code> among all the ones that: (a) are greater than <code>previous_handle</code>, and (b) have available samples (i.e. samples that meet the constraints imposed by the specified states). </p>
<p>The special value <a class="el" href="group__DDSUserDataModule.html#ga7974338d80c6817f16f77899d908a60e" title="The NIL instance handle.">DDS_HANDLE_NIL</a> is guaranteed to be 'less than' any valid <code>instance_handle</code>. So the use of the parameter value <code>previous_handle</code> == <a class="el" href="group__DDSUserDataModule.html#ga7974338d80c6817f16f77899d908a60e" title="The NIL instance handle.">DDS_HANDLE_NIL</a> will return the samples for the instance which has the smallest <code>instance_handle</code> among all the instances that contain available samples. </p>
<p>The operation <a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_next_instance</a> is intended to be used in an application-driven iteration, where the application starts by passing <code>previous_handle</code> == <a class="el" href="group__DDSUserDataModule.html#ga7974338d80c6817f16f77899d908a60e" title="The NIL instance handle.">DDS_HANDLE_NIL</a>, examines the samples returned, and then uses the <code>instance_handle</code> returned in the <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> as the value of the <code>previous_handle</code> argument to the next call to <a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_next_instance</a>. The iteration continues until <a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_next_instance</a> fails with the value <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a> . </p>
<p>Note that it is possible to call the <a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_next_instance</a> operation with a <code>previous_handle</code> that does not correspond to an instance currently managed by the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. This is because as stated earlier the 'greater-than' relationship is defined even for handles not managed by the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. One practical situation where this may occur is when an application is iterating though all the instances, takes all the samples of a <a class="el" href="group__DDSInstanceStateModule.html#ggaf2264cae1aa8cd66490debfdc5e0c360a72ebdc6f53c9a7588458b48e3ea66507" title="Not alive no writers for instance. None of the DDS_DataWriter objects that are currently alive (accor...">DDS_NOT_ALIVE_NO_WRITERS_INSTANCE_STATE</a> instance, returns the loan (at which point the instance information may be removed, and thus the handle becomes invalid), and tries to read the next instance. The behavior of the <a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_next_instance</a> operation follows the same rules as the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> operation regarding the pre-conditions and post-conditions for the <code>received_data</code> and <code>sample_info</code>. Similar to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, the <a class="el" href="group__DDSReaderModule.html#ga0c41d6ff208c71f13ff7593d32c50a56" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_instance</a> operation may 'loan' elements to the output collections, which must then be returned by means of <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>. </p>
<p>Similar to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. </p>
<p>If the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> has no samples that meet the constraints, the function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">received_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">info_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">max_samples</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available, up to the limits described in the documentation for <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take()</a>. </td></tr>
    <tr><td class="paramname">previous_handle</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The 'next smallest' instance with a value greater than this value that has available samples will be returned. Must be a valid non-NULL <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b" title="Type definition for an instance handle.">DDS_InstanceHandle_t</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">sample_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>sample_states</code> are returned. See the valid values for this parameter here: <a class="el" href="group__DDSSampleStateModule.html#gadb6d36e7c796da27519b6bf7f8f187e5" title="Indicates whether or not a sample has ever been read.">DDS_SampleStateKind</a>. </td></tr>
    <tr><td class="paramname">view_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>view_state</code> are returned. See the valid values for this parameter here: <a class="el" href="group__DDSViewStateModule.html#gab7a8a4ae44a2c00f411a4461135b45f1" title="Indicates whether or not an instance is new.">DDS_ViewStateKind</a>. </td></tr>
    <tr><td class="paramname">instance_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>instance_state</code> are returned. See the valid values for this parameter here: <a class="el" href="group__DDSInstanceStateModule.html#gaf2264cae1aa8cd66490debfdc5e0c360" title="Indicates if the samples are from a live DDS_DataWriter or not.">DDS_InstanceStateKind</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a> <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> </dd>
<dd>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga08724909c0ad0d49f60956f358134adf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_take_next_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&#160;</td>
          <td class="paramname"><em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *&#160;</td>
          <td class="paramname"><em>previous_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a>&#160;</td>
          <td class="paramname"><em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a>&#160;</td>
          <td class="paramname"><em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a>&#160;</td>
          <td class="paramname"><em>instance_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a collection of data samples from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>This operation accesses a collection of data values from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> and 'removes' them from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>This operation has the same behavior as <a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_next_instance</a>, except that the samples are 'taken' from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> such that they are no longer accessible via subsequent 'read' or 'take' operations. </p>
<p>Similar to the operation <a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_next_instance</a>, it is possible to call <a class="el" href="group__DDSReaderModule.html#ga08724909c0ad0d49f60956f358134adf" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_take_next_instance</a> with a <code>previous_handle</code> that does not correspond to an instance currently managed by the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>The behavior of the <a class="el" href="group__DDSReaderModule.html#ga08724909c0ad0d49f60956f358134adf" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_take_next_instance</a> operation follows the same rules as the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> operation regarding the pre-conditions and post-conditions for the <code>received_data</code> and <code>sample_info</code>. Similar to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, the <a class="el" href="group__DDSReaderModule.html#ga08724909c0ad0d49f60956f358134adf" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_take_next_instance</a> operation may 'loan' elements to the output collections, which must then be returned by means of <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>. </p>
<p>Similar to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. </p>
<p>If the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> has no samples that meet the constraints, the function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">received_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">info_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">max_samples</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available, up to the limits described in the documentation for <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take()</a>. </td></tr>
    <tr><td class="paramname">previous_handle</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The 'next smallest' instance with a value greater than this value that has available samples will be returned. Must be a valid non-NULL <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b" title="Type definition for an instance handle.">DDS_InstanceHandle_t</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">sample_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>sample_states</code> are returned. </td></tr>
    <tr><td class="paramname">view_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>view_state</code> are returned. </td></tr>
    <tr><td class="paramname">instance_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> data samples matching ones of these <code>instance_state</code> are returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take</a> </dd>
<dd>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga55910a020e513e170ec432db8eda4899"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_read_next_instance_w_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&#160;</td>
          <td class="paramname"><em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *&#160;</td>
          <td class="paramname"><em>previous_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a> *&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses via <a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_next_instance</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a>. </p>
<p>This operation accesses a collection of data values from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. The behavior is identical to <a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_next_instance</a>, except that all returned samples satisfy the specified condition. In other words, on success, all returned samples belong to the same instance, and the instance is the instance with 'smallest' <code>instance_handle</code> among the ones that verify: (a) <code>instance_handle</code> &gt;= <code>previous_handle</code>, and (b) have samples for which the specified <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> evaluates to TRUE. </p>
<p>Similar to the operation <a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_next_instance</a>, it is possible to call <a class="el" href="group__DDSReaderModule.html#ga55910a020e513e170ec432db8eda4899" title="Accesses via FooDataReader_read_next_instance the samples that match the criteria specified in the DD...">FooDataReader_read_next_instance_w_condition</a> with a <code>previous_handle</code> that does not correspond to an instance currently managed by the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>The behavior of the <a class="el" href="group__DDSReaderModule.html#ga55910a020e513e170ec432db8eda4899" title="Accesses via FooDataReader_read_next_instance the samples that match the criteria specified in the DD...">FooDataReader_read_next_instance_w_condition</a> operation follows the same rules as the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> operation regarding the pre-conditions and post-conditions for the <code>received_data</code> and <code>sample_info</code>. Similar to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, the <a class="el" href="group__DDSReaderModule.html#ga55910a020e513e170ec432db8eda4899" title="Accesses via FooDataReader_read_next_instance the samples that match the criteria specified in the DD...">FooDataReader_read_next_instance_w_condition</a> operation may 'loan' elements to the output collections, which must then be returned by means of <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>. </p>
<p>Similar to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. </p>
<p>If the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> has no samples that meet the constraints, the function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">received_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">info_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">max_samples</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available, up to the limits described in the documentation for <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take()</a>. </td></tr>
    <tr><td class="paramname">previous_handle</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The 'next smallest' instance with a value greater than this value that has available samples will be returned. Must be a valid non-NULL <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b" title="Type definition for an instance handle.">DDS_InstanceHandle_t</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">condition</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> to select samples of interest. Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a> <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_next_instance</a> </dd>
<dd>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab7d499fba202bd3613c705d53c034a1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_take_next_instance_w_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&#160;</td>
          <td class="paramname"><em>info_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>max_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *&#160;</td>
          <td class="paramname"><em>previous_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a> *&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses via <a class="el" href="group__DDSReaderModule.html#ga08724909c0ad0d49f60956f358134adf" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_take_next_instance</a> the samples that match the criteria specified in the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a>. </p>
<p>This operation accesses a collection of data values from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> and 'removes' them from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>The operation has the same behavior as <a class="el" href="group__DDSReaderModule.html#ga55910a020e513e170ec432db8eda4899" title="Accesses via FooDataReader_read_next_instance the samples that match the criteria specified in the DD...">FooDataReader_read_next_instance_w_condition</a>, except that the samples are 'taken' from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> such that they are no longer accessible via subsequent 'read' or 'take' operations. </p>
<p>Similar to the operation <a class="el" href="group__DDSReaderModule.html#ga010154c1c20c87500b6068d65c16cdd9" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read_next_instance</a>, it is possible to call <a class="el" href="group__DDSReaderModule.html#gab7d499fba202bd3613c705d53c034a1c" title="Accesses via FooDataReader_take_next_instance the samples that match the criteria specified in the DD...">FooDataReader_take_next_instance_w_condition</a> with a <code>previous_handle</code> that does not correspond to an instance currently managed by the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>The behavior of the <a class="el" href="group__DDSReaderModule.html#gab7d499fba202bd3613c705d53c034a1c" title="Accesses via FooDataReader_take_next_instance the samples that match the criteria specified in the DD...">FooDataReader_take_next_instance_w_condition</a> operation follows the same rules as the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a> operation regarding the pre-conditions and post-conditions for the <code>received_data</code> and <code>sample_info</code>. Similar to <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, the <a class="el" href="group__DDSReaderModule.html#gab7d499fba202bd3613c705d53c034a1c" title="Accesses via FooDataReader_take_next_instance the samples that match the criteria specified in the DD...">FooDataReader_take_next_instance_w_condition</a> operation may 'loan' elements to the output collections, which must then be returned by means of <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>. </p>
<p>Similar to the <a class="el" href="group__DDSReaderModule.html#ga84f8ad6ee21fb024234034bbcce6d812" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_read</a>, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. </p>
<p>If the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> has no samples that meet the constraints, the function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">received_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> object where the received data samples will be returned. Must be a valid non-NULL <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">info_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a> object where the received sample info will be returned. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">max_samples</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The maximum number of samples to be returned. If the special value <a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> is provided, as many samples will be returned as are available, up to the limits described in the documentation for <a class="el" href="group__DDSReaderModule.html#gafa56233023b6c95f89a9df48d16a4659" title="Access a collection of data-samples from the DDS_DataReader.">FooDataReader_take()</a>. </td></tr>
    <tr><td class="paramname">previous_handle</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The 'next smallest' instance with a value greater than this value that has available samples will be returned. Must be a valid non-NULL <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b" title="Type definition for an instance handle.">DDS_InstanceHandle_t</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">condition</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> to select samples of interest. Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>, or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91aa8e69444ae8a8efa65bde05556818669" title="Indicates a transient situation where the operation did not return any data but there is no inherent ...">DDS_RETCODE_NO_DATA</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga08724909c0ad0d49f60956f358134adf" title="Access a collection of data samples from the DDS_DataReader.">FooDataReader_take_next_instance</a> </dd>
<dd>
<a class="el" href="group__DDSResourceLimitsQosModule.html#ga58912505c0b73a5f1d3677eaf9ce9e6d" title="A special value indicating an unlimited quantity.">DDS_LENGTH_UNLIMITED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadf2188ce7cd1b7bed39451833b91f1f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_return_loan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFooSeq.html">FooSeq</a> *&#160;</td>
          <td class="paramname"><em>received_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleInfoSeq.html">DDS_SampleInfoSeq</a> *&#160;</td>
          <td class="paramname"><em>info_seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> that the application is done accessing the collection of <code>received_data</code> and <code>info_seq</code> obtained by some earlier invocation of read or take on the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>This operation indicates to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> that the application is done accessing the collection of <code>received_data</code> and <code>info_seq</code> obtained by some earlier invocation of read or take on the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>The <code>received_data</code> and <code>info_seq</code> must belong to a single related "pair"; that is, they should correspond to a pair returned from a single call to read or take. The <code>received_data</code> and <code>info_seq</code> must also have been obtained from the same <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> to which they are returned. If either of these conditions is not met, the operation will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>. </p>
<p>The operation <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a> allows implementations of the read and take operations to "loan" buffers from the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> to the application and in this manner provide "zerocopy" access to the data. During the loan, the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> will guarantee that the data and sample-information are not modified. </p>
<p>It is not necessary for an application to return the loans immediately after the read or take calls. However, as these buffers correspond to internal resources inside the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>, the application should not retain them indefinitely. </p>
<p>The use of <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a> is only necessary if the read or take calls "loaned" buffers to the application. This only occurs if the <code>received_data</code> and <code>info_Seq</code> collections had <code>max_len=0</code> at the time read or take was called. </p>
<p>The application may also examine the "owns" property of the collection to determine where there is an outstanding loan. However, calling <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a> on a collection that does not have a loan is safe and has no side effects. </p>
<p>If the collections had a loan, upon completion of <a class="el" href="group__DDSReaderModule.html#gadf2188ce7cd1b7bed39451833b91f1f6" title="Indicates to the DDS_DataReader that the application is done accessing the collection of received_dat...">FooDataReader_return_loan</a>, the collections will have <code>max_len=0</code>. </p>
<p>Similar to read, this operation must be provided on the specialized class that is generated for the particular application data-type that is being taken. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">received_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> user data type-specific <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> object where the received data samples was obtained from earlier invocation of read or take on the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. Must be a valid non-NULL <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">info_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> a <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a> object where the received sample info was obtained from earlier invocation of read or take on the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. Must be a valid non-NULL <a class="el" href="structDDS__SampleInfoSeq.html" title="Declares IDL sequence &lt; DDS_SampleInfo &gt; .">DDS_SampleInfoSeq</a>. The function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if it is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga434a5530ff95ee21227e5643273a85d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> FooDataReader_get_key_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFoo.html">Foo</a> *&#160;</td>
          <td class="paramname"><em>key_holder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the instance <code>key</code> that corresponds to an instance <code>handle</code>. </p>
<p>Useful for keyed data types. </p>
<p>The operation will only fill the fields that form the <code>key</code> inside the <code>key_holder</code> instance. </p>
<p>For keyed data types, this operation may fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if the <code>handle</code> does not correspond to an existing data-object known to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">key_holder</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> a user data type specific key holder, whose <code>key</code> fields are filled by this operation. If <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> has no key, this function has no effect. This function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if <code>key_holder</code> is NULL. </td></tr>
    <tr><td class="paramname">handle</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the <code>instance</code> whose key is to be retrieved. If <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> <em>has</em> a key, <code>handle</code> must represent an existing instance of type <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> known to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. Otherwise, this function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a>. </td></tr>
  </table>
  </dd>
</dl>
<p>If <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> <em>has</em> a key and <code>handle</code> is <a class="el" href="group__DDSUserDataModule.html#ga7974338d80c6817f16f77899d908a60e" title="The NIL instance handle.">DDS_HANDLE_NIL</a>, this function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a>. </p>
<p>If <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> has a key and <code>handle</code> represents an instance of another type or an instance of type <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> that has been unregistered, this function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a>. If <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> has no key, this function has no effect. </p>
<p>This function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a> if <code>handle</code> is NULL. </p>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSWriterModule.html#ga19894c4f981ba46f999ab297b5211cf9" title="Retrieve the instance key that corresponds to an instance handle.">FooDataWriter_get_key_value</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2fd320620045206555b1205574e20424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> FooDataReader_lookup_instance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFooDataReader.html">FooDataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structFoo.html">Foo</a> *&#160;</td>
          <td class="paramname"><em>key_holder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the instance <code>handle</code> that corresponds to an instance <code>key_holder</code>. </p>
<p>Useful for keyed data types. </p>
<p>This operation takes as a parameter an instance and returns a handle that can be used in subsequent operations that accept an instance handle as an argument. The instance parameter is only used for the purpose of examining the fields that define the key. This operation does not register the instance in question. If the instance has not been previously registered, or if for any other reason the Service is unable to provide an instance handle, the Service will return the special value <a class="el" href="group__DDSUserDataModule.html#ga7974338d80c6817f16f77899d908a60e" title="The NIL instance handle.">DDS_HANDLE_NIL</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">key_holder</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> a user data type specific key holder. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the instance handle associated with this instance. If <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> has no key, this function has no effect and returns <a class="el" href="group__DDSUserDataModule.html#ga7974338d80c6817f16f77899d908a60e" title="The NIL instance handle.">DDS_HANDLE_NIL</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae42864b6d0bba9133c02edb8499bebc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_RequestedDeadlineMissedStatus_initialize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html" title="DDS_REQUESTED_DEADLINE_MISSED_STATUS">DDS_RequestedDeadlineMissedStatus</a> instances on heap should be initialized with this function before they are passed to any function. This step ensures that those contained fields that use dynamic memory are properly initialized. This function does not allocate memory. </p>
<p><a class="el" href="group__DDSReaderModule.html#gab3fba000e337f5b1b3a7aa3eebb0e01d" title="Free any dynamic memory allocated by status instances.">DDS_RequestedDeadlineMissedStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><a class="code" href="structDDS__RequestedDeadlineMissedStatus.html" title="DDS_REQUESTED_DEADLINE_MISSED_STATUS">DDS_RequestedDeadlineMissedStatus</a> *myStatus = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__RequestedDeadlineMissedStatus.html" title="DDS_REQUESTED_DEADLINE_MISSED_STATUS">DDS_RequestedDeadlineMissedStatus</a>)); </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#gae42864b6d0bba9133c02edb8499bebc7" title="Initializer for new status instances.">DDS_RequestedDeadlineMissedStatus_initialize</a>(myStatus); </div>
<div class="line"> ... </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#gab3fba000e337f5b1b3a7aa3eebb0e01d" title="Free any dynamic memory allocated by status instances.">DDS_RequestedDeadlineMissedStatus_finalize</a>(myStatus);</div>
<div class="line"> free(myStatus);                                         </div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga63dd5dce539e1fbfeef6aa103fe5a5c6" title="Initializer for new status instances.">DDS_RequestedDeadlineMissedStatus_INITIALIZER</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gab3fba000e337f5b1b3a7aa3eebb0e01d" title="Free any dynamic memory allocated by status instances.">DDS_RequestedDeadlineMissedStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga24e09cac0e2af80edb94b57272196619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_RequestedDeadlineMissedStatus_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of the given status into this status. </p>
<p>Status instances can use dynamic memory because of the sequences contained in some status. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">source</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab3fba000e337f5b1b3a7aa3eebb0e01d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_RequestedDeadlineMissedStatus_finalize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free any dynamic memory allocated by status instances. </p>
<p>some status may use dynamic memory (regardless of whether the status itself is in dynamic memory). This function frees that memory but otherwise leaves this status unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). </p>
<p>Note that if this status instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based status instance after calling this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5271a563774a9f2a72809b3735405cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_LivelinessChangedStatus_initialize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__LivelinessChangedStatus.html" title="DDS_LIVELINESS_CHANGED_STATUS">DDS_LivelinessChangedStatus</a> instances on heap should be initialized with this function before they are passed to any function. This step ensures that those contained fields that use dynamic memory are properly initialized. This function does not allocate memory. </p>
<p><a class="el" href="group__DDSReaderModule.html#gaab27cc8ce42069622afae27f49b373e0" title="Free any dynamic memory allocated by status instances.">DDS_LivelinessChangedStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><a class="code" href="structDDS__LivelinessChangedStatus.html" title="DDS_LIVELINESS_CHANGED_STATUS">DDS_LivelinessChangedStatus</a> *myStatus = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__LivelinessChangedStatus.html" title="DDS_LIVELINESS_CHANGED_STATUS">DDS_LivelinessChangedStatus</a>)); </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#ga5271a563774a9f2a72809b3735405cd8" title="Initializer for new status instances.">DDS_LivelinessChangedStatus_initialize</a>(myStatus); </div>
<div class="line"> ... </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#gaab27cc8ce42069622afae27f49b373e0" title="Free any dynamic memory allocated by status instances.">DDS_LivelinessChangedStatus_finalize</a>(myStatus);</div>
<div class="line"> free(myStatus);                                         </div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga2782ef600172b7568bbb2b63bba06579" title="Initializer for new status instances.">DDS_LivelinessChangedStatus_INITIALIZER</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gaab27cc8ce42069622afae27f49b373e0" title="Free any dynamic memory allocated by status instances.">DDS_LivelinessChangedStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2e560fe3c0dc385b8f051e39a3b8369"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_LivelinessChangedStatus_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of the given status into this status. </p>
<p>Status instances can use dynamic memory because of the sequences contained in some status. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">source</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab27cc8ce42069622afae27f49b373e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_LivelinessChangedStatus_finalize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free any dynamic memory allocated by status instances. </p>
<p>some status may use dynamic memory (regardless of whether the status itself is in dynamic memory). This function frees that memory but otherwise leaves this status unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). </p>
<p>Note that if this status instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based status instance after calling this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga420c632bdc10f20b21a9c9ba9ae3b0e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_RequestedIncompatibleQosStatus_initialize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html" title="DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS">DDS_RequestedIncompatibleQosStatus</a> instances on heap should be initialized with this function before they are passed to any function. This step ensures that those contained fields that use dynamic memory are properly initialized. This function does not allocate memory. </p>
<p><a class="el" href="group__DDSReaderModule.html#gaab52ada6e4480cd8d1b296baa2c64ad9" title="Free any dynamic memory allocated by status instances.">DDS_RequestedIncompatibleQosStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><a class="code" href="structDDS__RequestedIncompatibleQosStatus.html" title="DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS">DDS_RequestedIncompatibleQosStatus</a> *myStatus = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__RequestedIncompatibleQosStatus.html" title="DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS">DDS_RequestedIncompatibleQosStatus</a>)); </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#ga420c632bdc10f20b21a9c9ba9ae3b0e8" title="Initializer for new status instances.">DDS_RequestedIncompatibleQosStatus_initialize</a>(myStatus); </div>
<div class="line"> ... </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#gaab52ada6e4480cd8d1b296baa2c64ad9" title="Free any dynamic memory allocated by status instances.">DDS_RequestedIncompatibleQosStatus_finalize</a>(myStatus);</div>
<div class="line"> free(myStatus);                                         </div>
</div><!-- fragment --> <dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga921a6add7754ae8c670109f4755fd84b" title="Initializer for new status instances.">DDS_RequestedIncompatibleQosStatus_INITIALIZER</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gaab52ada6e4480cd8d1b296baa2c64ad9" title="Free any dynamic memory allocated by status instances.">DDS_RequestedIncompatibleQosStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga683ac618feceb34ab55fe7893c1cc18d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_RequestedIncompatibleQosStatus_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of the given status into this status. </p>
<p>Status instances can use dynamic memory because of the sequences contained in some status. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">source</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab52ada6e4480cd8d1b296baa2c64ad9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_RequestedIncompatibleQosStatus_finalize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free any dynamic memory allocated by status instances. </p>
<p>some status may use dynamic memory (regardless of whether the status itself is in dynamic memory). This function frees that memory but otherwise leaves this status unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). </p>
<p>Note that if this status instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based status instance after calling this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaad9f77fd4d243ffa3c459aa8c436b8ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_SampleLostStatus_initialize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__SampleLostStatus.html" title="DDS_SAMPLE_LOST_STATUS">DDS_SampleLostStatus</a> instances on heap should be initialized with this function before they are passed to any function. This step ensures that those contained fields that use dynamic memory are properly initialized. This function does not allocate memory. </p>
<p><a class="el" href="group__DDSReaderModule.html#gaab52ada6e4480cd8d1b296baa2c64ad9" title="Free any dynamic memory allocated by status instances.">DDS_RequestedIncompatibleQosStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><a class="code" href="structDDS__SampleLostStatus.html" title="DDS_SAMPLE_LOST_STATUS">DDS_SampleLostStatus</a> *myStatus = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__SampleLostStatus.html" title="DDS_SAMPLE_LOST_STATUS">DDS_SampleLostStatus</a>)); </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#gaad9f77fd4d243ffa3c459aa8c436b8ff" title="Initializer for new status instances.">DDS_SampleLostStatus_initialize</a>(myStatus); </div>
<div class="line"> ... </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#ga757dc31c9b9344362cd483f6b3790384" title="Free any dynamic memory allocated by status instances.">DDS_SampleLostStatus_finalize</a>(myStatus);</div>
<div class="line"> free(myStatus);                                         </div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#gaf4c1f7a879707692562cd6508d5966aa" title="Initializer for new status instances.">DDS_SampleLostStatus_INITIALIZER</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#ga757dc31c9b9344362cd483f6b3790384" title="Free any dynamic memory allocated by status instances.">DDS_SampleLostStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaeb526d90fdc6fe5dd3e2d7c20868a2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_SampleLostStatus_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of the given status into this status. </p>
<p>Status instances can use dynamic memory because of the sequences contained in some status. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">source</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga757dc31c9b9344362cd483f6b3790384"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_SampleLostStatus_finalize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free any dynamic memory allocated by status instances. </p>
<p>some status may use dynamic memory (regardless of whether the status itself is in dynamic memory). This function frees that memory but otherwise leaves this status unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). </p>
<p>Note that if this status instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based status instance after calling this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa8b8755d6dc935138cc715d5b975202d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_SampleRejectedStatus_initialize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__SampleRejectedStatus.html" title="DDS_SAMPLE_REJECTED_STATUS">DDS_SampleRejectedStatus</a> instances on heap should be initialized with this function before they are passed to any function. This step ensures that those contained fields that use dynamic memory are properly initialized. This function does not allocate memory. </p>
<p><a class="el" href="group__DDSReaderModule.html#gaab52ada6e4480cd8d1b296baa2c64ad9" title="Free any dynamic memory allocated by status instances.">DDS_RequestedIncompatibleQosStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><a class="code" href="structDDS__SampleRejectedStatus.html" title="DDS_SAMPLE_REJECTED_STATUS">DDS_SampleRejectedStatus</a> *myStatus = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__SampleRejectedStatus.html" title="DDS_SAMPLE_REJECTED_STATUS">DDS_SampleRejectedStatus</a>)); </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#gaa8b8755d6dc935138cc715d5b975202d" title="Initializer for new status instances.">DDS_SampleRejectedStatus_initialize</a>(myStatus); </div>
<div class="line"> ... </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#ga8f324b1b1b20b914cb0c8422e1003ae9" title="Free any dynamic memory allocated by status instances.">DDS_SampleRejectedStatus_finalize</a>(myStatus);</div>
<div class="line"> free(myStatus);                                         </div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga0a4b42a43cd74020e6315ab9fec1895d" title="Initializer for new status instances.">DDS_SampleRejectedStatus_INITIALIZER</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#ga8f324b1b1b20b914cb0c8422e1003ae9" title="Free any dynamic memory allocated by status instances.">DDS_SampleRejectedStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga43f3b0fd14443908d67fda7b45d8ea5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_SampleRejectedStatus_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of the given status into this status. </p>
<p>Status instances can use dynamic memory because of the sequences contained in some status. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">source</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8f324b1b1b20b914cb0c8422e1003ae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_SampleRejectedStatus_finalize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free any dynamic memory allocated by status instances. </p>
<p>some status may use dynamic memory (regardless of whether the status itself is in dynamic memory). This function frees that memory but otherwise leaves this status unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). </p>
<p>Note that if this status instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based status instance after calling this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga54fc534d7b91199b73430c2d43ac1755"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_SubscriptionMatchedStatus_initialize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__SubscriptionMatchedStatus.html" title="DDS_SUBSCRIPTION_MATCHED_STATUS">DDS_SubscriptionMatchedStatus</a> instances on heap should be initialized with this function before they are passed to any function. This step ensures that those contained fields that use dynamic memory are properly initialized. This function does not allocate memory. </p>
<p><a class="el" href="group__DDSReaderModule.html#gaab52ada6e4480cd8d1b296baa2c64ad9" title="Free any dynamic memory allocated by status instances.">DDS_RequestedIncompatibleQosStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><a class="code" href="structDDS__SubscriptionMatchedStatus.html" title="DDS_SUBSCRIPTION_MATCHED_STATUS">DDS_SubscriptionMatchedStatus</a> *myStatus = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__SubscriptionMatchedStatus.html" title="DDS_SUBSCRIPTION_MATCHED_STATUS">DDS_SubscriptionMatchedStatus</a>)); </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#ga54fc534d7b91199b73430c2d43ac1755" title="Initializer for new status instances.">DDS_SubscriptionMatchedStatus_initialize</a>(myStatus); </div>
<div class="line"> ... </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#gae97dae72e3d6f58afd3f6a058bb73b66" title="Free any dynamic memory allocated by status instances.">DDS_SubscriptionMatchedStatus_finalize</a>(myStatus);</div>
<div class="line"> free(myStatus);                                         </div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga6c5c0e445a7d0e968129792ee3ad9403" title="Initializer for new status instances.">DDS_SubscriptionMatchedStatus_INITIALIZER</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gae97dae72e3d6f58afd3f6a058bb73b66" title="Free any dynamic memory allocated by status instances.">DDS_SubscriptionMatchedStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga107f1a93f438655b3a01196a8359a21f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_SubscriptionMatchedStatus_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of the given status into this status. </p>
<p>Status instances can use dynamic memory because of the sequences contained in some status. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">source</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae97dae72e3d6f58afd3f6a058bb73b66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_SubscriptionMatchedStatus_finalize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free any dynamic memory allocated by status instances. </p>
<p>some status may use dynamic memory (regardless of whether the status itself is in dynamic memory). This function frees that memory but otherwise leaves this status unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). </p>
<p>Note that if this status instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based status instance after calling this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad9c14b59e151d9dbdbf940cdc7804bee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReaderCacheStatus_initialize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__DataReaderCacheStatus.html">DDS_DataReaderCacheStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__DataReaderCacheStatus.html" title="&lt;&lt;extension&gt;&gt; The status of the reader&#39;s cache.">DDS_DataReaderCacheStatus</a> instance on heap should be initialized with this function before they are passed to any function. This step ensures that those contained fields that use dynamic memory are properly initialized. This function does not allocate memory. </p>
<p><a class="el" href="group__DDSReaderModule.html#ga45a17706bc1673a4d90a7b190301bd9c" title="Free any dynamic memory allocated by status instances.">DDS_DataReaderCacheStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><a class="code" href="structDDS__DataReaderCacheStatus.html" title="&lt;&lt;extension&gt;&gt; The status of the reader&#39;s cache.">DDS_DataReaderCacheStatus</a> *myStatus = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__DataReaderCacheStatus.html" title="&lt;&lt;extension&gt;&gt; The status of the reader&#39;s cache.">DDS_DataReaderCacheStatus</a>)); </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#gad9c14b59e151d9dbdbf940cdc7804bee" title="Initializer for new status instances.">DDS_DataReaderCacheStatus_initialize</a>(myStatus); </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#ga93a94e1fd1aafc39f3c7e806d1d10f0f" title="&lt;&lt;extension&gt;&gt; Get the datareader cache status for this reader.">DDS_DataReader_get_datareader_cache_status</a>(myDataReader, myStatus);</div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#ga45a17706bc1673a4d90a7b190301bd9c" title="Free any dynamic memory allocated by status instances.">DDS_DataReaderCacheStatus_finalize</a>(myStatus);</div>
<div class="line"> free(myStatus);                                         </div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga93a94e1fd1aafc39f3c7e806d1d10f0f" title="&lt;&lt;extension&gt;&gt; Get the datareader cache status for this reader.">DDS_DataReader_get_datareader_cache_status</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#ga45a17706bc1673a4d90a7b190301bd9c" title="Free any dynamic memory allocated by status instances.">DDS_DataReaderCacheStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab70f6bd2a67e9eee11643bfad487ed52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReaderCacheStatus_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__DataReaderCacheStatus.html">DDS_DataReaderCacheStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__DataReaderCacheStatus.html">DDS_DataReaderCacheStatus</a> *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of the given status into this status. </p>
<p>Status instances can use dynamic memory because of the sequences contained in some status. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">source</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga901cbe00ad4ca398bbb2d768d2e3e856" title="Initializer for new status instances.">DDS_DataReaderCacheStatus_INITIALIZER</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gad9c14b59e151d9dbdbf940cdc7804bee" title="Initializer for new status instances.">DDS_DataReaderCacheStatus_initialize</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#ga45a17706bc1673a4d90a7b190301bd9c" title="Free any dynamic memory allocated by status instances.">DDS_DataReaderCacheStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga45a17706bc1673a4d90a7b190301bd9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReaderCacheStatus_finalize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__DataReaderCacheStatus.html">DDS_DataReaderCacheStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free any dynamic memory allocated by status instances. </p>
<p>some status may use dynamic memory (regardless of whether the status itself is in dynamic memory). This function frees that memory but otherwise leaves this status unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). </p>
<p>Note that if this status instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based status instance after calling this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga901cbe00ad4ca398bbb2d768d2e3e856" title="Initializer for new status instances.">DDS_DataReaderCacheStatus_INITIALIZER</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gad9c14b59e151d9dbdbf940cdc7804bee" title="Initializer for new status instances.">DDS_DataReaderCacheStatus_initialize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad81b4ada2f2c61fb2a6130951b400400"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReaderProtocolStatus_initialize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__DataReaderProtocolStatus.html">DDS_DataReaderProtocolStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new status instances. </p>
<p>New <a class="el" href="structDDS__DataReaderProtocolStatus.html" title="&lt;&lt;extension&gt;&gt; The status of a reader&#39;s internal protocol related metrics, like the number of samp...">DDS_DataReaderProtocolStatus</a> instance on heap should be initialized with this function before they are passed to any function. This step ensures that those contained fields that use dynamic memory are properly initialized. This function does not allocate memory. </p>
<p><a class="el" href="group__DDSReaderModule.html#ga418d64947735d8dfd8000d9bcaa7b982" title="Free any dynamic memory allocated by status instances.">DDS_DataReaderProtocolStatus_finalize</a> should be called to free the contained fields that use dynamic memory: </p>
<div class="fragment"><div class="line"><a class="code" href="structDDS__DataReaderProtocolStatus.html" title="&lt;&lt;extension&gt;&gt; The status of a reader&#39;s internal protocol related metrics, like the number of samp...">DDS_DataReaderProtocolStatus</a> *myStatus = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__DataReaderProtocolStatus.html" title="&lt;&lt;extension&gt;&gt; The status of a reader&#39;s internal protocol related metrics, like the number of samp...">DDS_DataReaderProtocolStatus</a>)); </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#gad81b4ada2f2c61fb2a6130951b400400" title="Initializer for new status instances.">DDS_DataReaderProtocolStatus_initialize</a>(myStatus); </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#gac7a347d2add85ece49739512970972c8" title="&lt;&lt;extension&gt;&gt; Get the datareader protocol status for this reader.">DDS_DataReader_get_datareader_protocol_status</a>(myDataReader, myStatus);</div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#ga418d64947735d8dfd8000d9bcaa7b982" title="Free any dynamic memory allocated by status instances.">DDS_DataReaderProtocolStatus_finalize</a>(myStatus);</div>
<div class="line"> free(myStatus);                                         </div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#gac7a347d2add85ece49739512970972c8" title="&lt;&lt;extension&gt;&gt; Get the datareader protocol status for this reader.">DDS_DataReader_get_datareader_protocol_status</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#ga418d64947735d8dfd8000d9bcaa7b982" title="Free any dynamic memory allocated by status instances.">DDS_DataReaderProtocolStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac510a168ae4aa5b0dda50839f4506b53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReaderProtocolStatus_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__DataReaderProtocolStatus.html">DDS_DataReaderProtocolStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__DataReaderProtocolStatus.html">DDS_DataReaderProtocolStatus</a> *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of the given status into this status. </p>
<p>Status instances can use dynamic memory because of the sequences contained in some status. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">source</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#gafaab1c73ce936c2664bf5c5055f32ae9" title="Initializer for new status instances.">DDS_DataReaderProtocolStatus_INITIALIZER</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gad81b4ada2f2c61fb2a6130951b400400" title="Initializer for new status instances.">DDS_DataReaderProtocolStatus_initialize</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#ga418d64947735d8dfd8000d9bcaa7b982" title="Free any dynamic memory allocated by status instances.">DDS_DataReaderProtocolStatus_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga418d64947735d8dfd8000d9bcaa7b982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReaderProtocolStatus_finalize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__DataReaderProtocolStatus.html">DDS_DataReaderProtocolStatus</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free any dynamic memory allocated by status instances. </p>
<p>some status may use dynamic memory (regardless of whether the status itself is in dynamic memory). This function frees that memory but otherwise leaves this status unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). </p>
<p>Note that if this status instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based status instance after calling this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#gafaab1c73ce936c2664bf5c5055f32ae9" title="Initializer for new status instances.">DDS_DataReaderProtocolStatus_INITIALIZER</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gad81b4ada2f2c61fb2a6130951b400400" title="Initializer for new status instances.">DDS_DataReaderProtocolStatus_initialize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab31248e90a8e3e031540a62dc991f424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#ga19b2e2f603cfff0021ec54dc57ceae7d">DDS_Boolean</a> DDS_DataReaderQos_equals </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a> for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> This DataReaderQos. </td></tr>
    <tr><td class="paramname">other</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The other DataReaderQos to be compared with this DataReaderQos. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> if the two Qos objects are equal or <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga45e821e20642157dc567e18dc7a63346"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReaderQos_initialize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for new QoS instances. </p>
<p>New <a class="el" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a> instances on heap should be initialized with this function before they are passed to any function. This step ensures that those contained QoS policies that use dynamic memory are properly initialized. This function does not allocate memory. </p>
<p>Calling this function is not a substitute for calling <a class="el" href="group__DDSReaderModule.html#gae5b1cfff484564089701bc91eb3edafe" title="Gets the reader QoS.">DDS_DataReader_get_qos</a> or <a class="el" href="group__DDSDomainParticipantModule.html#ga2dbde1ddb44183864f3834db374ba6d3" title="&lt;&lt;extension&gt;&gt; Copy the default DDS_DataReaderQos values into the provided DDS_DataReaderQos instance...">DDS_DomainParticipant_get_default_datareader_qos</a>; one of those should be called subsequently to setting the QoS of any new or existing entity. <a class="el" href="group__DDSReaderModule.html#ga09dfd320506e72b6236c939caba93887" title="Free any dynamic memory allocated by the policies in this DDS_DataReaderQos.">DDS_DataReaderQos_finalize</a> should be called to free the contained QoS policies that use dynamic memory: </p>
<div class="fragment"><div class="line"><a class="code" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a> *myQos = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a>)); </div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#ga45e821e20642157dc567e18dc7a63346" title="Initializer for new QoS instances.">DDS_DataReaderQos_initialize</a>(myQos); </div>
<div class="line"> DDS_DomainParticipantFactory_get_default_datareader_qos(myFactory, myQos);</div>
<div class="line"> DDS_DataReaderQos_set_qos(myDataReader, myQos);</div>
<div class="line"> <a class="code" href="group__DDSReaderModule.html#ga09dfd320506e72b6236c939caba93887" title="Free any dynamic memory allocated by the policies in this DDS_DataReaderQos.">DDS_DataReaderQos_finalize</a>(myQos);</div>
<div class="line"> free(myQos);                     </div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga9b7aa62b41bef09a48fc43ea26d2e645" title="Initializer for new QoS instances.">DDS_DataReaderQos_INITIALIZER</a> </dd>
<dd>
<a class="el" href="group__DDSDomainParticipantModule.html#ga2dbde1ddb44183864f3834db374ba6d3" title="&lt;&lt;extension&gt;&gt; Copy the default DDS_DataReaderQos values into the provided DDS_DataReaderQos instance...">DDS_DomainParticipant_get_default_datareader_qos</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#ga09dfd320506e72b6236c939caba93887" title="Free any dynamic memory allocated by the policies in this DDS_DataReaderQos.">DDS_DataReaderQos_finalize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaca08c0dd978d76072b4bbfab89299f83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReaderQos_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of the given QoS into this QoS. </p>
<p><a class="el" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a> instances can use dynamic memory because of the sequences contained in some QoS policies. A shallow copy by assignment is therefore unsafe. This function performs a deep-copy, allocating memory if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">source</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Status to be copied from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09dfd320506e72b6236c939caba93887"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReaderQos_finalize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free any dynamic memory allocated by the policies in this <a class="el" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a>. </p>
<p>Some QoS policies may use dynamic memory (regardless of whether the QoS itself is in dynamic memory). This function frees that memory but otherwise leaves this QoS unchanged. It should be called on all instances before they are freed (or, in the case of stack-based instances, before they go out of scope). </p>
<p>This function does not leave this object in an invalid state. It is permissable to clear a QoS and then subsequently allocate new dynamic memory in one or more of its QoS policies. </p>
<p>Note that if this QoS instance is stored in heap memory, calling this function will <em>not</em> call free() on it; the user is responsible for explicitly freeing any heap-based QoS instance after calling this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6f5ee779d32b78d5255ca41ae3b521ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSEntityModule.html#ga928b59d917d674720975f0581149b905">DDS_Entity</a>* DDS_DataReader_as_entity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>dataReader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>'s supertype instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataReader</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab6e48531c43261208a355211da9395e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a>* DDS_DataReader_create_readcondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a>&#160;</td>
          <td class="paramname"><em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a>&#160;</td>
          <td class="paramname"><em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a>&#160;</td>
          <td class="paramname"><em>instance_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a>. </p>
<p>The returned <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> will be attached and belong to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">sample_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> sample state of the data samples that are of interest </td></tr>
    <tr><td class="paramname">view_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> view state of the data samples that are of interest </td></tr>
    <tr><td class="paramname">instance_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> instance state of the data samples that are of interest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> created. Returns NULL in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gadc22d119a497a8e2359f6cb2ebcfd0fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843">DDS_QueryCondition</a>* DDS_DataReader_create_querycondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSSampleStateModule.html#ga00cf17a2dec95fc16ffd02c57ef356f5">DDS_SampleStateMask</a>&#160;</td>
          <td class="paramname"><em>sample_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSViewStateModule.html#gac6c18247f611af71486839446604e18c">DDS_ViewStateMask</a>&#160;</td>
          <td class="paramname"><em>view_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSInstanceStateModule.html#ga4ded4022b3281636f4fbee19aab2844f">DDS_InstanceStateMask</a>&#160;</td>
          <td class="paramname"><em>instance_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>query_expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__StringSeq.html">DDS_StringSeq</a> *&#160;</td>
          <td class="paramname"><em>query_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843" title="&lt;&lt;interface&gt;&gt; These are specialised DDS_ReadCondition objects that allow the application to also spec...">DDS_QueryCondition</a>. </p>
<p>The returned <a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843" title="&lt;&lt;interface&gt;&gt; These are specialised DDS_ReadCondition objects that allow the application to also spec...">DDS_QueryCondition</a> will be attached and belong to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p><a class="el" href="group__DDSQueryAndFilterSyntaxModule.html">Queries and Filters Syntax</a> describes the syntax of <code>query_expression</code> and <code>query_parameters</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">sample_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> sample state of the data samples that are of interest </td></tr>
    <tr><td class="paramname">view_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> view state of the data samples that are of interest </td></tr>
    <tr><td class="paramname">instance_states</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> instance state of the data samples that are of interest </td></tr>
    <tr><td class="paramname">query_expression</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Expression for the query. Cannot be NULL. </td></tr>
    <tr><td class="paramname">query_parameters</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Parameters for the query expression. Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return <a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843" title="&lt;&lt;interface&gt;&gt; These are specialised DDS_ReadCondition objects that allow the application to also spec...">DDS_QueryCondition</a> created. Returns NULL in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga47b1ae37d4e2eb9070f8df5b5aa1446b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_delete_readcondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba">DDS_ReadCondition</a> *&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> or <a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843" title="&lt;&lt;interface&gt;&gt; These are specialised DDS_ReadCondition objects that allow the application to also spec...">DDS_QueryCondition</a> attached to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>Since <a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843" title="&lt;&lt;interface&gt;&gt; These are specialised DDS_ReadCondition objects that allow the application to also spec...">DDS_QueryCondition</a> specializes <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a>, it can also be used to delete a <a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843" title="&lt;&lt;interface&gt;&gt; These are specialised DDS_ReadCondition objects that allow the application to also spec...">DDS_QueryCondition</a>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> must be attached to the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>, or the operation will fail with the error <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a>. </dd></dl>
<dl class="section user"><dt>MT Safety:</dt><dd>UNSAFE. It is not safe to delete an entity while another thread may be simultaneously calling an API that uses the entity. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">condition</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Condition to be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga605cd53958cf2919c345c76259123650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_delete_contained_entities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes all the entities that were created by means of the "create" operations on the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>Deletes all contained <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> and <a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843" title="&lt;&lt;interface&gt;&gt; These are specialised DDS_ReadCondition objects that allow the application to also spec...">DDS_QueryCondition</a> objects. </p>
<p>The operation will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a> if the any of the contained entities is in a state where it cannot be deleted. </p>
<p>Once <a class="el" href="group__DDSReaderModule.html#ga605cd53958cf2919c345c76259123650" title="Deletes all the entities that were created by means of the &quot;create&quot; operations on the DDS_DataReader...">DDS_DataReader_delete_contained_entities</a> completes successfully, the application may delete the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>, knowing that it has no contained <a class="el" href="group__DDSReadConditionModule.html#ga5386f18823c58c65c1293b0ac89dd9ba" title="&lt;&lt;interface&gt;&gt; Conditions specifically dedicated to read operations and attached to one DDS_DataReader...">DDS_ReadCondition</a> and <a class="el" href="group__DDSQueryConditionModule.html#ga51ec811e0c2d583015ac7d5a4cd4d843" title="&lt;&lt;interface&gt;&gt; These are specialised DDS_ReadCondition objects that allow the application to also spec...">DDS_QueryCondition</a> objects. </p>
<dl class="section user"><dt>MT Safety:</dt><dd>UNSAFE. It is not safe to delete an entity while another thread may be simultaneously calling an API that uses the entity. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab116e48bb072f448fbf531bf9fd98cc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_wait_for_historical_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__Duration__t.html">DDS_Duration_t</a> *&#160;</td>
          <td class="paramname"><em>max_wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until all "historical" data is received for <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> entities that have a non-VOLATILE Durability Qos kind. </p>
<p>This operation is intended only for <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> entities that have a non-VOLATILE Durability QoS kind. </p>
<p>As soon as an application enables a non-VOLATILE <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>, it will start receiving both "historical" data (i.e., the data that was written prior to the time the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> joined the domain) as well as any new data written by the <a class="el" href="group__DDSWriterModule.html#gafb74fa54675abe1bfb2090265bf4d116" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS_To...">DDS_DataWriter</a> entities. There are situations where the application logic may require the application to wait until all "historical" data is received. This is the purpose of the <a class="el" href="group__DDSReaderModule.html#gab116e48bb072f448fbf531bf9fd98cc8" title="Waits until all &quot;historical&quot; data is received for DDS_DataReader entities that have a non-VOLATILE Du...">DDS_DataReader_wait_for_historical_data</a> operations. </p>
<p><a class="el" href="group__DDSReaderModule.html#gab116e48bb072f448fbf531bf9fd98cc8" title="Waits until all &quot;historical&quot; data is received for DDS_DataReader entities that have a non-VOLATILE Du...">DDS_DataReader_wait_for_historical_data()</a> blocks the calling thread until either all "historical" data is received, or until the duration specified by the max_wait parameter elapses, whichever happens first. It will return immediately if no DataWriters have been discovered at the time the operation is called; therefore it is advisable to make sure at least one <a class="el" href="group__DDSWriterModule.html#gafb74fa54675abe1bfb2090265bf4d116" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS_To...">DDS_DataWriter</a> has been discovered before calling this operation. (One way to do this is by using <a class="el" href="group__DDSReaderModule.html#gab74b4f6cabb251f17587cd57a42139e3" title="Accesses the DDS_SUBSCRIPTION_MATCHED_STATUS communication status.">DDS_DataReader_get_subscription_matched_status</a>.) </p>
<p>A successful completion indicates that all the "historical" data was "received"; timing out indicates that max_wait elapsed before all the data was received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">max_wait</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Timeout value. Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a9e9b16cc5337664c6c6bbd4a9ed01bcb" title="The operation timed out.">DDS_RETCODE_TIMEOUT</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gae2117c288ee652696be268cad4931b4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_acknowledge_sample_w_response </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> *&#160;</td>
          <td class="paramname"><em>sample_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__AckResponseData__t.html">DDS_AckResponseData_t</a> *&#160;</td>
          <td class="paramname"><em>response_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acknowledge a single sample explicitly. </p>
<p>Applicable only when <a class="el" href="structDDS__ReliabilityQosPolicy.html#aa56c90c279a6e4f0bcedcdedda9e125e" title="Kind of reliable acknowledgment.">DDS_ReliabilityQosPolicy::acknowledgment_kind</a> = <a class="el" href="group__DDSReliabilityQosModule.html#gga288de7529d06055c9edd3900a73f3dcaa48e6db746c88202c67f9801d15ba1477" title="Samples are acknowledged after the subscribing application explicitly calls acknowledge on the sample...">DDS_APPLICATION_EXPLICIT_ACKNOWLEDGMENT_MODE</a> </p>
<p>A call to this function does not necessarily trigger the sending of an AppAck RTPS message from the DataReader to the DataWriter. How and when AppAck messages are sent can be configured using the QoS values <a class="el" href="structDDS__RtpsReliableReaderProtocol__t.html#acd2d05d1562c1adf755fbb1eccb6b62b" title="The minimum number of samples acknowledged by one application-level acknowledgment message...">DDS_RtpsReliableReaderProtocol_t::samples_per_app_ack</a> and <a class="el" href="structDDS__RtpsReliableReaderProtocol__t.html#a9c87af40207de4455bdaddf7789b956b" title="The period at which application-level acknowledgment messages are sent.">DDS_RtpsReliableReaderProtocol_t::app_ack_period</a>. </p>
<p>The maximum length of the response is configured using <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a22e6ff9fcd67631949d80ff737a7d514" title="Maximum length of application-level acknowledgment response data.">DDS_DataReaderResourceLimitsQosPolicy::max_app_ack_response_length</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">sample_info</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> identifying the sample being acknowledged. </td></tr>
    <tr><td class="paramname">response_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Response data sent to <a class="el" href="group__DDSWriterModule.html#gafb74fa54675abe1bfb2090265bf4d116" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS_To...">DDS_DataWriter</a> upon acknowledgment (via <a class="el" href="structDDS__DataWriterListener.html#a4cf6b49fdea9b938ae7508b983bd7e02" title="Called when a sample is application-acknowledged.">DDS_DataWriterListener::on_application_acknowledgment</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ce922a98455ffb9dd25a95ed29f1f8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_acknowledge_all_w_response </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__AckResponseData__t.html">DDS_AckResponseData_t</a> *&#160;</td>
          <td class="paramname"><em>response_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acknowledge all previously accessed samples. </p>
<p>Applicable only when <a class="el" href="structDDS__ReliabilityQosPolicy.html#aa56c90c279a6e4f0bcedcdedda9e125e" title="Kind of reliable acknowledgment.">DDS_ReliabilityQosPolicy::acknowledgment_kind</a> = <a class="el" href="group__DDSReliabilityQosModule.html#gga288de7529d06055c9edd3900a73f3dcaa48e6db746c88202c67f9801d15ba1477" title="Samples are acknowledged after the subscribing application explicitly calls acknowledge on the sample...">DDS_APPLICATION_EXPLICIT_ACKNOWLEDGMENT_MODE</a> </p>
<p>A call to this function does not necessarily trigger the sending of an AppAck RTPS message from the DataReader to the DataWriter. How and when AppAck messages are sent can be configured using the QoS values <a class="el" href="structDDS__RtpsReliableReaderProtocol__t.html#acd2d05d1562c1adf755fbb1eccb6b62b" title="The minimum number of samples acknowledged by one application-level acknowledgment message...">DDS_RtpsReliableReaderProtocol_t::samples_per_app_ack</a> and <a class="el" href="structDDS__RtpsReliableReaderProtocol__t.html#a9c87af40207de4455bdaddf7789b956b" title="The period at which application-level acknowledgment messages are sent.">DDS_RtpsReliableReaderProtocol_t::app_ack_period</a>. </p>
<p>The maximum length of the response is configured using <a class="el" href="structDDS__DataReaderResourceLimitsQosPolicy.html#a22e6ff9fcd67631949d80ff737a7d514" title="Maximum length of application-level acknowledgment response data.">DDS_DataReaderResourceLimitsQosPolicy::max_app_ack_response_length</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">response_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Response data sent to <a class="el" href="group__DDSWriterModule.html#gafb74fa54675abe1bfb2090265bf4d116" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS_To...">DDS_DataWriter</a> upon acknowledgment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b7f1b1f22a95d3292c85ea3babfeb62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_acknowledge_sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__SampleInfo.html">DDS_SampleInfo</a> *&#160;</td>
          <td class="paramname"><em>sample_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acknowledge a single sample explicitly. </p>
<p>Applicable only when <a class="el" href="structDDS__ReliabilityQosPolicy.html#aa56c90c279a6e4f0bcedcdedda9e125e" title="Kind of reliable acknowledgment.">DDS_ReliabilityQosPolicy::acknowledgment_kind</a> = <a class="el" href="group__DDSReliabilityQosModule.html#gga288de7529d06055c9edd3900a73f3dcaa48e6db746c88202c67f9801d15ba1477" title="Samples are acknowledged after the subscribing application explicitly calls acknowledge on the sample...">DDS_APPLICATION_EXPLICIT_ACKNOWLEDGMENT_MODE</a> </p>
<p>A call to this function does not necessarily trigger the sending of an AppAck RTPS message from the DataReader to the DataWriter. How and when AppAck messages are sent can be configured using the QoS values <a class="el" href="structDDS__RtpsReliableReaderProtocol__t.html#acd2d05d1562c1adf755fbb1eccb6b62b" title="The minimum number of samples acknowledged by one application-level acknowledgment message...">DDS_RtpsReliableReaderProtocol_t::samples_per_app_ack</a> and <a class="el" href="structDDS__RtpsReliableReaderProtocol__t.html#a9c87af40207de4455bdaddf7789b956b" title="The period at which application-level acknowledgment messages are sent.">DDS_RtpsReliableReaderProtocol_t::app_ack_period</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">sample_info</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> identifying the sample being acknowledged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e92cfc011f888dd4c03c0a6883a0de7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_acknowledge_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acknowledge all previously accessed samples. </p>
<p>Applicable only when <a class="el" href="structDDS__ReliabilityQosPolicy.html#aa56c90c279a6e4f0bcedcdedda9e125e" title="Kind of reliable acknowledgment.">DDS_ReliabilityQosPolicy::acknowledgment_kind</a> = <a class="el" href="group__DDSReliabilityQosModule.html#gga288de7529d06055c9edd3900a73f3dcaa48e6db746c88202c67f9801d15ba1477" title="Samples are acknowledged after the subscribing application explicitly calls acknowledge on the sample...">DDS_APPLICATION_EXPLICIT_ACKNOWLEDGMENT_MODE</a> </p>
<p>A call to this function does not necessarily trigger the sending of an AppAck RTPS message from the DataReader to the DataWriter. How and when AppAck messages are sent can be configured using the QoS values <a class="el" href="structDDS__RtpsReliableReaderProtocol__t.html#acd2d05d1562c1adf755fbb1eccb6b62b" title="The minimum number of samples acknowledged by one application-level acknowledgment message...">DDS_RtpsReliableReaderProtocol_t::samples_per_app_ack</a> and <a class="el" href="structDDS__RtpsReliableReaderProtocol__t.html#a9c87af40207de4455bdaddf7789b956b" title="The period at which application-level acknowledgment messages are sent.">DDS_RtpsReliableReaderProtocol_t::app_ack_period</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac2b1864f15a7ffa34859e6eff826c499"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_get_matched_publications </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__InstanceHandleSeq.html">DDS_InstanceHandleSeq</a> *&#160;</td>
          <td class="paramname"><em>publication_handles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the list of publications currently "associated" with this <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>Matching publications are those in the same domain that have a matching <a class="el" href="group__DDSTopicEntityModule.html#ga7f615cc63381c78f535904e370cf1356" title="&lt;&lt;interface&gt;&gt; The most basic description of the data to be published and subscribed.">DDS_Topic</a>, compatible QoS common partition that the <a class="el" href="group__DDSDomainParticipantModule.html#ga1964274885335d5bcea6855f66b0bfe1" title="&lt;&lt;interface&gt;&gt; Container for all DDS_DomainEntity objects.">DDS_DomainParticipant</a> has not indicated should be "ignored" by means of the <a class="el" href="group__DDSDomainParticipantModule.html#ga2d462ae7c5b07d83ab170e551e05874c" title="Instructs RTI Connext to locally ignore a publication.">DDS_DomainParticipant_ignore_publication</a> operation. </p>
<p>The handles returned in the <code>publication_handles</code> list are the ones that are used by the RTI Connext implementation to locally identify the corresponding matched <a class="el" href="group__DDSWriterModule.html#gafb74fa54675abe1bfb2090265bf4d116" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS_To...">DDS_DataWriter</a> entities. These handles match the ones that appear in the <code>instance_handle</code> field of the <a class="el" href="structDDS__SampleInfo.html" title="Information that accompanies each sample that is read or taken.">DDS_SampleInfo</a> when reading the <a class="el" href="group__DDSPublicationBuiltInTopicModule.html#gaaaf3b75757885897768615bc8dc98586" title="Publication topic name.">DDS_PUBLICATION_TOPIC_NAME</a> builtin topic </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">publication_handles</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em>. The sequence will be grown if the sequence has ownership and the system has the corresponding resources. Use a sequence without ownership to avoid dynamic memory allocation. If the sequence is too small to store all the matches and the system can not resize the sequence, this function will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a35b4c98bf40ced0114572156c7f41893" title="RTI Connext ran out of the resources needed to complete the operation.">DDS_RETCODE_OUT_OF_RESOURCES</a>. The maximum number of matches possible is configured with <a class="el" href="structDDS__DomainParticipantResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS_DomainParticipant allocates and uses physical memory for in...">DDS_DomainParticipantResourceLimitsQosPolicy</a>. You can use a zero-maximum sequence without ownership to quickly check whether there are any matches without allocating any memory. Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a35b4c98bf40ced0114572156c7f41893" title="RTI Connext ran out of the resources needed to complete the operation.">DDS_RETCODE_OUT_OF_RESOURCES</a> if the sequence is too small and the system can not resize it, or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7403be049e90ede89f8a8c1b3a5f4e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_get_matched_publication_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__PublicationBuiltinTopicData.html">DDS_PublicationBuiltinTopicData</a> *&#160;</td>
          <td class="paramname"><em>publication_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *&#160;</td>
          <td class="paramname"><em>publication_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This operation retrieves the information on a publication that is currently "associated" with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>Matched publications are those with a matching <a class="el" href="group__DDSTopicEntityModule.html#ga7f615cc63381c78f535904e370cf1356" title="&lt;&lt;interface&gt;&gt; The most basic description of the data to be published and subscribed.">DDS_Topic</a>, compatible QoS and common partition that the application has not indicated should be "ignored" by means of the <a class="el" href="group__DDSDomainParticipantModule.html#ga2d462ae7c5b07d83ab170e551e05874c" title="Instructs RTI Connext to locally ignore a publication.">DDS_DomainParticipant_ignore_publication</a> operation. </p>
<p>The <code>publication_handle</code> must correspond to a publication currently associated with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. Otherwise, the operation will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a>. Use the operation <a class="el" href="group__DDSReaderModule.html#gac2b1864f15a7ffa34859e6eff826c499" title="Retrieve the list of publications currently &quot;associated&quot; with this DDS_DataReader.">DDS_DataReader_get_matched_publications</a> to find the publications that are currently matched with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>Note: This operation does not retrieve the following information in <a class="el" href="structDDS__PublicationBuiltinTopicData.html" title="Entry created when a DDS_DataWriter is discovered in association with its Publisher.">DDS_PublicationBuiltinTopicData</a>: </p>
<ul>
<li><a class="el" href="structDDS__PublicationBuiltinTopicData.html#aa1f6f4832c3fee58fcaa9cb7789abbe1" title="&lt;&lt;extension&gt;&gt; Type code information of the corresponding Topic">DDS_PublicationBuiltinTopicData::type_code</a> </li>
<li><a class="el" href="structDDS__PublicationBuiltinTopicData.html#a8b37e8b464591ab33b307791fff5fb01" title="&lt;&lt;extension&gt;&gt; Properties of the corresponding DataWriter.">DDS_PublicationBuiltinTopicData::property</a> </li>
</ul>
<p>The above information is available through <a class="el" href="structDDS__DataReaderListener.html#a81faf1e28859a849c45ea7931179a786" title="Handle the DDS_DATA_AVAILABLE_STATUS communication status.">DDS_DataReaderListener::on_data_available()</a> (if a reader listener is installed on the <a class="el" href="group__DDSPublicationBuiltInTopicModule.html#gab8f22ec9bdcd4385f2737f3008164ca3" title="Instantiates DataReader &lt; DDS_PublicationBuiltinTopicData &gt; .">DDS_PublicationBuiltinTopicDataDataReader</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">publication_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em>. The information to be filled in on the associated publication. Cannot be NULL. </td></tr>
    <tr><td class="paramname">publication_handle</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Handle to a specific publication associated with the <a class="el" href="group__DDSWriterModule.html#gafb74fa54675abe1bfb2090265bf4d116" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS_To...">DDS_DataWriter</a>. Cannot be NULL.. Must correspond to a publication currently associated with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c2a5ee697d6c73a68196a566708abeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_get_matched_publication_participant_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__ParticipantBuiltinTopicData.html">DDS_ParticipantBuiltinTopicData</a> *&#160;</td>
          <td class="paramname"><em>participant_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *&#160;</td>
          <td class="paramname"><em>publication_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> This operation retrieves the information on the discovered <a class="el" href="group__DDSDomainParticipantModule.html#ga1964274885335d5bcea6855f66b0bfe1" title="&lt;&lt;interface&gt;&gt; Container for all DDS_DomainEntity objects.">DDS_DomainParticipant</a> associated with the publication that is currently matching with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>Matched Participants are those with a matching <a class="el" href="group__DDSTopicEntityModule.html#ga7f615cc63381c78f535904e370cf1356" title="&lt;&lt;interface&gt;&gt; The most basic description of the data to be published and subscribed.">DDS_Topic</a>, compatible QoS and common partition that the application has not indicated should be "ignored" by means of the <a class="el" href="group__DDSDomainParticipantModule.html#ga2d462ae7c5b07d83ab170e551e05874c" title="Instructs RTI Connext to locally ignore a publication.">DDS_DomainParticipant_ignore_publication</a> operation. </p>
<p>The <code>publication_handle</code> must correspond to a publication currently associated with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. Otherwise, the operation will fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91ad8661c51c31806806aaf10dca3c80f6c" title="Illegal parameter value.">DDS_RETCODE_BAD_PARAMETER</a>. The operation may also fail with <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a3a638871d5b4174c32c8d2880f1f6770" title="A pre-condition for the operation was not met.">DDS_RETCODE_PRECONDITION_NOT_MET</a> if the publication corresponds to the same <a class="el" href="group__DDSDomainParticipantModule.html#ga1964274885335d5bcea6855f66b0bfe1" title="&lt;&lt;interface&gt;&gt; Container for all DDS_DomainEntity objects.">DDS_DomainParticipant</a> that the DataReader belongs to. Use the operation <a class="el" href="group__DDSReaderModule.html#gac2b1864f15a7ffa34859e6eff826c499" title="Retrieve the list of publications currently &quot;associated&quot; with this DDS_DataReader.">DDS_DataReader_get_matched_publications</a> to find the publications that are currently matched with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>Note: This operation does not retrieve the <a class="el" href="structDDS__ParticipantBuiltinTopicData.html#a91f02a3edca55b3f7787301c18e0e287" title="&lt;&lt;extension&gt;&gt; Name value pair properties to be stored with domain participant">DDS_ParticipantBuiltinTopicData::property</a>. </p>
<p>The above information is available through <a class="el" href="structDDS__DataReaderListener.html#a81faf1e28859a849c45ea7931179a786" title="Handle the DDS_DATA_AVAILABLE_STATUS communication status.">DDS_DataReaderListener::on_data_available()</a> (if a reader listener is installed on the <a class="el" href="group__DDSPublicationBuiltInTopicModule.html#gab8f22ec9bdcd4385f2737f3008164ca3" title="Instantiates DataReader &lt; DDS_PublicationBuiltinTopicData &gt; .">DDS_PublicationBuiltinTopicDataDataReader</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">participant_data</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em>. The information to be filled in on the associated participant. Cannot be NULL. </td></tr>
    <tr><td class="paramname">publication_handle</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Handle to a specific publication associated with a <a class="el" href="group__DDSWriterModule.html#gafb74fa54675abe1bfb2090265bf4d116" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS_To...">DDS_DataWriter</a>. Cannot be NULL.. Must correspond to a publication currently associated with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga098faba88f06eb848d0229a37cc608e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSTopicEntityModule.html#ga89cd495d744b91edd5d6af4b276322c4">DDS_TopicDescription</a>* DDS_DataReader_get_topicdescription </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="group__DDSTopicEntityModule.html#ga89cd495d744b91edd5d6af4b276322c4" title="&lt;&lt;interface&gt;&gt; Base class for DDS_Topic, DDS_ContentFilteredTopic, and DDS_MultiTopic.">DDS_TopicDescription</a> associated with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>Returns that same <a class="el" href="group__DDSTopicEntityModule.html#ga89cd495d744b91edd5d6af4b276322c4" title="&lt;&lt;interface&gt;&gt; Base class for DDS_Topic, DDS_ContentFilteredTopic, and DDS_MultiTopic.">DDS_TopicDescription</a> that was used to create the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSTopicEntityModule.html#ga89cd495d744b91edd5d6af4b276322c4" title="&lt;&lt;interface&gt;&gt; Base class for DDS_Topic, DDS_ContentFilteredTopic, and DDS_MultiTopic.">DDS_TopicDescription</a> associated with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga87dc984879b87f0271016e826b26ee31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSSubscriberModule.html#ga2755712602505786a23baef5a42d6782">DDS_Subscriber</a>* DDS_DataReader_get_subscriber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="group__DDSSubscriberModule.html#ga2755712602505786a23baef5a42d6782" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS_Subscriber</a> to which the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> belongs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSSubscriberModule.html#ga2755712602505786a23baef5a42d6782" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS_Subscriber</a> to which the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> belongs. </dd></dl>

</div>
</div>
<a class="anchor" id="gac1a7bcba6875d06440998cf577e8aec4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_get_sample_rejected_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleRejectedStatus.html">DDS_SampleRejectedStatus</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa9e9d4b8dec6fa48c37aa32aa51ad2dd0" title="A (received) sample has been rejected.">DDS_SAMPLE_REJECTED_STATUS</a> communication status. </p>
<p>This also resets the status so that it is no longer considered changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">status</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__SampleRejectedStatus.html" title="DDS_SAMPLE_REJECTED_STATUS">DDS_SampleRejectedStatus</a> to be filled in. Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaceda17acaead9acca331d3902f8da17c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_get_liveliness_changed_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__LivelinessChangedStatus.html">DDS_LivelinessChangedStatus</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa267a5ad100a1e87c372752b6900a9965" title="The liveliness of one or more DDS_DataWriter that were writing instances read through the DDS_DataRea...">DDS_LIVELINESS_CHANGED_STATUS</a> communication status. </p>
<p>This also resets the status so that it is no longer considered changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">status</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__LivelinessChangedStatus.html" title="DDS_LIVELINESS_CHANGED_STATUS">DDS_LivelinessChangedStatus</a> to be filled in. Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad02eeca6be023a820a682dd1f93b9d3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_get_requested_deadline_missed_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html">DDS_RequestedDeadlineMissedStatus</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fab4c627eaeae35f65790cc564208ca2e6" title="The deadline that the DDS_DataReader was expecting through its DDS_DeadlineQosPolicy was not respecte...">DDS_REQUESTED_DEADLINE_MISSED_STATUS</a> communication status. </p>
<p>This also resets the status so that it is no longer considered changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">status</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__RequestedDeadlineMissedStatus.html" title="DDS_REQUESTED_DEADLINE_MISSED_STATUS">DDS_RequestedDeadlineMissedStatus</a> to be filled in. Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga590d7b383341749ed2b819252c89c945"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_get_requested_incompatible_qos_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html">DDS_RequestedIncompatibleQosStatus</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa126ff1b38cdfc905353cb2dac57b6796" title="A QosPolicy value was incompatible with what is offered.">DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS</a> communication status. </p>
<p>This also resets the status so that it is no longer considered changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">status</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__RequestedIncompatibleQosStatus.html" title="DDS_REQUESTED_INCOMPATIBLE_QOS_STATUS">DDS_RequestedIncompatibleQosStatus</a> to be filled in. Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab74b4f6cabb251f17587cd57a42139e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_get_subscription_matched_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SubscriptionMatchedStatus.html">DDS_SubscriptionMatchedStatus</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26faceedf0fda6d695b4fabd8ac0af807bb1" title="The DDS_DataReader has found DDS_DataWriter that matches the DDS_Topic and has compatible QoS...">DDS_SUBSCRIPTION_MATCHED_STATUS</a> communication status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">status</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__SubscriptionMatchedStatus.html" title="DDS_SUBSCRIPTION_MATCHED_STATUS">DDS_SubscriptionMatchedStatus</a> to be filled in. Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaef247058f61fe47bcb621fd33bf98d83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_get_sample_lost_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__SampleLostStatus.html">DDS_SampleLostStatus</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the <a class="el" href="group__DDSStatusTypesModule.html#ggaa99b5585ecdf8c5f93ac3108439ad26fa0114c506e39a7fef5a42587556fc812f" title="A sample has been lost (i.e. was never received).">DDS_SAMPLE_LOST_STATUS</a> communication status. </p>
<p>This also resets the status so that it is no longer considered changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">status</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__SampleLostStatus.html" title="DDS_SAMPLE_LOST_STATUS">DDS_SampleLostStatus</a> to be filled in. Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga93a94e1fd1aafc39f3c7e806d1d10f0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_get_datareader_cache_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__DataReaderCacheStatus.html">DDS_DataReaderCacheStatus</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Get the datareader cache status for this reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">status</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__DataReaderCacheStatus.html" title="&lt;&lt;extension&gt;&gt; The status of the reader&#39;s cache.">DDS_DataReaderCacheStatus</a> to be filled in. Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gac7a347d2add85ece49739512970972c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_get_datareader_protocol_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__DataReaderProtocolStatus.html">DDS_DataReaderProtocolStatus</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Get the datareader protocol status for this reader. </p>
<p>This also resets the status so that it is no longer considered changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">status</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__DataReaderProtocolStatus.html" title="&lt;&lt;extension&gt;&gt; The status of a reader&#39;s internal protocol related metrics, like the number of samp...">DDS_DataReaderProtocolStatus</a> to be filled in. Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga91424a08c0885e7e82802b8f0f59d552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_get_matched_publication_datareader_protocol_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__DataReaderProtocolStatus.html">DDS_DataReaderProtocolStatus</a> *&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__DDSUserDataModule.html#ga2cd7a0bbf330870ab93f94e05c92318b">DDS_InstanceHandle_t</a> *&#160;</td>
          <td class="paramname"><em>publication_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Get the datareader protocol status for this reader, per matched publication identified by the publication_handle. </p>
<p>This also resets the status so that it is no longer considered changed. </p>
<p>Note: Status for a remote entity is only kept while the entity is alive. Once a remote entity is no longer alive, its status is deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">status</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em>. The information to be filled in on the associated publication. Cannot be NULL. </td></tr>
    <tr><td class="paramname">publication_handle</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em>. Handle to a specific publication associated with the <a class="el" href="group__DDSWriterModule.html#gafb74fa54675abe1bfb2090265bf4d116" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS_To...">DDS_DataWriter</a>. Cannot be NULL.. Must correspond to a publication currently associated with the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a2e310a02f1ef7b8a7e5b5f5029b154f9" title="Operation invoked on a DDS_Entity that is not yet enabled.">DDS_RETCODE_NOT_ENABLED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac6edf6c1cb03f06c3647ee838b279de8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_set_qos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the reader QoS. </p>
<p>This operation modifies the QoS of the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>The <a class="el" href="structDDS__DataReaderQos.html#a24dfd6a672faaa0d65047747f21d91ad" title="User data policy, USER_DATA.">DDS_DataReaderQos::user_data</a>, <a class="el" href="structDDS__DataReaderQos.html#a490674322e9365f8fa7c1240d84371e8" title="Deadline policy, DEADLINE.">DDS_DataReaderQos::deadline</a>, <a class="el" href="structDDS__DataReaderQos.html#a9dcd621be2055fbaf344782537385c1e" title="Latency budget policy, LATENCY_BUDGET.">DDS_DataReaderQos::latency_budget</a>, <a class="el" href="structDDS__DataReaderQos.html#aa0a89101de5b9d0028f04877139262cf" title="Time-based filter policy, TIME_BASED_FILTER.">DDS_DataReaderQos::time_based_filter</a>, <a class="el" href="structDDS__DataReaderQos.html#a97c41d195de10ea5645cb8e34d938c8b" title="Reader data lifecycle policy, READER_DATA_LIFECYCLE.">DDS_DataReaderQos::reader_data_lifecycle</a> can be changed. The other policies are immutable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">qos</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The <a class="el" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a> to be set to. Policies must be consistent. Immutable policies cannot be changed after <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> is enabled. The special value <a class="el" href="group__DDSSubscriberModule.html#gabf8d3b7aa9e72443354af9aa5bc02f81" title="Special value for creating data reader with default QoS.">DDS_DATAREADER_QOS_DEFAULT</a> can be used to indicate that the QoS of the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a> should be changed to match the current default <a class="el" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a> set in the <a class="el" href="group__DDSSubscriberModule.html#ga2755712602505786a23baef5a42d6782" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS_Subscriber</a>. Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a6e50f4433cf3e47737f4d317d0a4a707" title="Application attempted to modify an immutable QoS policy.">DDS_RETCODE_IMMUTABLE_POLICY</a>, or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a5128152d6418ba270e44c5de487ce4c0" title="Application specified a set of QoS policies that are not consistent with each other.">DDS_RETCODE_INCONSISTENT_POLICY</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a> for rules on consistency among QoS </dd>
<dd>
<a class="el" href="group__DDSEntityModule.html#Entity_set_qos">set_qos (abstract)</a> </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gac6edf6c1cb03f06c3647ee838b279de8" title="Sets the reader QoS.">DDS_DataReader_set_qos</a> </dd>
<dd>
<a class="el" href="structDDS__Listener.html#SharedEACallbackRules">Operations Allowed in Listener Callbacks</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga82d9dd690919ee72be4c26d59e66a567"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_set_qos_with_profile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>library_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>profile_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Change the QoS of this reader using the input XML QoS profile. </p>
<p>This operation modifies the QoS of the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </p>
<p>The <a class="el" href="structDDS__DataReaderQos.html#a24dfd6a672faaa0d65047747f21d91ad" title="User data policy, USER_DATA.">DDS_DataReaderQos::user_data</a>, <a class="el" href="structDDS__DataReaderQos.html#a490674322e9365f8fa7c1240d84371e8" title="Deadline policy, DEADLINE.">DDS_DataReaderQos::deadline</a>, <a class="el" href="structDDS__DataReaderQos.html#a9dcd621be2055fbaf344782537385c1e" title="Latency budget policy, LATENCY_BUDGET.">DDS_DataReaderQos::latency_budget</a>, <a class="el" href="structDDS__DataReaderQos.html#aa0a89101de5b9d0028f04877139262cf" title="Time-based filter policy, TIME_BASED_FILTER.">DDS_DataReaderQos::time_based_filter</a>, <a class="el" href="structDDS__DataReaderQos.html#a97c41d195de10ea5645cb8e34d938c8b" title="Reader data lifecycle policy, READER_DATA_LIFECYCLE.">DDS_DataReaderQos::reader_data_lifecycle</a> can be changed. The other policies are immutable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">library_name</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Library name containing the XML QoS profile. If library_name is null RTI Connext will use the default library (see <a class="el" href="group__DDSSubscriberModule.html#ga789331ac5388bbf0d3f3e997bccef2dc" title="&lt;&lt;extension&gt;&gt; Sets the default XML library for a DDS_Subscriber.">DDS_Subscriber_set_default_library</a>). </td></tr>
    <tr><td class="paramname">profile_name</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> XML QoS Profile name. If profile_name is null RTI Connext will use the default profile (see <a class="el" href="group__DDSSubscriberModule.html#ga7407d3352e9621c7b2ead6009c59d568" title="&lt;&lt;extension&gt;&gt; Sets the default XML profile for a DDS_Subscriber.">DDS_Subscriber_set_default_profile</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a>, <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a6e50f4433cf3e47737f4d317d0a4a707" title="Application attempted to modify an immutable QoS policy.">DDS_RETCODE_IMMUTABLE_POLICY</a>, or <a class="el" href="group__DDSReturnTypesModule.html#gga73f148aaf96b5f6f9fc630b7cfeb0c91a5128152d6418ba270e44c5de487ce4c0" title="Application specified a set of QoS policies that are not consistent with each other.">DDS_RETCODE_INCONSISTENT_POLICY</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a> for rules on consistency among QoS </dd>
<dd>
<a class="el" href="group__DDSReaderModule.html#gac6edf6c1cb03f06c3647ee838b279de8" title="Sets the reader QoS.">DDS_DataReader_set_qos</a> </dd>
<dd>
<a class="el" href="structDDS__Listener.html#SharedEACallbackRules">Operations Allowed in Listener Callbacks</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae5b1cfff484564089701bc91eb3edafe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_get_qos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__DataReaderQos.html">DDS_DataReaderQos</a> *&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the reader QoS. </p>
<p>This function may potentially allocate memory depending on the sequences contained in some QoS policies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">qos</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> The <a class="el" href="structDDS__DataReaderQos.html" title="QoS policies supported by a DDS_DataReader entity.">DDS_DataReaderQos</a> to be filled up. Cannot be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSEntityModule.html#Entity_get_qos">get_qos (abstract)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6af5ac237d6c16988546befcbbc53a27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_set_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSStatusTypesModule.html#ga4d99a5cbe5e3451400717c8358be6377">DDS_StatusMask</a>&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the reader listener. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">l</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> to set to </td></tr>
    <tr><td class="paramname">mask</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> <a class="el" href="group__DDSStatusTypesModule.html#ga4d99a5cbe5e3451400717c8358be6377" title="A bit-mask (list) of concrete status types, i.e. DDS_StatusKind[].">DDS_StatusMask</a> associated with the <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a>. The callback function on the listener cannot be NULL if the corresponding status is turned on in the <code>mask</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSEntityModule.html#Entity_set_listener">set_listener (abstract)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gade4c138c7861e56d4fd03372031c9ae3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> DDS_DataReader_get_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the reader listener. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> of the <a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS_DataReader</a>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#ga39c40a4095755948fc68b0cb906dd5dd" title="&lt;&lt;extension&gt;&gt; Get the reader listener.">DDS_DataReader_get_listenerX</a> </dd>
<dd>
Entity_get_listener </dd></dl>

</div>
</div>
<a class="anchor" id="ga39c40a4095755948fc68b0cb906dd5dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSReturnTypesModule.html#ga73f148aaf96b5f6f9fc630b7cfeb0c91">DDS_ReturnCode_t</a> DDS_DataReader_get_listenerX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSReaderModule.html#ga49ce0cab2c1b60ddee4784a1432577a4">DDS_DataReader</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structDDS__DataReaderListener.html">DDS_DataReaderListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> Get the reader listener. </p>
<p>An alternative form of get_listener that fills in an existing listener structure rather than returning one on the stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> Cannot be NULL. </td></tr>
    <tr><td class="paramname">listener</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_inout">&lt;&lt;inout&gt;&gt;</a></em> <a class="el" href="structDDS__DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS_Listener for reader status.">DDS_DataReaderListener</a> structure to be filled up. Cannot be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the <a class="el" href="group__DDSReturnTypesModule.html#DDSReturnTypesModule_std_retcodes">Standard Return Codes</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__DDSReaderModule.html#gade4c138c7861e56d4fd03372031c9ae3" title="Get the reader listener.">DDS_DataReader_get_listener</a> </dd>
<dd>
Entity_get_listener </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Connext C API Version 5.2.3</A>
Copyright &copy; Wed Apr 27 2016 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
