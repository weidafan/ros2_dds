<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>RTI TCP Transport: NDDS_Transport_TCPv4_Property_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RTI TCP Transport
   &#160;<span id="projectnumber">Version 5.2.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2-20120808 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structNDDS__Transport__TCPv4__Property__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">NDDS_Transport_TCPv4_Property_t Struct Reference<div class="ingroups"><a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html">TCP Transport Plugin API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Configurable TCP Transport-Plugin properties.  
 <a href="structNDDS__Transport__TCPv4__Property__t.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:afb5adf55222f80b6a3026f8072be9263"><td class="memItemLeft" align="right" valign="top">struct <a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structNDDS__Transport__Property__t.html">NDDS_Transport_Property_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#afb5adf55222f80b6a3026f8072be9263">parent</a></td></tr>
<tr class="memdesc:afb5adf55222f80b6a3026f8072be9263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic properties of all transport plugins.  <a href="#afb5adf55222f80b6a3026f8072be9263"></a><br/></td></tr>
<tr class="separator:afb5adf55222f80b6a3026f8072be9263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f62222236d473546994c2e5da687e0c"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a1f62222236d473546994c2e5da687e0c">send_socket_buffer_size</a></td></tr>
<tr class="memdesc:a1f62222236d473546994c2e5da687e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of the send buffer of a socket used for sending.  <a href="#a1f62222236d473546994c2e5da687e0c"></a><br/></td></tr>
<tr class="separator:a1f62222236d473546994c2e5da687e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6493846a2fdc43a3549d6f2037f030d"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#ab6493846a2fdc43a3549d6f2037f030d">recv_socket_buffer_size</a></td></tr>
<tr class="memdesc:ab6493846a2fdc43a3549d6f2037f030d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of the receive buffer of a socket used for receiving.  <a href="#ab6493846a2fdc43a3549d6f2037f030d"></a><br/></td></tr>
<tr class="separator:ab6493846a2fdc43a3549d6f2037f030d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ea76f0ef421554dd0c573ca0a3c8f4"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a89ea76f0ef421554dd0c573ca0a3c8f4">ignore_loopback_interface</a></td></tr>
<tr class="memdesc:a89ea76f0ef421554dd0c573ca0a3c8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents the transport plugin from using the IP loopback interface.  <a href="#a89ea76f0ef421554dd0c573ca0a3c8f4"></a><br/></td></tr>
<tr class="separator:a89ea76f0ef421554dd0c573ca0a3c8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7133460aa84f385577739ebd55635e"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a8e7133460aa84f385577739ebd55635e">ignore_nonrunning_interfaces</a></td></tr>
<tr class="memdesc:a8e7133460aa84f385577739ebd55635e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents the transport plugin from using a network interface that is not reported as RUNNING by the operating system.  <a href="#a8e7133460aa84f385577739ebd55635e"></a><br/></td></tr>
<tr class="separator:a8e7133460aa84f385577739ebd55635e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b105995d3d96083ae548a1f058416b"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a52b105995d3d96083ae548a1f058416b">transport_priority_mask</a></td></tr>
<tr class="memdesc:a52b105995d3d96083ae548a1f058416b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for the transport priority field.  <a href="#a52b105995d3d96083ae548a1f058416b"></a><br/></td></tr>
<tr class="separator:a52b105995d3d96083ae548a1f058416b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007cb73aa6ec419df850fd9803c6a3c7"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a007cb73aa6ec419df850fd9803c6a3c7">transport_priority_mapping_low</a></td></tr>
<tr class="memdesc:a007cb73aa6ec419df850fd9803c6a3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the low value of the output range to IPv4 TOS.  <a href="#a007cb73aa6ec419df850fd9803c6a3c7"></a><br/></td></tr>
<tr class="separator:a007cb73aa6ec419df850fd9803c6a3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f90cc42da518f74e9c7f628a23c1a0"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#af2f90cc42da518f74e9c7f628a23c1a0">transport_priority_mapping_high</a></td></tr>
<tr class="memdesc:af2f90cc42da518f74e9c7f628a23c1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the high value of the output range to IPv4 TOS.  <a href="#af2f90cc42da518f74e9c7f628a23c1a0"></a><br/></td></tr>
<tr class="separator:af2f90cc42da518f74e9c7f628a23c1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b68c157ad51671e31af25de77b86d5"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a90b68c157ad51671e31af25de77b86d5">server_socket_backlog</a></td></tr>
<tr class="memdesc:a90b68c157ad51671e31af25de77b86d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines what is the maximum length of the queue of pending connections.  <a href="#a90b68c157ad51671e31af25de77b86d5"></a><br/></td></tr>
<tr class="separator:a90b68c157ad51671e31af25de77b86d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3d66f580609cdf8437b0b4c3ae509c"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structNDDS__Transport__Address__t.html">NDDS_Transport_Address_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a3f3d66f580609cdf8437b0b4c3ae509c">public_address</a></td></tr>
<tr class="memdesc:a3f3d66f580609cdf8437b0b4c3ae509c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public locator (IP address and port) of the transport instantiation.  <a href="#a3f3d66f580609cdf8437b0b4c3ae509c"></a><br/></td></tr>
<tr class="separator:a3f3d66f580609cdf8437b0b4c3ae509c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b6fc42dae821b8261b4a1f8b6fe2ee"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a53b6fc42dae821b8261b4a1f8b6fe2ee">bind_interface_address</a></td></tr>
<tr class="memdesc:a53b6fc42dae821b8261b4a1f8b6fe2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface IP address for the transport sockets.  <a href="#a53b6fc42dae821b8261b4a1f8b6fe2ee"></a><br/></td></tr>
<tr class="separator:a53b6fc42dae821b8261b4a1f8b6fe2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84999d210a2a16e2b782b6caa164cfd5"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a84999d210a2a16e2b782b6caa164cfd5">server_bind_port</a></td></tr>
<tr class="memdesc:a84999d210a2a16e2b782b6caa164cfd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private IP port (inside the LAN) used by the transport to accept TCP connections.  <a href="#a84999d210a2a16e2b782b6caa164cfd5"></a><br/></td></tr>
<tr class="separator:a84999d210a2a16e2b782b6caa164cfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a205229c4819deb28e9883201e5570a"><td class="memItemLeft" align="right" valign="top">struct <br class="typebreak"/>
<a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structTransportAllocationSettings__t.html">TransportAllocationSettings_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a5a205229c4819deb28e9883201e5570a">read_buffer_allocation</a></td></tr>
<tr class="memdesc:a5a205229c4819deb28e9883201e5570a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation settings applied to read buffers.  <a href="#a5a205229c4819deb28e9883201e5570a"></a><br/></td></tr>
<tr class="separator:a5a205229c4819deb28e9883201e5570a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae84d492aa34d436f1673312c6bd649"><td class="memItemLeft" align="right" valign="top">struct <br class="typebreak"/>
<a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structTransportAllocationSettings__t.html">TransportAllocationSettings_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a2ae84d492aa34d436f1673312c6bd649">write_buffer_allocation</a></td></tr>
<tr class="memdesc:a2ae84d492aa34d436f1673312c6bd649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation settings applied to buffers used for asynchronous (nonblocking) write.  <a href="#a2ae84d492aa34d436f1673312c6bd649"></a><br/></td></tr>
<tr class="separator:a2ae84d492aa34d436f1673312c6bd649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4a0a6451f8d1bf991f9d23b845d44c"><td class="memItemLeft" align="right" valign="top">struct <br class="typebreak"/>
<a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structTransportAllocationSettings__t.html">TransportAllocationSettings_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a1d4a0a6451f8d1bf991f9d23b845d44c">control_buffer_allocation</a></td></tr>
<tr class="memdesc:a1d4a0a6451f8d1bf991f9d23b845d44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation settings applied to buffers used to serialize and send control messages.  <a href="#a1d4a0a6451f8d1bf991f9d23b845d44c"></a><br/></td></tr>
<tr class="separator:a1d4a0a6451f8d1bf991f9d23b845d44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fcc975f3b28d0c6c04032972193025"><td class="memItemLeft" align="right" valign="top">struct <br class="typebreak"/>
<a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structTransportAllocationSettings__t.html">TransportAllocationSettings_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#aa4fcc975f3b28d0c6c04032972193025">control_message_allocation</a></td></tr>
<tr class="memdesc:aa4fcc975f3b28d0c6c04032972193025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation settings applied to control messages.  <a href="#aa4fcc975f3b28d0c6c04032972193025"></a><br/></td></tr>
<tr class="separator:aa4fcc975f3b28d0c6c04032972193025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312c4506cacac2860114bdc88b287e1f"><td class="memItemLeft" align="right" valign="top">struct <br class="typebreak"/>
<a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structTransportAllocationSettings__t.html">TransportAllocationSettings_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a312c4506cacac2860114bdc88b287e1f">control_attribute_allocation</a></td></tr>
<tr class="memdesc:a312c4506cacac2860114bdc88b287e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation settings applied to control messages attributes.  <a href="#a312c4506cacac2860114bdc88b287e1f"></a><br/></td></tr>
<tr class="separator:a312c4506cacac2860114bdc88b287e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656e0f79a74ad91a95270a92f6042054"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a656e0f79a74ad91a95270a92f6042054">force_asynchronous_send</a></td></tr>
<tr class="memdesc:a656e0f79a74ad91a95270a92f6042054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether the plugin will send data synchronously or asynchronously.  <a href="#a656e0f79a74ad91a95270a92f6042054"></a><br/></td></tr>
<tr class="separator:a656e0f79a74ad91a95270a92f6042054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac24b3e796f05379eaafb334574e225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#ga748081711416a2170e256f57ac8b4b14">NDDS_Transport_TCPv4_OnConnectionEstablishedCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a9ac24b3e796f05379eaafb334574e225">on_connection_established</a></td></tr>
<tr class="separator:a9ac24b3e796f05379eaafb334574e225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02f0469ee4e7fe03b0a3837d2b67e42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#ga8510a42efd3b75f149766d7f11d7a414">NDDS_Transport_TCPv4_OnConnectionLostCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#ae02f0469ee4e7fe03b0a3837d2b67e42">on_connection_lost</a></td></tr>
<tr class="separator:ae02f0469ee4e7fe03b0a3837d2b67e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6b4e03926d87ea386cd85cc42e0506"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a3c6b4e03926d87ea386cd85cc42e0506">max_packet_size</a></td></tr>
<tr class="memdesc:a3c6b4e03926d87ea386cd85cc42e0506"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum size of a TCP segment.  <a href="#a3c6b4e03926d87ea386cd85cc42e0506"></a><br/></td></tr>
<tr class="separator:a3c6b4e03926d87ea386cd85cc42e0506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5288b16e9e27591496baf7868185064"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#af5288b16e9e27591496baf7868185064">enable_keep_alive</a></td></tr>
<tr class="memdesc:af5288b16e9e27591496baf7868185064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the sending of KEEP_ALIVE messages in TCP.  <a href="#af5288b16e9e27591496baf7868185064"></a><br/></td></tr>
<tr class="separator:af5288b16e9e27591496baf7868185064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53eab1fcf5d1c3105702bd7b26859d94"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a53eab1fcf5d1c3105702bd7b26859d94">keep_alive_time</a></td></tr>
<tr class="memdesc:a53eab1fcf5d1c3105702bd7b26859d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the interval of inactivity in seconds that causes TCP to generate a KEEP_ALIVE message.  <a href="#a53eab1fcf5d1c3105702bd7b26859d94"></a><br/></td></tr>
<tr class="separator:a53eab1fcf5d1c3105702bd7b26859d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b2110a8ec14156c42b4cf502ee71cf"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a99b2110a8ec14156c42b4cf502ee71cf">keep_alive_interval</a></td></tr>
<tr class="memdesc:a99b2110a8ec14156c42b4cf502ee71cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the interval in seconds between KEEP_ALIVE retries.  <a href="#a99b2110a8ec14156c42b4cf502ee71cf"></a><br/></td></tr>
<tr class="separator:a99b2110a8ec14156c42b4cf502ee71cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a96ef27a5ada7806654bb6251ccd1a5"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a7a96ef27a5ada7806654bb6251ccd1a5">keep_alive_retry_count</a></td></tr>
<tr class="memdesc:a7a96ef27a5ada7806654bb6251ccd1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of KEEP_ALIVE retries before dropping the connection.  <a href="#a7a96ef27a5ada7806654bb6251ccd1a5"></a><br/></td></tr>
<tr class="separator:a7a96ef27a5ada7806654bb6251ccd1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ae104dcc6835f092a94c96f1f27901"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a84ae104dcc6835f092a94c96f1f27901">user_timeout</a></td></tr>
<tr class="separator:a84ae104dcc6835f092a94c96f1f27901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b9287fc8515b3c7fd22be07e852542"><td class="memItemLeft" align="right" valign="top">struct <br class="typebreak"/>
<a class="el" href="structNDDS__Transport__TCPv4__ConnectionLivelinessSettings__t.html">NDDS_Transport_TCPv4_ConnectionLivelinessSettings_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a79b9287fc8515b3c7fd22be07e852542">connection_liveliness_settings</a></td></tr>
<tr class="separator:a79b9287fc8515b3c7fd22be07e852542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ea40d1a341a4a99d0bcf0daf1c6433"><td class="memItemLeft" align="right" valign="top">struct <br class="typebreak"/>
<a class="el" href="structNDDS__Transport__TCPv4__EventThreadSettings__t.html">NDDS_Transport_TCPv4_EventThreadSettings_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#ae5ea40d1a341a4a99d0bcf0daf1c6433">event_thread_settings</a></td></tr>
<tr class="separator:ae5ea40d1a341a4a99d0bcf0daf1c6433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd193ebe8e03f12b1deec8783d7ddd8"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#aecd193ebe8e03f12b1deec8783d7ddd8">disable_nagle</a></td></tr>
<tr class="memdesc:aecd193ebe8e03f12b1deec8783d7ddd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the TCP nagle algorithm.  <a href="#aecd193ebe8e03f12b1deec8783d7ddd8"></a><br/></td></tr>
<tr class="separator:aecd193ebe8e03f12b1deec8783d7ddd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26738778d5d08a5e582ed1661cef891b"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a26738778d5d08a5e582ed1661cef891b">logging_verbosity_bitmap</a></td></tr>
<tr class="memdesc:a26738778d5d08a5e582ed1661cef891b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitmap that specifies the verbosity of log messages from the transport.  <a href="#a26738778d5d08a5e582ed1661cef891b"></a><br/></td></tr>
<tr class="separator:a26738778d5d08a5e582ed1661cef891b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4099ee4f950ff6ef0a0c778c44ca6bb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#gaa0f28d8f619267225f5bd7fc0f50b411">NDDS_Transport_TCPv4_SocketMonitoringKind_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a4099ee4f950ff6ef0a0c778c44ca6bb8">socket_monitoring_kind</a></td></tr>
<tr class="memdesc:a4099ee4f950ff6ef0a0c778c44ca6bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the socket monitoring API used by the transport.  <a href="#a4099ee4f950ff6ef0a0c778c44ca6bb8"></a><br/></td></tr>
<tr class="separator:a4099ee4f950ff6ef0a0c778c44ca6bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871a31b2ff63aa49c20a481f813d760c"><td class="memItemLeft" align="right" valign="top">struct <br class="typebreak"/>
<a class="el" href="structNDDS__Transport__TCPv4__WindowsIOCPSettings__t.html">NDDS_Transport_TCPv4_WindowsIOCPSettings_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a871a31b2ff63aa49c20a481f813d760c">windows_iocp_settings</a></td></tr>
<tr class="memdesc:a871a31b2ff63aa49c20a481f813d760c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures I/O completion ports when <a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a4099ee4f950ff6ef0a0c778c44ca6bb8">socket_monitoring_kind</a> is set to <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#ggaa0f28d8f619267225f5bd7fc0f50b411a6db303c57d1b60d9f865c0cc68573312">NDDS_TRANSPORT_TCPV4_SOCKET_MONITORING_KIND_WINDOWS_IOCP</a>.  <a href="#a871a31b2ff63aa49c20a481f813d760c"></a><br/></td></tr>
<tr class="separator:a871a31b2ff63aa49c20a481f813d760c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7c8408af309efa848d4e5c486dccf3"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a0f7c8408af309efa848d4e5c486dccf3">outstanding_connection_cookies</a></td></tr>
<tr class="memdesc:a0f7c8408af309efa848d4e5c486dccf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of outstanding connection cookies allowed by the transport when acting as server.  <a href="#a0f7c8408af309efa848d4e5c486dccf3"></a><br/></td></tr>
<tr class="separator:a0f7c8408af309efa848d4e5c486dccf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecaf753f9168a3c6f6b2f803f44eefc"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a2ecaf753f9168a3c6f6b2f803f44eefc">outstanding_connection_cookies_life_span</a></td></tr>
<tr class="memdesc:a2ecaf753f9168a3c6f6b2f803f44eefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum lifespan (in seconds) of the cookies associated with pending connections.  <a href="#a2ecaf753f9168a3c6f6b2f803f44eefc"></a><br/></td></tr>
<tr class="separator:a2ecaf753f9168a3c6f6b2f803f44eefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e044f3f48a1c1a95a3973a9ac463fe"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a34e044f3f48a1c1a95a3973a9ac463fe">send_max_wait_sec</a></td></tr>
<tr class="memdesc:a34e044f3f48a1c1a95a3973a9ac463fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of seconds a low-level TCP sendto() function is allowed to block.  <a href="#a34e044f3f48a1c1a95a3973a9ac463fe"></a><br/></td></tr>
<tr class="separator:a34e044f3f48a1c1a95a3973a9ac463fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4647015335b32528cabe98fa16f7b7c8"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a4647015335b32528cabe98fa16f7b7c8">server_connection_negotiation_timeout</a></td></tr>
<tr class="memdesc:a4647015335b32528cabe98fa16f7b7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout (in seconds) for negotiating a connection.  <a href="#a4647015335b32528cabe98fa16f7b7c8"></a><br/></td></tr>
<tr class="separator:a4647015335b32528cabe98fa16f7b7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b26b7ece4765d342f9c0f2e3ee81520"><td class="memItemLeft" align="right" valign="top">RTI_INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a0b26b7ece4765d342f9c0f2e3ee81520">initial_handshake_timeout</a></td></tr>
<tr class="memdesc:a0b26b7ece4765d342f9c0f2e3ee81520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout (in seconds) for the initial handshake for a connection.  <a href="#a0b26b7ece4765d342f9c0f2e3ee81520"></a><br/></td></tr>
<tr class="separator:a0b26b7ece4765d342f9c0f2e3ee81520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01fe54972c6ec0f606edb6d79a5d6d9"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structRTITLS__OpenSSL__Configuration.html">RTITLS_OpenSSL_Configuration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#af01fe54972c6ec0f606edb6d79a5d6d9">tls</a></td></tr>
<tr class="memdesc:af01fe54972c6ec0f606edb6d79a5d6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">OpenSSL TLS parameters.  <a href="#af01fe54972c6ec0f606edb6d79a5d6d9"></a><br/></td></tr>
<tr class="separator:af01fe54972c6ec0f606edb6d79a5d6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Configurable TCP Transport-Plugin properties. </p>
<p>For communications within a LAN you should initialize the object as follows:</p>
<div class="fragment"><div class="line">prop.parent.classid = <a class="codeRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//group__NDDS__Transport__ClassId__t.html#ga7dad1954eb64c8c234f85d298ed21965">NDDS_TRANSPORT_CLASSID_TCPV4_LAN</a>;</div>
</div><!-- fragment --><p>If you want to use the transport in WAN configuration, you must also define the public_address and sever_bind_port:</p>
<div class="fragment"><div class="line">prop.parent.classid = <a class="codeRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//group__NDDS__Transport__ClassId__t.html#gaa5adf7348c32089e3080b0a8faa4a58a">NDDS_TRANSPORT_CLASSID_TCPV4_WAN</a>;</div>
<div class="line"><a class="code" href="group__NDDS__Transport__TCPv4__Plugin.html#gaf3e6bd586be5af37c7bd72239eda34df" title="Converts a string into a transport address suitable to be used with the TCP transport.">NDDS_Transport_TCPv4_Plugin_stringToTransportAddress</a>(</div>
<div class="line">        &amp;prop.public_address,</div>
<div class="line">        <span class="stringliteral">&quot;142.123.123.111:7890&quot;</span>,</div>
<div class="line">        0);</div>
<div class="line">prop.server_bind_port = 7400; </div>
</div><!-- fragment --><p>Remember that the public_address is the public address that your network gateway is exposing to a remote peer. It is not the local network address where the application is running. </p>
</div><h2>Field Documentation</h2>
<a class="anchor" id="afb5adf55222f80b6a3026f8072be9263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structNDDS__Transport__Property__t.html">NDDS_Transport_Property_t</a> NDDS_Transport_TCPv4_Property_t::parent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic properties of all transport plugins. </p>
<p><b>[default]</b> Refer to the property default NDDS_Transport_TCPv4_Plugin::NDDS_TRANSPORT_TCPV4_PROPERTY_DEFAULT_LAN </p>

</div>
</div>
<a class="anchor" id="a1f62222236d473546994c2e5da687e0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::send_socket_buffer_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size in bytes of the send buffer of a socket used for sending. </p>
<p>On most operating systems, setsockopt() will be called to set the SENDBUF to the value of this parameter.</p>
<p>This value must be greater than or equal to <a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structNDDS__Transport__Property__t.html#a4ab89765aee4395142e2dabc7849a46a">NDDS_Transport_Property_t::message_size_max</a> or <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#gaad48e5f8794be9406aeec8aeb7866985">NDDS_TRANSPORT_TCPV4_SOCKET_BUFFER_SIZE_OS_DEFAULT</a>.</p>
<p>The maximum value is operating system-dependent.</p>
<p><b>[default]</b> <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#gaad48e5f8794be9406aeec8aeb7866985">NDDS_TRANSPORT_TCPV4_SOCKET_BUFFER_SIZE_OS_DEFAULT</a> </p>

</div>
</div>
<a class="anchor" id="ab6493846a2fdc43a3549d6f2037f030d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::recv_socket_buffer_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size in bytes of the receive buffer of a socket used for receiving. </p>
<p>On most operating systems, setsockopt() will be called to set the RECVBUF to the value of this parameter.</p>
<p>This value must be greater than or equal to parent.message_size_max or <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#gaad48e5f8794be9406aeec8aeb7866985">NDDS_TRANSPORT_TCPV4_SOCKET_BUFFER_SIZE_OS_DEFAULT</a>.</p>
<p>The maximum value is operating-system dependent.</p>
<p><b>[default]</b> <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#gaad48e5f8794be9406aeec8aeb7866985">NDDS_TRANSPORT_TCPV4_SOCKET_BUFFER_SIZE_OS_DEFAULT</a> </p>

</div>
</div>
<a class="anchor" id="a89ea76f0ef421554dd0c573ca0a3c8f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::ignore_loopback_interface</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevents the transport plugin from using the IP loopback interface. </p>
<p>This property is ignored when parent.classid is equal to <a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//group__NDDS__Transport__ClassId__t.html#gaa5adf7348c32089e3080b0a8faa4a58a">NDDS_TRANSPORT_CLASSID_TCPV4_WAN</a>.</p>
<p>Two values are allowed: </p>
<ul>
<li>
0: Enable local traffic via this plugin. The plugin will only use and report the IP loopback interface only if there are no other network interfaces (NICs) up on the system. </li>
<li>
1: Disable local traffic via this plugin. This means "do not use the
           IP loopback interface, even if no NICs are discovered." This setting is useful when you want applications running on the same node to use a more efficient plugin like shared memory instead of the IP loopback. </li>
</ul>
<p><b>[default]</b> 1 </p>

</div>
</div>
<a class="anchor" id="a8e7133460aa84f385577739ebd55635e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::ignore_nonrunning_interfaces</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevents the transport plugin from using a network interface that is not reported as RUNNING by the operating system. </p>
<p>The transport checks the flags reported by the operating system for each network interface upon initialization. An interface which is not reported as UP will not be used. This property allows the same check to be extended to the IFF_RUNNING flag implemented by some operating systems. The RUNNING flag is defined to mean that "all resources are
allocated" and may be off if no link is detected (e.g., the network cable is unplugged).</p>
<p>Two values are allowed: </p>
<ul>
<li>
0: Do not check the RUNNING flag when enumerating interfaces, just make sure the interface is UP. </li>
<li>
1: Check the flag when enumerating interfaces, and ignore those that are not reported as RUNNING. This can be used on some operating systems to cause the transport to ignore interfaces that are enabled but not connected to the network. </li>
</ul>
<p><b>[default]</b> 1 </p>

</div>
</div>
<a class="anchor" id="a52b105995d3d96083ae548a1f058416b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::transport_priority_mask</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask for the transport priority field. </p>
<p>This is used in conjunction with <a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a007cb73aa6ec419df850fd9803c6a3c7">transport_priority_mapping_low</a> and <a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#af2f90cc42da518f74e9c7f628a23c1a0">transport_priority_mapping_high</a> to define the mapping from DDS transport priority (see <a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//group__DDSTransportPriorityQosModule.html">TRANSPORT_PRIORITY</a>) to the IPv4 TOS field. Defines a contiguous region of bits in the 32-bit transport priority value that is used to generate values for the IPv4 TOS field on an outgoing socket.</p>
<p>For example, the value 0x0000ff00 causes bits 9-16 (8 bits) to be used in the mapping. The value will be scaled from the mask range (0x0000 - 0xff00 in this case) to the range specified by low and high.</p>
<p>If the mask is set to zero, then the transport will not set IPv4 TOS for send sockets.</p>
<p><b>[default]</b> 0 </p>

</div>
</div>
<a class="anchor" id="a007cb73aa6ec419df850fd9803c6a3c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::transport_priority_mapping_low</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the low value of the output range to IPv4 TOS. </p>
<p>This is used in conjunction with <a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a52b105995d3d96083ae548a1f058416b">transport_priority_mask</a> and <a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#af2f90cc42da518f74e9c7f628a23c1a0">transport_priority_mapping_high</a> to define the mapping from DDS transport priority to the IPv4 TOS field. Defines the low value of the output range for scaling.</p>
<p>Note that IPv4 TOS is generally an 8-bit value.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a52b105995d3d96083ae548a1f058416b" title="Mask for the transport priority field.">transport_priority_mask</a></dd></dl>
<p><b>[default]</b> 0 </p>

</div>
</div>
<a class="anchor" id="af2f90cc42da518f74e9c7f628a23c1a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::transport_priority_mapping_high</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the high value of the output range to IPv4 TOS. </p>
<p>This is used in conjunction with <a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a52b105995d3d96083ae548a1f058416b">transport_priority_mask</a> and <a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a007cb73aa6ec419df850fd9803c6a3c7">transport_priority_mapping_low</a> to define the mapping from DDS transport priority to the IPv4 TOS field. Defines the high value of the output range for scaling.</p>
<p>Note that IPv4 TOS is generally an 8-bit value.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a52b105995d3d96083ae548a1f058416b" title="Mask for the transport priority field.">transport_priority_mask</a></dd></dl>
<p><b>[default]</b> 0xFF </p>

</div>
</div>
<a class="anchor" id="a90b68c157ad51671e31af25de77b86d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::server_socket_backlog</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines what is the maximum length of the queue of pending connections. </p>
<p><b>[default]</b> <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#ga2989f637e758ec0ffd3b9f91c161d3f4">NDDS_TRANSPORT_TCPV4_SERVER_SOCKET_BACKLOG_DEFAULT</a> </p>

</div>
</div>
<a class="anchor" id="a3f3d66f580609cdf8437b0b4c3ae509c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structNDDS__Transport__Address__t.html">NDDS_Transport_Address_t</a> NDDS_Transport_TCPv4_Property_t::public_address</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public locator (IP address and port) of the transport instantiation. </p>
<p>Use the function <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#gaf3e6bd586be5af37c7bd72239eda34df">NDDS_Transport_TCPv4_Plugin_stringToTransportAddress</a> to compose the transport locator from a string form.</p>
<p>This field is used and required only when <a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structNDDS__Transport__Property__t.html#ad1801e5fd5ad7bb727c3c55cc4ee9096">NDDS_Transport_Property_t::classid</a> is set to <a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//group__NDDS__Transport__ClassId__t.html#gaa5adf7348c32089e3080b0a8faa4a58a">NDDS_TRANSPORT_CLASSID_TCPV4_WAN</a>.</p>
<p>The public IP address and port are necessary to support communication over WAN that involves Network Address Translators (NATs).</p>
<p>Typically, the address is the public address of the IP router that provides access to the WAN. The port is the IP router port that is used to reach the private <a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a84999d210a2a16e2b782b6caa164cfd5">server_bind_port</a> inside the LAN from the outside.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a84999d210a2a16e2b782b6caa164cfd5" title="Private IP port (inside the LAN) used by the transport to accept TCP connections.">NDDS_Transport_TCPv4_Property_t::server_bind_port</a></dd></dl>
<p><b>[default]</b> <a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//group__NDDS__Transport__Address__t.html#ga1dc33ff13f6cc78ccd6425bc4f5d90f8">NDDS_TRANSPORT_ADDRESS_INVALID</a> </p>

</div>
</div>
<a class="anchor" id="a53b6fc42dae821b8261b4a1f8b6fe2ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* NDDS_Transport_TCPv4_Property_t::bind_interface_address</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface IP address for the transport sockets. </p>
<p>The TCP transport can be configured to bind all sockets to a specified interface.</p>
<p>If the value is NULL, the sockets will be bound to the special IP address INADDR_ANY. This address allows the sockets to receive packets destined to any of the interfaces.</p>
<p>This field should be set in multi-homed systems communicating across NAT routers.</p>
<p><b>[default]</b> NULL </p>

</div>
</div>
<a class="anchor" id="a84999d210a2a16e2b782b6caa164cfd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::server_bind_port</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Private IP port (inside the LAN) used by the transport to accept TCP connections. </p>
<pre class="fragment">    If this property is set to zero, the transport will disable the internal 
    server socket, making it impossible for external peers to connect to this node.
    In this case, the node is considered unreachable and will only communicate  
    using the asymmetric mode with other (reachable) peers.

    For WAN communication, this port must be forwarded to a public port in the 
    NAT-enabled router that connects to the outer network.
</pre><p>The server_bind_port cannot be shared among multiple participants on a common host. On most operating systems, attempting to reuse the same server_bind_port for multiple participants on a common host will result in a "port already in use" error. However, Windows systems will not recognize if the server_bind_port is already in use, and thus care must be taken to properly configure Windows systems. </p>
<pre class="fragment">    \see NDDS_Transport_TCPv4_Property_t#public_address

    &lt;B&gt;[default]&lt;/B&gt; \ref NDDS_TRANSPORT_TCPV4_DEFAULT_PORT_NUMBER</pre> 
</div>
</div>
<a class="anchor" id="a5a205229c4819deb28e9883201e5570a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structTransportAllocationSettings__t.html">TransportAllocationSettings_t</a> NDDS_Transport_TCPv4_Property_t::read_buffer_allocation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocation settings applied to read buffers. </p>
<p>These settings configure the initial number of buffers, the maximum number of buffers and the buffers to be allocated when more buffers are needed.</p>
<p><b>[default]</b> <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#ga309a653a0c5f728f78cccabb44af54aa">NDDS_TRANSPORT_TCPV4_READ_BUFFER_POOL_GROWTH_POLICY_DEFAULT</a> </p>

</div>
</div>
<a class="anchor" id="a2ae84d492aa34d436f1673312c6bd649"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structTransportAllocationSettings__t.html">TransportAllocationSettings_t</a> NDDS_Transport_TCPv4_Property_t::write_buffer_allocation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocation settings applied to buffers used for asynchronous (nonblocking) write. </p>
<p>These settings configure the initial number of buffers, the maximum number of buffers and the buffers to be allocated when more buffers are needed.</p>
<p>Note that for the write buffer pool, the default max_count is not set to unlimited. This is to avoid having a fast writer quickly exhaust all the available system memory, in case of a temporary network slowdown. When this write buffer pool reaches the maximum, the low-level send command of the transport will fail; at that point RTI Connext will take the appropriate action (retry to send or drop it), according to the application's QoS (if the transport is used for reliable communication, the data will still be sent eventually).</p>
<p><b>[default]</b> <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#ga8232156a2cadc1bf038943c8a28972aa">NDDS_TRANSPORT_TCPV4_WRITE_BUFFER_POOL_GROWTH_POLICY_DEFAULT</a> </p>

</div>
</div>
<a class="anchor" id="a1d4a0a6451f8d1bf991f9d23b845d44c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structTransportAllocationSettings__t.html">TransportAllocationSettings_t</a> NDDS_Transport_TCPv4_Property_t::control_buffer_allocation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocation settings applied to buffers used to serialize and send control messages. </p>
<p>These settings configure the initial number of buffers, the maximum number of buffers and the buffers to be allocated when more buffers are needed.</p>
<p><b>[default]</b> <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#ga9a12f5152d388e9151bf4a181a908f1e">NDDS_TRANSPORT_TCPV4_CONTROL_BUFFER_POOL_GROWTH_POLICY_DEFAULT</a> </p>

</div>
</div>
<a class="anchor" id="aa4fcc975f3b28d0c6c04032972193025"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structTransportAllocationSettings__t.html">TransportAllocationSettings_t</a> NDDS_Transport_TCPv4_Property_t::control_message_allocation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocation settings applied to control messages. </p>
<p>These settings configure the initial number of buffers, the maximum number of buffers and the buffers to be allocated when more buffers are needed.</p>
<p><b>[default]</b> <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#ga672202af4ea799b7178e9befd80f4b8f">NDDS_TRANSPORT_TCPV4_CONTROL_MESSAGE_FACTORY_GROWTH_POLICY_DEFAULT</a> </p>

</div>
</div>
<a class="anchor" id="a312c4506cacac2860114bdc88b287e1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="elRef" doxygen="dds_c_public.tag:../api_c/" href="../api_c//structTransportAllocationSettings__t.html">TransportAllocationSettings_t</a> NDDS_Transport_TCPv4_Property_t::control_attribute_allocation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocation settings applied to control messages attributes. </p>
<p>These settings configure the initial number of attributes, the maximum number of attributes and the attributes to be allocated when more attributes are needed.</p>
<p><b>[default]</b> <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#ga6e823ddafe45cd23960ff34529299e99">NDDS_TRANSPORT_TCPV4_CONTROL_MESSAGE_ATTRIBUTE_FACTORY_GROWTH_POLICY_DEFAULT</a> </p>

</div>
</div>
<a class="anchor" id="a656e0f79a74ad91a95270a92f6042054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::force_asynchronous_send</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls whether the plugin will send data synchronously or asynchronously. </p>
<p>When this parameter is set to 0, the TCP transport will attempt to send data as soon as the internal send() function is called. When it is set to 1, the transport will make a copy of the data to send and enqueue it in an internal send buffer. Data will be sent as soon as the low-level socket buffer has space.</p>
<p>Normally setting it to 1 delivers better throughput in a fast network, but will result in a longer time to recover from various TCP error conditions. Setting it to 0 may cause the low-level send() function to block until the data is physically delivered to the lower socket buffer. For an application writing data at a very fast rate, it may cause the caller thread to block if the send socket buffer is full. This could produce lower throughput in those conditions (the caller thread could prepare the next packet while waiting for the send socket buffer to become available).</p>
<p><b>[default]</b> 0 (synchronous send) </p>

</div>
</div>
<a class="anchor" id="a9ac24b3e796f05379eaafb334574e225"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#ga748081711416a2170e256f57ac8b4b14">NDDS_Transport_TCPv4_OnConnectionEstablishedCallback</a> NDDS_Transport_TCPv4_Property_t::on_connection_established</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to a function that is called whenever the plugin establish a connection with a remote peer.</p>
<p>For plugins configured to behave as servers, this function is called every time a remote client successfully establish a data communication.</p>
<p>For plugins configured to behave as clients, this function is called for every successful connection to a remote server.</p>
<p>It can be set to NULL (no notification callbacks are performed)</p>
<p>IMPORTANT: This function is called from the receive thread (both client/server side). if you don't return the control fast enough, the control protocol may be affected causing disconnections and/or delays in establishing connections with remote peers.</p>
<p><b>[default]</b> NULL </p>

</div>
</div>
<a class="anchor" id="ae02f0469ee4e7fe03b0a3837d2b67e42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#ga8510a42efd3b75f149766d7f11d7a414">NDDS_Transport_TCPv4_OnConnectionLostCallback</a> NDDS_Transport_TCPv4_Property_t::on_connection_lost</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer to a function that is called when a previously established connection with a remote peer gets closed.</p>
<p>It can be set to NULL (no notification callbacks are performed)</p>
<p>IMPORTANT: This function is called from the receive thread (both client/server side). if you don't return the control fast enough, the control protocol may be affected causing disconnections and/or delays in establishing connections with remote peers.</p>
<p><b>[default]</b> NULL </p>

</div>
</div>
<a class="anchor" id="a3c6b4e03926d87ea386cd85cc42e0506"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::max_packet_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum size of a TCP segment. </p>
<p>This parameter is only supported on Linux architectures.</p>
<p>By default, the maximum size of a TCP segment is based on the network MTU for destinations on a local network, or on a default 576 for destinations on non-local networks. This behavior can be changed by setting this parameter to a value between 1 and 65535.</p>
<p><b>[default]</b> -1 (use OS default) </p>

</div>
</div>
<a class="anchor" id="af5288b16e9e27591496baf7868185064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::enable_keep_alive</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the sending of KEEP_ALIVE messages in TCP. </p>
<p>Setting this value to 1, causes a KEEP_ALIVE packet to be sent to the remote peer if a long time passes with no other data sent or received.</p>
<p>This feature is implemented only on architectures that provide a lowlevel implementation of the TCP keep-alive feature.</p>
<p>On Windows systems, the TCP keep-alive feature can be globally enabled through the system's registry: <b>\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Tcpip\Parameters</b>.</p>
<p>Refer to MSDN documentation for more details.</p>
<p>On Solaris systems, most of the TCP keep-alive parameters can be changed though the kernel properties.</p>
<p><b>[default]</b> 0 (disabled) </p>

</div>
</div>
<a class="anchor" id="a53eab1fcf5d1c3105702bd7b26859d94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::keep_alive_time</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the interval of inactivity in seconds that causes TCP to generate a KEEP_ALIVE message. </p>
<p>This parameter is only supported on Linux architectures.</p>
<p><b>[default]</b> -1 (OS default value) </p>

</div>
</div>
<a class="anchor" id="a99b2110a8ec14156c42b4cf502ee71cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::keep_alive_interval</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the interval in seconds between KEEP_ALIVE retries. </p>
<p>This parameter is only supported on Linux architectures.</p>
<p><b>[default]</b> -1 (OS default value) </p>

</div>
</div>
<a class="anchor" id="a7a96ef27a5ada7806654bb6251ccd1a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::keep_alive_retry_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of KEEP_ALIVE retries before dropping the connection. </p>
<p>This parameter is only supported on Linux architectures.</p>
<p><b>[default]</b> -1 (use system's default). </p>

</div>
</div>
<a class="anchor" id="a84ae104dcc6835f092a94c96f1f27901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::user_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the default OS TCP User Timeout configuration. If set to a value greater than 0, it represents the TCP User Timeout in seconds.</p>
<p>Currently this feature is supported only on Linux 2.6.37 and above.</p>
<p><b>[default]</b> 0 (use system's default). </p>

</div>
</div>
<a class="anchor" id="a79b9287fc8515b3c7fd22be07e852542"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structNDDS__Transport__TCPv4__ConnectionLivelinessSettings__t.html">NDDS_Transport_TCPv4_ConnectionLivelinessSettings_t</a> NDDS_Transport_TCPv4_Property_t::connection_liveliness_settings</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configuration for the liveliness mechanism for the control connection.</p>
<p><b>[default]</b> <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#ga7fa89223a110b3fbdfd40716012978ed">NDDS_TRANSPORT_TCPV4_CONNECTION_LIVELINESS_SETTINGS_DEFAULT</a> </p>

</div>
</div>
<a class="anchor" id="ae5ea40d1a341a4a99d0bcf0daf1c6433"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structNDDS__Transport__TCPv4__EventThreadSettings__t.html">NDDS_Transport_TCPv4_EventThreadSettings_t</a> NDDS_Transport_TCPv4_Property_t::event_thread_settings</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configuration for the TCPv4 Event Thread.</p>
<p><b>[default]</b> <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#gad6e4c663487d32c48e318a035b1a2ecf">NDDS_TRANSPORT_TCPV4_EVENT_THREAD_SETTINGS_DEFAULT</a> </p>

</div>
</div>
<a class="anchor" id="aecd193ebe8e03f12b1deec8783d7ddd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::disable_nagle</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the TCP nagle algorithm. </p>
<p>When this property is set to 1, TCP segments are always sent as soon as possible, which may result in poor network utilization.</p>
<p><b>[default]</b> 0 (disabled) </p>

</div>
</div>
<a class="anchor" id="a26738778d5d08a5e582ed1661cef891b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::logging_verbosity_bitmap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitmap that specifies the verbosity of log messages from the transport. </p>
<p>Logging values: </p>
<ul>
<li>
-1 (0xffffffff): do not change the current verbosity </li>
<li>
0x00: silence </li>
<li>
0x01: errors </li>
<li>
0x02: warnings </li>
<li>
0x04: local </li>
<li>
0x08: remote </li>
<li>
0x10: period </li>
<li>
0x80: other (used for control protocol tracing) </li>
</ul>
<p>You can combine these values by logically ORing them together. For example, 0x9F means all (errors, warnings, local, remote, period, and other).</p>
<p>Note: The logging verbosity is a global property shared across multiple instances of the TCP transport. If you create a new TCP Transport instance with logging_verbosity_bitmap different than -1, the change will affect all the other instances as well.</p>
<p>The default TCP transport verbosity is errors and warnings.</p>
<p>Note: The option of 0x80 (other) is used only for tracing the internal control protocol. Since the output is very verbose, this feature is enabled only in the debug version of the TCP Transport library.</p>
<p><b>[default]</b> -1 (do not change default verbosity). </p>

</div>
</div>
<a class="anchor" id="a4099ee4f950ff6ef0a0c778c44ca6bb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#gaa0f28d8f619267225f5bd7fc0f50b411">NDDS_Transport_TCPv4_SocketMonitoringKind_t</a> NDDS_Transport_TCPv4_Property_t::socket_monitoring_kind</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the socket monitoring API used by the transport. </p>
<p><b>[default]</b> <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#ggaa0f28d8f619267225f5bd7fc0f50b411a867ad5e5bc89623ba1c808569a5511dc">NDDS_TRANSPORT_TCPV4_SOCKET_MONITORING_KIND_SELECT</a> </p>

</div>
</div>
<a class="anchor" id="a871a31b2ff63aa49c20a481f813d760c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structNDDS__Transport__TCPv4__WindowsIOCPSettings__t.html">NDDS_Transport_TCPv4_WindowsIOCPSettings_t</a> NDDS_Transport_TCPv4_Property_t::windows_iocp_settings</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures I/O completion ports when <a class="el" href="structNDDS__Transport__TCPv4__Property__t.html#a4099ee4f950ff6ef0a0c778c44ca6bb8">socket_monitoring_kind</a> is set to <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#ggaa0f28d8f619267225f5bd7fc0f50b411a6db303c57d1b60d9f865c0cc68573312">NDDS_TRANSPORT_TCPV4_SOCKET_MONITORING_KIND_WINDOWS_IOCP</a>. </p>
<p><b>[default]</b> <a class="el" href="group__NDDS__Transport__TCPv4__Plugin.html#ga38f1deb60fded1462d849881cfd8ae2f">NDDS_TRANSPORT_TCPV4_WINDOWS_IOCP_SETTINGS_DEFAULT</a> </p>

</div>
</div>
<a class="anchor" id="a0f7c8408af309efa848d4e5c486dccf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::outstanding_connection_cookies</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of outstanding connection cookies allowed by the transport when acting as server. </p>
<p>A connection cookie is a token provided by a server to a client; it is used to establish a data connection. Until the data connection is established, the cookie cannot be reused by the server.</p>
<p>To avoid wasting memory, it is good practice to set a cap to the maximum number of connection cookies (pending connections).</p>
<p>When the maximum value is reached, a client will not be able to connect to the server until new cookies become available.</p>
<p><b>[default]</b> 100 </p>

</div>
</div>
<a class="anchor" id="a2ecaf753f9168a3c6f6b2f803f44eefc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::outstanding_connection_cookies_life_span</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum lifespan (in seconds) of the cookies associated with pending connections. </p>
<p>If a client does not connect to the server before the lifespan of its cookie expires, it will have to request a new cookie.</p>
<p>Range: 1 second or higher, or -1.</p>
<p><b>[default]</b> -1, which means an unlimited amount of time (effectively disabling the feature). </p>

</div>
</div>
<a class="anchor" id="a34e044f3f48a1c1a95a3973a9ac463fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::send_max_wait_sec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of seconds a low-level TCP sendto() function is allowed to block. </p>
<p>This property controls the maximum time (in seconds) the low level sendto() is allowed to block the caller thread when the TCP send buffer becomes full.</p>
<p>If the bandwidth used by the transport is limited, and the sender thread try to push data faster than the OS can handle, the low level sendto() function will block the caller until there is some room available on the queue.</p>
<p>By limiting this delay we eliminate possibility of deadlock and increase the response time of the internal DDS thread.</p>
<p>This property affects both CONTROL and DATA stream, and affect only SYNCHRONOUS send operations. Asynchronous send never blocks a send operation.</p>
<p>For synchronous send() this property limit the time the DDS sender thread can block for a send buffer full. If is too large, DDS not only won't be able to send more data, but it won't be able to receive any more data because of an internal resource mutex.</p>
<p>Setting this property to 0 cause the low level function to report an immediate failure if the TCP send buffer is full.</p>
<p>Setting this property to -1 cause the low level function to block forever until space becomes available in the TCP buffer</p>
<p><b>[default]</b> 3 seconds. </p>

</div>
</div>
<a class="anchor" id="a4647015335b32528cabe98fa16f7b7c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::server_connection_negotiation_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timeout (in seconds) for negotiating a connection. </p>
<p>The TCP Transport Plugin requires some negotiation before sending data over an accepted connection. This property controls the maximum time (in seconds) the a connection can remain in progress. If the negotiation of a connection has not completed after the specified timeout, the connection will be closed. This way, the TCP Transport Plugin can restart the process of establishing and negotiating that connection.</p>
<p>Range: 1 second or higher.</p>
<p><b>[default]</b> 10 seconds </p>

</div>
</div>
<a class="anchor" id="a0b26b7ece4765d342f9c0f2e3ee81520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTI_INT32 NDDS_Transport_TCPv4_Property_t::initial_handshake_timeout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timeout (in seconds) for the initial handshake for a connection. </p>
<p>Some of the TCP Transport Plugin configurations (e.g., when using TLS over TCP) require to perform an initial handshake for each established connection. This property controls the maximum time (in seconds) the initial handshake for a connection can remain in progress. If the handshake has not completed after the specified timeout, the connection will be closed. This way, the TCP Transport Plugin can restart the process of establishing and handshaking that connection.</p>
<p>Range: 1 second or higher.</p>
<p><b>[default]</b> 10 seconds </p>

</div>
</div>
<a class="anchor" id="af01fe54972c6ec0f606edb6d79a5d6d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structRTITLS__OpenSSL__Configuration.html">RTITLS_OpenSSL_Configuration</a> NDDS_Transport_TCPv4_Property_t::tls</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OpenSSL TLS parameters. </p>
<p><b>[default]</b> RTITLS_OpenSSL::RTITLS_OPENSSL_CONFIGURATION_DEFAULT </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI TCP Transport Version 5.2.3</A>
Copyright &copy; Wed Apr 27 2016 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
