<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>RTI Connext Traditional C++ API: FooSeq Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RTI Connext Traditional C++ API
   &#160;<span id="projectnumber">Version 5.2.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2-20120808 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structFooSeq.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structFooSeq-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FooSeq Struct Reference<div class="ingroups"><a class="el" href="group__DDSSequenceModule.html">Sequence Support</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> <em><a class="el" href="group__DDSDocGuideModule.html#a_st_generic">&lt;&lt;generic&gt;&gt;</a></em> A type-safe, ordered collection of elements. The type of these elements is referred to in this documentation as <code><a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a></code>.  
 <a href="structFooSeq.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8244e65d7bce8f4555e62ba76b2db4ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFooSeq.html">FooSeq</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a8244e65d7bce8f4555e62ba76b2db4ba">operator=</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> &amp;src_seq)</td></tr>
<tr class="memdesc:a8244e65d7bce8f4555e62ba76b2db4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy elements from another sequence, resizing the sequence if necessary.  <a href="#a8244e65d7bce8f4555e62ba76b2db4ba"></a><br/></td></tr>
<tr class="separator:a8244e65d7bce8f4555e62ba76b2db4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4b27e70d871276f5c0588337596524"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a2c4b27e70d871276f5c0588337596524">copy_no_alloc</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> &amp;src_seq)</td></tr>
<tr class="memdesc:a2c4b27e70d871276f5c0588337596524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy elements from another sequence, only if the destination sequence has enough capacity.  <a href="#a2c4b27e70d871276f5c0588337596524"></a><br/></td></tr>
<tr class="separator:a2c4b27e70d871276f5c0588337596524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f4f626f27b041eaf1fbbb7abd90fd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a67f4f626f27b041eaf1fbbb7abd90fd7">from_array</a> (const <a class="el" href="structFoo.html">Foo</a> array[], <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> <a class="el" href="structFooSeq.html#a2a38c15cdd9eceab96555fc2375952a5">length</a>)</td></tr>
<tr class="memdesc:a67f4f626f27b041eaf1fbbb7abd90fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy elements from an array of elements, resizing the sequence if necessary. The original contents of the sequence (if any) are replaced.  <a href="#a67f4f626f27b041eaf1fbbb7abd90fd7"></a><br/></td></tr>
<tr class="separator:a67f4f626f27b041eaf1fbbb7abd90fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b2b38f46bb4b5aca744125627aeaac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a34b2b38f46bb4b5aca744125627aeaac">to_array</a> (<a class="el" href="structFoo.html">Foo</a> array[], <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> <a class="el" href="structFooSeq.html#a2a38c15cdd9eceab96555fc2375952a5">length</a>)</td></tr>
<tr class="memdesc:a34b2b38f46bb4b5aca744125627aeaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy elements to an array of elements. The original contents of the array (if any) are replaced.  <a href="#a34b2b38f46bb4b5aca744125627aeaac"></a><br/></td></tr>
<tr class="separator:a34b2b38f46bb4b5aca744125627aeaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7676bae9cf63f55e682b01e1fc9ef99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFoo.html">Foo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#aa7676bae9cf63f55e682b01e1fc9ef99">operator[]</a> (<a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> i)</td></tr>
<tr class="memdesc:aa7676bae9cf63f55e682b01e1fc9ef99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <code>i-th</code> element of the sequence.  <a href="#aa7676bae9cf63f55e682b01e1fc9ef99"></a><br/></td></tr>
<tr class="separator:aa7676bae9cf63f55e682b01e1fc9ef99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ba395790e24b580d935da5a53e784e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structFoo.html">Foo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#ae5ba395790e24b580d935da5a53e784e">operator[]</a> (<a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> i) const </td></tr>
<tr class="memdesc:ae5ba395790e24b580d935da5a53e784e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <code>i-th</code> element for a <code>const</code> sequence.  <a href="#ae5ba395790e24b580d935da5a53e784e"></a><br/></td></tr>
<tr class="separator:ae5ba395790e24b580d935da5a53e784e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a38c15cdd9eceab96555fc2375952a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a2a38c15cdd9eceab96555fc2375952a5">length</a> () const </td></tr>
<tr class="memdesc:a2a38c15cdd9eceab96555fc2375952a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the logical length of this sequence.  <a href="#a2a38c15cdd9eceab96555fc2375952a5"></a><br/></td></tr>
<tr class="separator:a2a38c15cdd9eceab96555fc2375952a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218d5e2a15c320b52b2e6a9e532c9cbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a218d5e2a15c320b52b2e6a9e532c9cbb">length</a> (<a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> new_length)</td></tr>
<tr class="memdesc:a218d5e2a15c320b52b2e6a9e532c9cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the length of this sequence.  <a href="#a218d5e2a15c320b52b2e6a9e532c9cbb"></a><br/></td></tr>
<tr class="separator:a218d5e2a15c320b52b2e6a9e532c9cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecaba1c585095dcec0b975c4b4ceacb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#aecaba1c585095dcec0b975c4b4ceacb5">ensure_length</a> (<a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> <a class="el" href="structFooSeq.html#a2a38c15cdd9eceab96555fc2375952a5">length</a>, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> max)</td></tr>
<tr class="memdesc:aecaba1c585095dcec0b975c4b4ceacb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sequence to the desired length, and resize the sequence if necessary.  <a href="#aecaba1c585095dcec0b975c4b4ceacb5"></a><br/></td></tr>
<tr class="separator:aecaba1c585095dcec0b975c4b4ceacb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50736790ee5daee025e076caf2c3428"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#ad50736790ee5daee025e076caf2c3428">maximum</a> () const </td></tr>
<tr class="memdesc:ad50736790ee5daee025e076caf2c3428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current maximum number of elements that can be stored in this sequence.  <a href="#ad50736790ee5daee025e076caf2c3428"></a><br/></td></tr>
<tr class="separator:ad50736790ee5daee025e076caf2c3428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bca9891ed49e9d82e249b4c0d54c34d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a1bca9891ed49e9d82e249b4c0d54c34d">maximum</a> (<a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> new_max)</td></tr>
<tr class="memdesc:a1bca9891ed49e9d82e249b4c0d54c34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize this sequence to a new desired maximum.  <a href="#a1bca9891ed49e9d82e249b4c0d54c34d"></a><br/></td></tr>
<tr class="separator:a1bca9891ed49e9d82e249b4c0d54c34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c6d9df78157a7077a6858db2d782a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#ad6c6d9df78157a7077a6858db2d782a2">loan_contiguous</a> (<a class="el" href="structFoo.html">Foo</a> *buffer, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> new_length, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> new_max)</td></tr>
<tr class="memdesc:ad6c6d9df78157a7077a6858db2d782a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loan a contiguous buffer to this sequence.  <a href="#ad6c6d9df78157a7077a6858db2d782a2"></a><br/></td></tr>
<tr class="separator:ad6c6d9df78157a7077a6858db2d782a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a116ece7d03d5b34ef5cdec1790839"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a54a116ece7d03d5b34ef5cdec1790839">loan_discontiguous</a> (<a class="el" href="structFoo.html">Foo</a> **buffer, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> new_length, <a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> new_max)</td></tr>
<tr class="memdesc:a54a116ece7d03d5b34ef5cdec1790839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loan a discontiguous buffer to this sequence.  <a href="#a54a116ece7d03d5b34ef5cdec1790839"></a><br/></td></tr>
<tr class="separator:a54a116ece7d03d5b34ef5cdec1790839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec103f89c5c2f118ca570b5cddce8bb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#aec103f89c5c2f118ca570b5cddce8bb6">unloan</a> ()</td></tr>
<tr class="memdesc:aec103f89c5c2f118ca570b5cddce8bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the loaned buffer in the sequence and set the maximum to 0.  <a href="#aec103f89c5c2f118ca570b5cddce8bb6"></a><br/></td></tr>
<tr class="separator:aec103f89c5c2f118ca570b5cddce8bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ac076c2beeb082392124a56cc0a6ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFoo.html">Foo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#ad9ac076c2beeb082392124a56cc0a6ff">get_contiguous_buffer</a> () const </td></tr>
<tr class="memdesc:ad9ac076c2beeb082392124a56cc0a6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the contiguous buffer of the sequence.  <a href="#ad9ac076c2beeb082392124a56cc0a6ff"></a><br/></td></tr>
<tr class="separator:ad9ac076c2beeb082392124a56cc0a6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6088f780e12190965288a0ffe8e4f6ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structFoo.html">Foo</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a6088f780e12190965288a0ffe8e4f6ea">get_discontiguous_buffer</a> () const </td></tr>
<tr class="memdesc:a6088f780e12190965288a0ffe8e4f6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the discontiguous buffer of the sequence.  <a href="#a6088f780e12190965288a0ffe8e4f6ea"></a><br/></td></tr>
<tr class="separator:a6088f780e12190965288a0ffe8e4f6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab037e9d5ce513e8cc966603ffc0cecde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#ab037e9d5ce513e8cc966603ffc0cecde">has_ownership</a> ()</td></tr>
<tr class="memdesc:ab037e9d5ce513e8cc966603ffc0cecde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the owned flag.  <a href="#ab037e9d5ce513e8cc966603ffc0cecde"></a><br/></td></tr>
<tr class="separator:ab037e9d5ce513e8cc966603ffc0cecde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ad8cfcb30ba3660fb421548938241a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#ae8ad8cfcb30ba3660fb421548938241a">~FooSeq</a> ()</td></tr>
<tr class="memdesc:ae8ad8cfcb30ba3660fb421548938241a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate this sequence's buffer.  <a href="#ae8ad8cfcb30ba3660fb421548938241a"></a><br/></td></tr>
<tr class="separator:ae8ad8cfcb30ba3660fb421548938241a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a969ff34dda8abb6df316c569b7fcad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#a0a969ff34dda8abb6df316c569b7fcad">FooSeq</a> (<a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> new_max=0)</td></tr>
<tr class="memdesc:a0a969ff34dda8abb6df316c569b7fcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sequence with the given maximum.  <a href="#a0a969ff34dda8abb6df316c569b7fcad"></a><br/></td></tr>
<tr class="separator:a0a969ff34dda8abb6df316c569b7fcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf91df43a597f8f41ee973b8dcdea9c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFooSeq.html#acf91df43a597f8f41ee973b8dcdea9c6">FooSeq</a> (const struct <a class="el" href="structFooSeq.html">FooSeq</a> &amp;foo_seq)</td></tr>
<tr class="memdesc:acf91df43a597f8f41ee973b8dcdea9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sequence by copying from an existing sequence.  <a href="#acf91df43a597f8f41ee973b8dcdea9c6"></a><br/></td></tr>
<tr class="separator:acf91df43a597f8f41ee973b8dcdea9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> <em><a class="el" href="group__DDSDocGuideModule.html#a_st_generic">&lt;&lt;generic&gt;&gt;</a></em> A type-safe, ordered collection of elements. The type of these elements is referred to in this documentation as <code><a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a></code>. </p>
<p>For users who define data types in OMG IDL, this type corresponds to the IDL express <code>sequence<code>&lt;<a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a>&gt;</code>.</code> </p>
<p>For any user-data type <code><a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a></code> that an application defines for the purpose of data-distribution with RTI Connext, a <code><a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a></code> is generated. The sequence offers a subset of the methods defined by the standard OMG IDL to C++ mapping for sequences. We refer to an IDL <code>sequence<code>&lt;<a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a>&gt;</code> as</code> <code><a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a></code>. </p>
<p>The state of a sequence is described by the properties 'maximum', 'length' and 'owned'. </p>
<ul>
<li>The 'maximum' represents the size of the underlying buffer; this is the maximum number of elements it can possibly hold. It is returned by the <a class="el" href="structFooSeq.html#ad50736790ee5daee025e076caf2c3428" title="Get the current maximum number of elements that can be stored in this sequence.">FooSeq::maximum()</a> operation. </li>
</ul>
<ul>
<li>The 'length' represents the actual number of elements it currently holds. It is returned by the <a class="el" href="structFooSeq.html#a2a38c15cdd9eceab96555fc2375952a5" title="Get the logical length of this sequence.">FooSeq::length()</a> operation. </li>
</ul>
<ul>
<li>The 'owned' flag represents whether the sequence owns the underlying buffer. It is returned by the <a class="el" href="structFooSeq.html#ab037e9d5ce513e8cc966603ffc0cecde" title="Return the value of the owned flag.">FooSeq::has_ownership</a> operation. If the sequence does not own the underlying buffer, the underlying buffer is loaned from somewhere else. This flag influences the lifecycle of the sequence and what operations are allowed on it. The general guidelines are provided below and more details are described in detail as pre-conditions and post-conditions of each of the sequence's operations: <ul>
<li>
<p class="startli">If owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a>, the sequence has ownership on the buffer. It is then responsible for destroying the buffer when the sequence is destroyed. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If the owned == <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a>, the sequence does not have ownership on the buffer. This implies that the sequence is loaning the buffer. The sequence cannot be destroyed until the loan is returned. </p>
<p class="endli"></p>
</li>
<li>
A sequence with a zero maximum always has owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </li>
</ul>
</li>
</ul>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structFooDataWriter.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; User data type specific data writer.">FooDataWriter</a>, <a class="el" href="structFooDataReader.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; User data type-specific data reader.">FooDataReader</a>, <a class="el" href="structFooTypeSupport.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; User data type specific interface.">FooTypeSupport</a>, <a class="el" href="group__DDSNddsgenModule.html">rtiddsgen</a> </dd></dl>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae8ad8cfcb30ba3660fb421548938241a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FooSeq::~FooSeq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate this sequence's buffer. </p>
<dl class="section pre"><dt>Precondition</dt><dd>(owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a>). If this precondition is not met, no memory will be freed and an error will be logged. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>maximum == 0 and the underlying buffer is freed. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structFooSeq.html#ad50736790ee5daee025e076caf2c3428" title="Get the current maximum number of elements that can be stored in this sequence.">FooSeq::maximum()</a>, <a class="el" href="structFooSeq.html#aec103f89c5c2f118ca570b5cddce8bb6" title="Return the loaned buffer in the sequence and set the maximum to 0.">FooSeq::unloan</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0a969ff34dda8abb6df316c569b7fcad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FooSeq::FooSeq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>new_max</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sequence with the given maximum. </p>
<p>This is a constructor for the sequence. The constructor will automatically allocate memory to hold new_max elements of type <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a>. </p>
<p>This constructor will be used when the application creates a sequence using one of the following: </p>
<div class="fragment"><div class="line"><a class="code" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> mySeq(5);</div>
<div class="line"> <span class="comment">// or</span></div>
<div class="line"> <a class="code" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> mySeq;</div>
<div class="line"> <span class="comment">// or</span></div>
<div class="line"> <a class="code" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a>* mySeqPtr = <span class="keyword">new</span> <a class="code" href="structFooSeq.html#a0a969ff34dda8abb6df316c569b7fcad" title="Create a sequence with the given maximum.">FooSeq</a>(5);</div>
</div><!-- fragment --> <dl class="section post"><dt>Postcondition</dt><dd>maximum == new_max </dd>
<dd>
length == 0 </dd>
<dd>
owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a>, </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_max</td><td>Must be &gt;= 0. Otherwise the sequence will be initialized to a new_max=0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf91df43a597f8f41ee973b8dcdea9c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FooSeq::FooSeq </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structFooSeq.html">FooSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>foo_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sequence by copying from an existing sequence. </p>
<p>This is a constructor for the sequence. The constructor will automatically allocate memory to hold foo_seq::maximum() elements of type <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> and will copy the current contents of foo_seq into the new sequence. </p>
<p>This constructor will be used when the application creates a sequence using one of the following: </p>
<div class="fragment"><div class="line"><a class="code" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> mySeq(foo_seq);</div>
<div class="line"> <span class="comment">// or</span></div>
<div class="line"> <a class="code" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> mySeq = foo_seq;</div>
<div class="line"> <span class="comment">// or</span></div>
<div class="line"> <a class="code" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> *mySeqPtr = <span class="keyword">new</span> <a class="code" href="structFooSeq.html#a0a969ff34dda8abb6df316c569b7fcad" title="Create a sequence with the given maximum.">FooSeq</a>(foo_seq);</div>
</div><!-- fragment --> <dl class="section post"><dt>Postcondition</dt><dd>this::maximum == foo_seq::maximum </dd>
<dd>
this::length == foo_seq::length </dd>
<dd>
this[i] == foo_seq[i] for 0 &lt;= i &lt; foo_seq::length </dd>
<dd>
this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the pre-conditions are not met, the constructor will initialize the new sequence to a maximum of zero. </dd></dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a8244e65d7bce8f4555e62ba76b2db4ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFooSeq.html">FooSeq</a>&amp; FooSeq::operator= </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structFooSeq.html">FooSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>src_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy elements from another sequence, resizing the sequence if necessary. </p>
<p>This method invokes <a class="el" href="structFooSeq.html#a2c4b27e70d871276f5c0588337596524" title="Copy elements from another sequence, only if the destination sequence has enough capacity.">FooSeq::copy_no_alloc</a> after ensuring that the sequence has enough capacity to hold the elements to be copied. </p>
<p>This operator is invoked when the following expression appears in the code: </p>
<div class="fragment"><div class="line">target_seq = src_seq                     </div>
</div><!-- fragment --> <p><em>Important:</em> This method <em>will</em> allocate memory if this::maximum &lt; src_seq::length. </p>
<p>Therefore, to programatically detect the successful completion of the operator it is recommended that the application first sets the length of this sequence to zero, makes the assignment, and then checks that the length of this sequence matches that of src_seq. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the sequence from which to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structFooSeq.html#a2c4b27e70d871276f5c0588337596524" title="Copy elements from another sequence, only if the destination sequence has enough capacity.">FooSeq::copy_no_alloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2c4b27e70d871276f5c0588337596524"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FooSeq::copy_no_alloc </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structFooSeq.html">FooSeq</a> &amp;&#160;</td>
          <td class="paramname"><em>src_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy elements from another sequence, only if the destination sequence has enough capacity. </p>
<p>Fill the elements in this sequence by copying the corresponding elements in <code>src_seq</code>. The original contents in this sequence are replaced via the element assignment operation (Foo_copy() function). By default, elements are discarded; 'delete' is not invoked on the discarded elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>this::maximum &gt;= src_seq::length </dd>
<dd>
this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>this::length == src_seq::length </dd>
<dd>
this[i] == src_seq[i] for 0 &lt;= i &lt; target_seq::length </dd>
<dd>
this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the sequence from which to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> if the sequence was successfully copied; <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the pre-conditions are not met, the operator will print a message to stdout and leave this sequence unchanged. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structFooSeq.html#a8244e65d7bce8f4555e62ba76b2db4ba" title="Copy elements from another sequence, resizing the sequence if necessary.">FooSeq::operator=</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a67f4f626f27b041eaf1fbbb7abd90fd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FooSeq::from_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFoo.html">Foo</a>&#160;</td>
          <td class="paramname"><em>array</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy elements from an array of elements, resizing the sequence if necessary. The original contents of the sequence (if any) are replaced. </p>
<p>Fill the elements in this sequence by copying the corresponding elements in <code>array</code>. The original contents in this sequence are replaced via the element assignment operation (Foo_copy() function). By default, elements are discarded; 'delete' is not invoked on the discarded elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>this::length == <code>length</code> </dd>
<dd>
this[i] == array[i] for 0 &lt;= i &lt; <code>length</code> </dd>
<dd>
this::owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The array of elements to be copy elements from </td></tr>
    <tr><td class="paramname">length</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The length of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> if the array was successfully copied; <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the pre-conditions are not met, the method will print a message to stdout and leave this sequence unchanged. </dd></dl>

</div>
</div>
<a class="anchor" id="a34b2b38f46bb4b5aca744125627aeaac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FooSeq::to_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFoo.html">Foo</a>&#160;</td>
          <td class="paramname"><em>array</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy elements to an array of elements. The original contents of the array (if any) are replaced. </p>
<p>Copy the elements of this sequence to the corresponding elements in the array. The original contents of the array are replaced via the element assignment operation (Foo_copy() function). By default, elements are discarded; 'delete' is not invoked on the discarded elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The array of elements to be filled with elements from this sequence </td></tr>
    <tr><td class="paramname">length</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The number of elements to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> if the elements of the sequence were successfully copied; <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7676bae9cf63f55e682b01e1fc9ef99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFoo.html">Foo</a>&amp; FooSeq::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <code>i-th</code> element of the sequence. </p>
<p>This is the operator that is invoked when the application indexes into a non- <code>const</code> sequence: </p>
<div class="fragment"><div class="line">myElement = mySequence[i];</div>
<div class="line"> mySequence[i] = myElement;</div>
</div><!-- fragment --> <p>Note that a <em>reference</em> to the <code>i-th</code> element is returned (and not a copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>index of element to access, must be &gt;= 0 and less than <a class="el" href="structFooSeq.html#a2a38c15cdd9eceab96555fc2375952a5" title="Get the logical length of this sequence.">FooSeq::length()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code>i-th</code> element </dd></dl>

</div>
</div>
<a class="anchor" id="ae5ba395790e24b580d935da5a53e784e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structFoo.html">Foo</a>&amp; FooSeq::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <code>i-th</code> element for a <code>const</code> sequence. </p>
<p>This is the operator that is invoked when the application indexes into a <code>const</code> sequence: </p>
<div class="fragment"><div class="line">myElement = mySequence[i];</div>
</div><!-- fragment --> <p>Note that a <em>reference</em> to the <code>i-th</code> element is returned (and not a copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>index of element to access, must be &gt;= 0 and less than <a class="el" href="structFooSeq.html#a2a38c15cdd9eceab96555fc2375952a5" title="Get the logical length of this sequence.">FooSeq::length()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code>i-th</code> element </dd></dl>

</div>
</div>
<a class="anchor" id="a2a38c15cdd9eceab96555fc2375952a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> FooSeq::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the logical length of this sequence. </p>
<p>Get the length that was last set, or zero if the length has never been set. </p>
<dl class="section return"><dt>Returns</dt><dd>the length of the sequence </dd></dl>

</div>
</div>
<a class="anchor" id="a218d5e2a15c320b52b2e6a9e532c9cbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FooSeq::length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>new_length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the length of this sequence. </p>
<p>This method does not allocate/deallocate memory. </p>
<p>The new length must not exceed the maximum of this sequence as returned by the <a class="el" href="structFooSeq.html#ad50736790ee5daee025e076caf2c3428" title="Get the current maximum number of elements that can be stored in this sequence.">FooSeq::maximum()</a> operation. (Note that, if necessary, the maximum of this sequence can be increased manually by using the ::FooSeq::maximum(long) operation.) </p>
<p>The elements of the sequence are not modified by this operation. If the new length is larger than the original length, the new elements will be uninitialized; if the length is decreased, the old elements that are beyond the new length will physically remain in the sequence but will not be accessible. </p>
<dl class="section post"><dt>Postcondition</dt><dd>length = new_length. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_length</td><td>the new desired length. This value must be non-negative and cannot exceed maximum of the sequence. In other words 0 &lt;= new_length &lt;= maximum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> on sucess or <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> on failure </dd></dl>

</div>
</div>
<a class="anchor" id="aecaba1c585095dcec0b975c4b4ceacb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FooSeq::ensure_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sequence to the desired length, and resize the sequence if necessary. </p>
<p>If the current maximum is greater than the desired length, then sequence is not resized. </p>
<p>Otherwise if this sequence owns its buffer, the sequence is resized to the new maximum by freeing and re-allocating the buffer. However, if the sequence does not own its buffer, this operation will fail. </p>
<p>This function allows user to avoid unnecessary buffer re-allocation. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>length</code> &lt;= <code>max</code> </dd>
<dd>
owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> if sequence needs to be resized </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>length == <code>length</code> </dd>
<dd>
maximum == <code>max</code> if resized </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The new length that should be set. Must be &gt;= 0. </td></tr>
    <tr><td class="paramname">max</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> If sequence need to be resized, this is the maximum that should be set. <code>max</code> &gt;= <code>length</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> on success, <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> if the preconditions are not met. In that case the sequence is not modified. </dd></dl>

</div>
</div>
<a class="anchor" id="ad50736790ee5daee025e076caf2c3428"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a> FooSeq::maximum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current maximum number of elements that can be stored in this sequence. </p>
<p>The <code>maximum</code> of the sequence represents the maximum number of elements that the underlying buffer can hold. It does not represent the current number of elements. </p>
<p>The <code>maximum</code> is a non-negative number. It is initialized when the sequence is first created. </p>
<p><code>maximum</code> can only be changed with the ::FooSeq::maximum(long) operation. </p>
<dl class="section return"><dt>Returns</dt><dd>the current maximum of the sequence. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structFooSeq.html#a2a38c15cdd9eceab96555fc2375952a5" title="Get the logical length of this sequence.">FooSeq::length()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1bca9891ed49e9d82e249b4c0d54c34d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FooSeq::maximum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>new_max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize this sequence to a new desired maximum. </p>
<p>This operation does nothing if the new desired maximum matches the current maximum. </p>
<p>If this sequence owns its buffer and the new maximum is not equal to the old maximum, then the existing buffer will be freed and re-allocated. </p>
<dl class="section pre"><dt>Precondition</dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </dd>
<dd>
length == MINIMUM(original length, new_max) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_max</td><td>Must be &gt;= 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> on success, <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> if the preconditions are not met. In that case the sequence is not modified. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6c6d9df78157a7077a6858db2d782a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FooSeq::loan_contiguous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFoo.html">Foo</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>new_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>new_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loan a contiguous buffer to this sequence. </p>
<p>This operation changes the <code>owned</code> flag of the sequence to <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> and also sets the underlying buffer used by the sequence. See the <a href="../../../manuals/connext_dds/RTI_ConnextDDS_CoreLibraries_UsersManual.pdf" target="_blank">User's Manual</a> for more information about sequences and memory ownership. </p>
<p>Use this method if you want to manage the memory used by the sequence yourself. You must provide an array of elements and integers indicating how many elements are allocated in that array (i.e. the maximum) and how many elements are valid (i.e. the length). The sequence will subsequently use the memory you provide and will not permit it to be freed by a call to ::FooSeq::maximum(long). </p>
<p>Once you have loaned a buffer to a sequence, make sure that you don't free it before calling <a class="el" href="structFooSeq.html#aec103f89c5c2f118ca570b5cddce8bb6" title="Return the loaned buffer in the sequence and set the maximum to 0.">FooSeq::unloan</a>: the next time you access the sequence, you will be accessing freed memory! </p>
<p>You can use this method to wrap stack memory with a sequence interface, thereby avoiding dynamic memory allocation. Create a <a class="el" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a> and an array of type <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> and then loan the array to the sequence: </p>
<div class="fragment"><div class="line"><a class="code" href="structFoo.html" title="A representative user-defined data type.">::Foo</a> fooArray[10];</div>
<div class="line"> <a class="code" href="structFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">::FooSeq</a> fooSeq;</div>
<div class="line"> fooSeq.<a class="code" href="structFooSeq.html#ad6c6d9df78157a7077a6858db2d782a2" title="Loan a contiguous buffer to this sequence.">loan_contiguous</a>(fooArray, 0, 10); </div>
</div><!-- fragment --> <p>By default, a sequence you create owns its memory unless you explicitly loan memory of your own to it. In a very few cases, RTI Connext will return a sequence to you that has a loan; those cases are documented as such. For example, if you call <a class="el" href="structFooDataReader.html#a41ce9a810ae59dc0a73a71a3183f5eb1" title="Access a collection of data samples from the DDSDataReader.">FooDataReader::read</a> or <a class="el" href="structFooDataReader.html#a61a138ab1a8aa7adf766dc4cbdab32dd" title="Access a collection of data-samples from the DDSDataReader.">FooDataReader::take</a> and pass in sequences with no loan and no memory allocated, RTI Connext will loan memory to your sequences which must be unloaned with <a class="el" href="structFooDataReader.html#a9f142a4ee87d08e14a4c07325e1b13ea" title="Indicates to the DDSDataReader that the application is done accessing the collection of received_data...">FooDataReader::return_loan</a>. See the documentation of those methods for more information. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="structFooSeq.html#ad50736790ee5daee025e076caf2c3428" title="Get the current maximum number of elements that can be stored in this sequence.">FooSeq::maximum()</a> == 0; i.e. the sequence has no memory allocated to it. </dd>
<dd>
<a class="el" href="structFooSeq.html#ab037e9d5ce513e8cc966603ffc0cecde" title="Return the value of the owned flag.">FooSeq::has_ownership</a> == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a>; i.e. the sequence does not already have an outstanding loan </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The sequence will store its elements in the buffer provided. </dd>
<dd>
<a class="el" href="structFooSeq.html#ab037e9d5ce513e8cc966603ffc0cecde" title="Return the value of the owned flag.">FooSeq::has_ownership</a> == <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> </dd>
<dd>
<a class="el" href="structFooSeq.html#a2a38c15cdd9eceab96555fc2375952a5" title="Get the logical length of this sequence.">FooSeq::length()</a> == new_length </dd>
<dd>
<a class="el" href="structFooSeq.html#ad50736790ee5daee025e076caf2c3428" title="Get the current maximum number of elements that can be stored in this sequence.">FooSeq::maximum()</a> == new_max </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The new buffer that the sequence will use. Must point to enough memory to hold new_max elements of type <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a>. It may be NULL if new_max == 0. </td></tr>
    <tr><td class="paramname">new_length</td><td>The desired new length for the sequence. It must be the case that that 0 &lt;= new_length &lt;= new_max. </td></tr>
    <tr><td class="paramname">new_max</td><td>The allocated number of elements that could fit in the loaned buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> if <code>buffer</code> is successfully loaned to this sequence or <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> otherwise. Failure only occurs due to failing to meet the pre-conditions. Upon failure the sequence remains unmodified. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structFooSeq.html#aec103f89c5c2f118ca570b5cddce8bb6" title="Return the loaned buffer in the sequence and set the maximum to 0.">FooSeq::unloan</a>, <a class="el" href="structFooSeq.html#a54a116ece7d03d5b34ef5cdec1790839" title="Loan a discontiguous buffer to this sequence.">FooSeq::loan_discontiguous</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a54a116ece7d03d5b34ef5cdec1790839"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FooSeq::loan_discontiguous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFoo.html">Foo</a> **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>new_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DDSCdrTypesModule.html#gadf1aad514e46148e661fc43b61845ed6">DDS_Long</a>&#160;</td>
          <td class="paramname"><em>new_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loan a discontiguous buffer to this sequence. </p>
<p>This method is exactly like <a class="el" href="structFooSeq.html#ad6c6d9df78157a7077a6858db2d782a2" title="Loan a contiguous buffer to this sequence.">FooSeq::loan_contiguous</a> except that the buffer loaned is an array of <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a> pointers, not an array of <a class="el" href="structFoo.html" title="A representative user-defined data type.">Foo</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The new buffer that the sequence will use. Must point to enough memory to hold new_max elements of type Foo*. It may be NULL if new_max == 0. </td></tr>
    <tr><td class="paramname">new_length</td><td>The desired new length for the sequence. It must be the case that that 0 &lt;= new_length &lt;= new_max. </td></tr>
    <tr><td class="paramname">new_max</td><td>The allocated number of elements that could fit in the loaned buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structFooSeq.html#aec103f89c5c2f118ca570b5cddce8bb6" title="Return the loaned buffer in the sequence and set the maximum to 0.">FooSeq::unloan</a>, <a class="el" href="structFooSeq.html#ad6c6d9df78157a7077a6858db2d782a2" title="Loan a contiguous buffer to this sequence.">FooSeq::loan_contiguous</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aec103f89c5c2f118ca570b5cddce8bb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FooSeq::unloan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the loaned buffer in the sequence and set the maximum to 0. </p>
<p>This method affects only the state of this sequence; it does not change the contents of the buffer in any way. </p>
<p>Only the user who originally loaned a buffer should return that loan, as the user may have dependencies on that memory known only to them. Unloaning someone else's buffer may cause unspecified problems. For example, suppose a sequence is loaning memory from a custom memory pool. A user of the sequence likely has no way to release the memory back into the pool, so unloaning the sequence buffer would result in a resource leak. If the user were to then re-loan a different buffer, the original creator of the sequence would have no way to discover, when freeing the sequence, that the loan no longer referred to its own memory and would thus not free the user's memory properly, exacerbating the situation and leading to undefined behavior. </p>
<dl class="section pre"><dt>Precondition</dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>owned == <a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> </dd>
<dd>
maximum == 0 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> if the preconditions were met. Otherwise <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a>. The function only fails if the pre-conditions are not met, in which case it leaves the sequence unmodified. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structFooSeq.html#ad6c6d9df78157a7077a6858db2d782a2" title="Loan a contiguous buffer to this sequence.">FooSeq::loan_contiguous</a>, <a class="el" href="structFooSeq.html#a54a116ece7d03d5b34ef5cdec1790839" title="Loan a discontiguous buffer to this sequence.">FooSeq::loan_discontiguous</a>, ::FooSeq::maximum(long) </dd></dl>

</div>
</div>
<a class="anchor" id="ad9ac076c2beeb082392124a56cc0a6ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFoo.html">Foo</a>* FooSeq::get_contiguous_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the contiguous buffer of the sequence. </p>
<p>Get the underlying buffer where contiguous elements of the sequence are stored. The size of the buffer matches the maximum of the sequence, but only the elements up to the <a class="el" href="structFooSeq.html#a2a38c15cdd9eceab96555fc2375952a5" title="Get the logical length of this sequence.">FooSeq::length()</a> of the sequence are valid. </p>
<p>This method provides almost no encapsulation of the sequence's underlying implementation. Certain operations, such as ::FooSeq::maximum(long), may render the buffer invalid. In light of these caveats, this operation should be used with care. </p>
<dl class="section return"><dt>Returns</dt><dd>buffer that stores contiguous elements in sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="a6088f780e12190965288a0ffe8e4f6ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFoo.html">Foo</a>** FooSeq::get_discontiguous_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the discontiguous buffer of the sequence. </p>
<p>This operation returns the underlying buffer where discontiguous elements of the sequence are stored. The size of the buffer matches the maximum of this sequence, but only the elements up to the <a class="el" href="structFooSeq.html#a2a38c15cdd9eceab96555fc2375952a5" title="Get the logical length of this sequence.">FooSeq::length()</a> of the sequence are valid. </p>
<p>The same caveats apply to this method as to ::FooSeq::get_contiguous_bufferI. </p>
<p>The sequence will dereference pointers in the discontiguous buffer to provide access to its elements by value in C and by reference in C++. If you access the discontiguous buffer directly by means of this method, do not store any NULL values into it, as acessing those values will result in a segmentation fault. </p>
<dl class="section return"><dt>Returns</dt><dd>buffer that stores discontiguous elements in sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="ab037e9d5ce513e8cc966603ffc0cecde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FooSeq::has_ownership </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of the owned flag. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__DDSCdrTypesModule.html#ga02f257a405ea7ff6774cdf4330a7eeb7" title="Defines &quot;true&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_TRUE</a> if sequence owns the underlying buffer, or <a class="el" href="group__DDSCdrTypesModule.html#ga727fba6a96485884ccd9438b560689f7" title="Defines &quot;false&quot; value of DDS_Boolean data type.">DDS_BOOLEAN_FALSE</a> if it has an outstanding loan. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Connext Traditional C++ API Version 5.2.3</A>
Copyright &copy; Wed Apr 27 2016 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
