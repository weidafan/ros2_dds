<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>RTI Connext .Net APIs: DDS::Sequence&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RTI Connext .Net APIs
   &#160;<span id="projectnumber">Version 5.2.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2-20120808 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classDDS_1_1Sequence.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="classDDS_1_1Sequence-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DDS::Sequence&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__DDSSequenceModule.html">Sequence Support</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> <em><a class="el" href="group__DDSDocGuideModule.html#a_st_generic">&lt;&lt;generic&gt;&gt;</a></em> A type-safe, ordered collection of elements. The type of these elements is referred to in this documentation as <code><a class="el" href="classFoo.html" title="A representative user-defined data type.">Foo</a></code>.  
 <a href="classDDS_1_1Sequence.html#details">More...</a></p>

<p><code>#include &lt;managed_sequence.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DDS::Sequence&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classDDS_1_1Sequence.png" usemap="#DDS::Sequence&lt; T &gt;_map" alt=""/>
  <map id="DDS::Sequence&lt; T &gt;_map" name="DDS::Sequence&lt; T &gt;_map">
<area href="classDDS_1_1ChannelSettingsSeq.html" title="Declares IDL sequence&lt; DDS::ChannelSettings_t &gt;" alt="DDS::ChannelSettingsSeq" shape="rect" coords="228,56,446,80"/>
<area href="classDDS_1_1ConditionSeq.html" title="Instantiates DDS::Sequence &lt; DDS::Condition &gt;" alt="DDS::ConditionSeq" shape="rect" coords="228,112,446,136"/>
<area href="classDDS_1_1CookieSeq.html" title="Declares IDL sequence &lt; DDS::Cookie_t &gt; ." alt="DDS::CookieSeq" shape="rect" coords="228,168,446,192"/>
<area href="classDDS_1_1DataReaderSeq.html" title="Declares IDL sequence &lt; DDS::DataReader &gt; ." alt="DDS::DataReaderSeq" shape="rect" coords="228,224,446,248"/>
<area href="classDDS_1_1EndpointGroupSeq.html" title="A sequence of DDS::EndpointGroup_t." alt="DDS::EndpointGroupSeq" shape="rect" coords="228,280,446,304"/>
<area href="classDDS_1_1EnumMemberSeq.html" title="Defines a sequence of enumerator members." alt="DDS::EnumMemberSeq" shape="rect" coords="228,336,446,360"/>
<area href="classDDS_1_1LocatorFilterSeq.html" title="Declares IDL sequence&lt; DDS::LocatorFilter_t &gt;." alt="DDS::LocatorFilterSeq" shape="rect" coords="228,392,446,416"/>
<area href="classDDS_1_1LocatorSeq.html" title="Declares IDL sequence &lt; DDS::Locator_t &gt;" alt="DDS::LocatorSeq" shape="rect" coords="228,448,446,472"/>
<area href="classDDS_1_1PropertySeq.html" title="Declares IDL sequence &lt; DDS::Property_t &gt;" alt="DDS::PropertySeq" shape="rect" coords="228,504,446,528"/>
<area href="classDDS_1_1PublisherSeq.html" title="Declares IDL sequence &lt; DDS::Publisher &gt; ." alt="DDS::PublisherSeq" shape="rect" coords="228,560,446,584"/>
<area href="classDDS_1_1StructMemberSeq.html" title="Defines a sequence of struct members." alt="DDS::StructMemberSeq" shape="rect" coords="228,616,446,640"/>
<area href="classDDS_1_1SubscriberSeq.html" title="Declares IDL sequence &lt; DDS::Subscriber &gt; ." alt="DDS::SubscriberSeq" shape="rect" coords="228,672,446,696"/>
<area href="classDDS_1_1TransportInfoSeq.html" title="Instantiates DDS::Sequence &lt; DDS::TransportInfo_t &gt; ." alt="DDS::TransportInfoSeq" shape="rect" coords="228,728,446,752"/>
<area href="classDDS_1_1TransportMulticastMappingSeq.html" title="Declares IDL sequence&lt; DDS::TransportMulticastMapping_t &gt;" alt="DDS::TransportMulticastMappingSeq" shape="rect" coords="228,784,446,808"/>
<area href="classDDS_1_1TransportMulticastSettingsSeq.html" title="Declares IDL sequence&lt; DDS::TransportMulticastSettings_t &gt;" alt="DDS::TransportMulticastSettingsSeq" shape="rect" coords="228,840,446,864"/>
<area href="classDDS_1_1TransportUnicastSettingsSeq.html" title="Declares IDL sequence&lt; DDS::TransportUnicastSettings_t &gt;" alt="DDS::TransportUnicastSettingsSeq" shape="rect" coords="228,896,446,920"/>
<area href="classDDS_1_1UnionMemberSeq.html" title="Defines a sequence of union members." alt="DDS::UnionMemberSeq" shape="rect" coords="228,952,446,976"/>
<area href="classDDS_1_1ValueMemberSeq.html" title="Defines a sequence of value members." alt="DDS::ValueMemberSeq" shape="rect" coords="228,1008,446,1032"/>
<area href="classDDS_1_1WstringSeq.html" title="Instantiates DDS::Sequence &lt; System::Char* &gt;" alt="DDS::WstringSeq" shape="rect" coords="228,1064,446,1088"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aade5d0f7e88bb6a38c955e6dcf564874"><td class="memItemLeft" align="right" valign="top">System::Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDDS_1_1Sequence.html#aade5d0f7e88bb6a38c955e6dcf564874">ensure_length</a> (System::Int32 <a class="el" href="classDDS_1_1Sequence.html#ae1dbca92f0e7622f82a3e06f5e14c03b">length</a>, System::Int32 max)</td></tr>
<tr class="memdesc:aade5d0f7e88bb6a38c955e6dcf564874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sequence to the desired length, and resize the sequence if necessary.  <a href="#aade5d0f7e88bb6a38c955e6dcf564874"></a><br/></td></tr>
<tr class="separator:aade5d0f7e88bb6a38c955e6dcf564874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6335007d26e4cce81ec2f9a9ce62cbdd"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDDS_1_1Sequence.html#a6335007d26e4cce81ec2f9a9ce62cbdd">get_at</a> (System::Int32 i)</td></tr>
<tr class="memdesc:a6335007d26e4cce81ec2f9a9ce62cbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <code>i-th</code> element for a <code>const</code> sequence.  <a href="#a6335007d26e4cce81ec2f9a9ce62cbdd"></a><br/></td></tr>
<tr class="separator:a6335007d26e4cce81ec2f9a9ce62cbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbc8adb3b3d6ff1e2e7e040a1b08d5c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDDS_1_1Sequence.html#aabbc8adb3b3d6ff1e2e7e040a1b08d5c">set_at</a> (System::Int32 i, T val)</td></tr>
<tr class="memdesc:aabbc8adb3b3d6ff1e2e7e040a1b08d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <code>i-th</code> element of the sequence.  <a href="#aabbc8adb3b3d6ff1e2e7e040a1b08d5c"></a><br/></td></tr>
<tr class="separator:aabbc8adb3b3d6ff1e2e7e040a1b08d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1189a8b3879fbdeb2467648374a4a8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDDS_1_1Sequence.html#ae1189a8b3879fbdeb2467648374a4a8d">loan</a> (array&lt; T &gt;^<a class="el" href="classDDS_1_1Sequence.html#ad28b6977aee1953d70faaf7b64f737fe">buffer</a>, System::Int32 new_length)</td></tr>
<tr class="memdesc:ae1189a8b3879fbdeb2467648374a4a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loan a contiguous buffer to this sequence.  <a href="#ae1189a8b3879fbdeb2467648374a4a8d"></a><br/></td></tr>
<tr class="separator:ae1189a8b3879fbdeb2467648374a4a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45abbd1c158a2681231758eed41836c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDDS_1_1Sequence.html#a45abbd1c158a2681231758eed41836c9">unloan</a> ()</td></tr>
<tr class="memdesc:a45abbd1c158a2681231758eed41836c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the loaned buffer in the sequence and set the maximum to 0.  <a href="#a45abbd1c158a2681231758eed41836c9"></a><br/></td></tr>
<tr class="separator:a45abbd1c158a2681231758eed41836c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffe63ac5ca1035c12f1e9366ebc48fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDDS_1_1Sequence.html#a9ffe63ac5ca1035c12f1e9366ebc48fd">from_array</a> (array&lt; T &gt;^arr)</td></tr>
<tr class="memdesc:a9ffe63ac5ca1035c12f1e9366ebc48fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy elements from an array of elements, resizing the sequence if necessary. The original contents of the sequence (if any) are replaced.  <a href="#a9ffe63ac5ca1035c12f1e9366ebc48fd"></a><br/></td></tr>
<tr class="separator:a9ffe63ac5ca1035c12f1e9366ebc48fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd442b3a083e75fb2b693419711e2c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDDS_1_1Sequence.html#a8dd442b3a083e75fb2b693419711e2c2">to_array</a> (array&lt; T &gt;^arr)</td></tr>
<tr class="memdesc:a8dd442b3a083e75fb2b693419711e2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy elements to an array of elements. The original contents of the array (if any) are replaced.  <a href="#a8dd442b3a083e75fb2b693419711e2c2"></a><br/></td></tr>
<tr class="separator:a8dd442b3a083e75fb2b693419711e2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360a7f669a8c8acad7addf8e1c712812"><td class="memItemLeft" align="right" valign="top">System::Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDDS_1_1Sequence.html#a360a7f669a8c8acad7addf8e1c712812">copy_from</a> (<a class="el" href="classDDS_1_1Sequence.html">Sequence</a>&lt; T &gt;^src_seq)</td></tr>
<tr class="memdesc:a360a7f669a8c8acad7addf8e1c712812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy elements from another sequence, resizing the sequence if necessary.  <a href="#a360a7f669a8c8acad7addf8e1c712812"></a><br/></td></tr>
<tr class="separator:a360a7f669a8c8acad7addf8e1c712812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d877e89d4f088eec2fe6b37e063985"><td class="memItemLeft" align="right" valign="top">virtual System::Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDDS_1_1Sequence.html#a81d877e89d4f088eec2fe6b37e063985">copy_from_no_alloc</a> (<a class="el" href="classDDS_1_1Sequence.html">Sequence</a>&lt; T &gt;^src_seq)</td></tr>
<tr class="memdesc:a81d877e89d4f088eec2fe6b37e063985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy elements from another sequence, only if the destination sequence has enough capacity.  <a href="#a81d877e89d4f088eec2fe6b37e063985"></a><br/></td></tr>
<tr class="separator:a81d877e89d4f088eec2fe6b37e063985"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ae1dbca92f0e7622f82a3e06f5e14c03b"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDDS_1_1Sequence.html#ae1dbca92f0e7622f82a3e06f5e14c03b">length</a><code> [get, set]</code></td></tr>
<tr class="memdesc:ae1dbca92f0e7622f82a3e06f5e14c03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical length of this sequence.  <a href="#ae1dbca92f0e7622f82a3e06f5e14c03b"></a><br/></td></tr>
<tr class="separator:ae1dbca92f0e7622f82a3e06f5e14c03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1b5200f7a295923c3cf4d9b52a1268"><td class="memItemLeft" align="right" valign="top">virtual System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDDS_1_1Sequence.html#abe1b5200f7a295923c3cf4d9b52a1268">maximum</a><code> [get, set]</code></td></tr>
<tr class="memdesc:abe1b5200f7a295923c3cf4d9b52a1268"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current maximum number of elements that can be stored in this sequence.  <a href="#abe1b5200f7a295923c3cf4d9b52a1268"></a><br/></td></tr>
<tr class="separator:abe1b5200f7a295923c3cf4d9b52a1268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28b6977aee1953d70faaf7b64f737fe"><td class="memItemLeft" align="right" valign="top">array&lt; T &gt;^&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDDS_1_1Sequence.html#ad28b6977aee1953d70faaf7b64f737fe">buffer</a><code> [get]</code></td></tr>
<tr class="memdesc:ad28b6977aee1953d70faaf7b64f737fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the contiguous buffer of the sequence.  <a href="#ad28b6977aee1953d70faaf7b64f737fe"></a><br/></td></tr>
<tr class="separator:ad28b6977aee1953d70faaf7b64f737fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b6d6d726cbd352eeefdbb6875d027b"><td class="memItemLeft" align="right" valign="top">System::Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDDS_1_1Sequence.html#ad6b6d6d726cbd352eeefdbb6875d027b">has_ownership</a><code> [get]</code></td></tr>
<tr class="memdesc:ad6b6d6d726cbd352eeefdbb6875d027b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the owned flag.  <a href="#ad6b6d6d726cbd352eeefdbb6875d027b"></a><br/></td></tr>
<tr class="separator:ad6b6d6d726cbd352eeefdbb6875d027b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class DDS::Sequence&lt; T &gt;</h3>

<p><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> <em><a class="el" href="group__DDSDocGuideModule.html#a_st_generic">&lt;&lt;generic&gt;&gt;</a></em> A type-safe, ordered collection of elements. The type of these elements is referred to in this documentation as <code><a class="el" href="classFoo.html" title="A representative user-defined data type.">Foo</a></code>. </p>
<p>For users who define data types in OMG IDL, this type corresponds to the IDL express <code>sequence<code>&lt;<a class="el" href="classFoo.html" title="A representative user-defined data type.">Foo</a>&gt;</code>.</code> </p>
<p>For any user-data type <code><a class="el" href="classFoo.html" title="A representative user-defined data type.">Foo</a></code> that an application defines for the purpose of data-distribution with <a class="el" href="namespaceRTI.html">RTI</a> Connext, a <code><a class="el" href="classFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a></code> is generated. We refer to an IDL <code>sequence<code>&lt;<a class="el" href="classFoo.html" title="A representative user-defined data type.">Foo</a>&gt;</code> as</code> <code><a class="el" href="classFooSeq.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; A type-safe, ordered collection of elements. The type of these elements is ...">FooSeq</a></code>. </p>
<p>The state of a sequence is described by the properties 'maximum', 'length' and 'owned'. </p>
<ul>
<li>The 'maximum' represents the size of the underlying buffer; this is the maximum number of elements it can possibly hold. It is returned by the <a class="el" href="classDDS_1_1Sequence.html#abe1b5200f7a295923c3cf4d9b52a1268" title="The current maximum number of elements that can be stored in this sequence.">DDS::Sequence::maximum</a> operation. </li>
</ul>
<ul>
<li>The 'length' represents the actual number of elements it currently holds. It is returned by the <a class="el" href="classDDS_1_1Sequence.html#ae1dbca92f0e7622f82a3e06f5e14c03b" title="The logical length of this sequence.">DDS::Sequence::length</a> operation. </li>
</ul>
<ul>
<li>The 'owned' flag represents whether the sequence owns the underlying buffer. It is returned by the <a class="el" href="classDDS_1_1Sequence.html#ad6b6d6d726cbd352eeefdbb6875d027b" title="Return the value of the owned flag.">DDS::Sequence::has_ownership</a> operation. If the sequence does not own the underlying buffer, the underlying buffer is loaned from somewhere else. This flag influences the lifecycle of the sequence and what operations are allowed on it. The general guidelines are provided below and more details are described in detail as pre-conditions and post-conditions of each of the sequence's operations: <ul>
<li>
<p class="startli">If owned == true, the sequence has ownership on the buffer. It is then responsible for destroying the buffer when the sequence is destroyed. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If the owned == false, the sequence does not have ownership on the buffer. This implies that the sequence is loaning the buffer. The sequence cannot be destroyed until the loan is returned. </p>
<p class="endli"></p>
</li>
<li>
A sequence with a zero maximum always has owned == true </li>
</ul>
</li>
</ul>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classDDS_1_1TypedDataWriter.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; User data type specific data writer.">DDS::TypedDataWriter</a>, <a class="el" href="classDDS_1_1TypedDataReader.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; User data type-specific data reader.">DDS::TypedDataReader</a>, <a class="el" href="classFooTypeSupport.html" title="&lt;&lt;interface&gt;&gt; &lt;&lt;generic&gt;&gt; User data type specific interface.">FooTypeSupport</a>, <a class="el" href="group__DDSNddsgenModule.html">rtiddsgen</a> </dd></dl>
</div><h2>Member Function Documentation</h2>
<a class="anchor" id="aade5d0f7e88bb6a38c955e6dcf564874"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">System::Boolean <a class="el" href="classDDS_1_1Sequence.html">DDS::Sequence</a>&lt; T &gt;::ensure_length </td>
          <td>(</td>
          <td class="paramtype">System::Int32&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">System::Int32&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sequence to the desired length, and resize the sequence if necessary. </p>
<p>If the current maximum is greater than the desired length, then sequence is not resized. </p>
<p>Otherwise if this sequence owns its buffer, the sequence is resized to the new maximum by freeing and re-allocating the buffer. However, if the sequence does not own its buffer, this operation will fail. </p>
<p>This function allows user to avoid unnecessary buffer re-allocation. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>length</code> &lt;= <code>max</code> </dd>
<dd>
owned == true if sequence needs to be resized </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>length == <code>length</code> </dd>
<dd>
maximum == <code>max</code> if resized </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The new length that should be set. Must be &gt;= 0. </td></tr>
    <tr><td class="paramname">max</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> If sequence need to be resized, this is the maximum that should be set. <code>max</code> &gt;= <code>length</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if the preconditions are not met. In that case the sequence is not modified. </dd></dl>

</div>
</div>
<a class="anchor" id="a6335007d26e4cce81ec2f9a9ce62cbdd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T <a class="el" href="classDDS_1_1Sequence.html">DDS::Sequence</a>&lt; T &gt;::get_at </td>
          <td>(</td>
          <td class="paramtype">System::Int32&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <code>i-th</code> element for a <code>const</code> sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>index of element to access, must be &gt;= 0 and less than <a class="el" href="classDDS_1_1Sequence.html#ae1dbca92f0e7622f82a3e06f5e14c03b" title="The logical length of this sequence.">DDS::Sequence::length</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code>i-th</code> element </dd></dl>

<p>Reimplemented in <a class="el" href="classDDS_1_1LoanableSequence.html#a2a880aa533a70780b46eca7d9de9c36e">DDS::LoanableSequence&lt; E &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#a2a880aa533a70780b46eca7d9de9c36e">DDS::LoanableSequence&lt; TopicBuiltinTopicData^  &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#a2a880aa533a70780b46eca7d9de9c36e">DDS::LoanableSequence&lt; ParticipantBuiltinTopicData^  &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#a2a880aa533a70780b46eca7d9de9c36e">DDS::LoanableSequence&lt; SubscriptionBuiltinTopicData^  &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#a2a880aa533a70780b46eca7d9de9c36e">DDS::LoanableSequence&lt; M^  &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#a2a880aa533a70780b46eca7d9de9c36e">DDS::LoanableSequence&lt; SampleInfo^  &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#a2a880aa533a70780b46eca7d9de9c36e">DDS::LoanableSequence&lt; Foo^  &gt;</a>, and <a class="el" href="classDDS_1_1LoanableSequence.html#a2a880aa533a70780b46eca7d9de9c36e">DDS::LoanableSequence&lt; PublicationBuiltinTopicData^  &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aabbc8adb3b3d6ff1e2e7e040a1b08d5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classDDS_1_1Sequence.html">DDS::Sequence</a>&lt; T &gt;::set_at </td>
          <td>(</td>
          <td class="paramtype">System::Int32&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the <code>i-th</code> element of the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>index of element to access, must be &gt;= 0 and less than <a class="el" href="classDDS_1_1Sequence.html#ae1dbca92f0e7622f82a3e06f5e14c03b" title="The logical length of this sequence.">DDS::Sequence::length</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> value to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1189a8b3879fbdeb2467648374a4a8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDDS_1_1Sequence.html">DDS::Sequence</a>&lt; T &gt;::loan </td>
          <td>(</td>
          <td class="paramtype">array&lt; T &gt;^&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">System::Int32&#160;</td>
          <td class="paramname"><em>new_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loan a contiguous buffer to this sequence. </p>
<p>This operation changes the <code>owned</code> flag of the sequence to false and also sets the underlying buffer used by the sequence. See the <a href="../../../manuals/connext_dds/RTI_ConnextDDS_CoreLibraries_UsersManual.pdf" target="_blank">User's Manual</a> for more information about sequences and memory ownership. </p>
<p>Use this method if you want to manage the memory used by the sequence yourself. You must provide an array of elements and integers indicating how many elements are allocated in that array (i.e. the maximum) and how many elements are valid (i.e. the length). The sequence will subsequently use the memory you provide and will not permit it to be freed by a call to <a class="el" href="classDDS_1_1Sequence.html#abe1b5200f7a295923c3cf4d9b52a1268" title="The current maximum number of elements that can be stored in this sequence.">DDS::Sequence::maximum</a>. </p>
<p>By default, a sequence you create owns its memory unless you explicitly loan memory of your own to it. In a very few cases, <a class="el" href="namespaceRTI.html">RTI</a> Connext will return a sequence to you that has a loan; those cases are documented as such. For example, if you call <a class="el" href="classDDS_1_1TypedDataReader.html#ae572bf2f25430c39a731fce065e412a0" title="Access a collection of data samples from the DDS::DataReader.">DDS::TypedDataReader::read</a> or <a class="el" href="classDDS_1_1TypedDataReader.html#a58f9fd1a6dedcb486ef5d62c392ba664" title="Access a collection of data-samples from the DDS::DataReader.">DDS::TypedDataReader::take</a> and pass in sequences with no loan and no memory allocated, <a class="el" href="namespaceRTI.html">RTI</a> Connext will loan memory to your sequences which must be unloaned with <a class="el" href="classDDS_1_1TypedDataReader.html#a57af270af1e041de951f959d2d255735" title="Indicates to the DDS::DataReader that the application is done accessing the collection of received_da...">DDS::TypedDataReader::return_loan</a>. See the documentation of those methods for more information. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classDDS_1_1Sequence.html#abe1b5200f7a295923c3cf4d9b52a1268" title="The current maximum number of elements that can be stored in this sequence.">DDS::Sequence::maximum</a> == 0; i.e. the sequence has no memory allocated to it. </dd>
<dd>
<a class="el" href="classDDS_1_1Sequence.html#ad6b6d6d726cbd352eeefdbb6875d027b" title="Return the value of the owned flag.">DDS::Sequence::has_ownership</a> == true; i.e. the sequence does not already have an outstanding loan </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The sequence will store its elements in the buffer provided. </dd>
<dd>
<a class="el" href="classDDS_1_1Sequence.html#ad6b6d6d726cbd352eeefdbb6875d027b" title="Return the value of the owned flag.">DDS::Sequence::has_ownership</a> == false </dd>
<dd>
<a class="el" href="classDDS_1_1Sequence.html#ae1dbca92f0e7622f82a3e06f5e14c03b" title="The logical length of this sequence.">DDS::Sequence::length</a> == new_length </dd>
<dd>
<a class="el" href="classDDS_1_1Sequence.html#abe1b5200f7a295923c3cf4d9b52a1268" title="The current maximum number of elements that can be stored in this sequence.">DDS::Sequence::maximum</a> == new_max </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The new buffer that the sequence will use. Must point to enough memory to hold new_max elements of type <a class="el" href="classFoo.html" title="A representative user-defined data type.">Foo</a>. It may be NULL if new_max == 0. </td></tr>
    <tr><td class="paramname">new_length</td><td>The desired new length for the sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <code>buffer</code> is successfully loaned to this sequence or false otherwise. Failure only occurs due to failing to meet the pre-conditions. Upon failure the sequence remains unmodified. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classDDS_1_1Sequence.html#a45abbd1c158a2681231758eed41836c9" title="Return the loaned buffer in the sequence and set the maximum to 0.">DDS::Sequence::unloan</a>, ::DDS::Sequence::loan_discontiguous </dd></dl>

</div>
</div>
<a class="anchor" id="a45abbd1c158a2681231758eed41836c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classDDS_1_1Sequence.html">DDS::Sequence</a>&lt; T &gt;::unloan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the loaned buffer in the sequence and set the maximum to 0. </p>
<p>This method affects only the state of this sequence; it does not change the contents of the buffer in any way. </p>
<p>Only the user who originally loaned a buffer should return that loan, as the user may have dependencies on that memory known only to them. Unloaning someone else's buffer may cause unspecified problems. For example, suppose a sequence is loaning memory from a custom memory pool. A user of the sequence likely has no way to release the memory back into the pool, so unloaning the sequence buffer would result in a resource leak. If the user were to then re-loan a different buffer, the original creator of the sequence would have no way to discover, when freeing the sequence, that the loan no longer referred to its own memory and would thus not free the user's memory properly, exacerbating the situation and leading to undefined behavior. </p>
<dl class="section pre"><dt>Precondition</dt><dd>owned == false </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>owned == true </dd>
<dd>
maximum == 0 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the preconditions were met. Otherwise false. The function only fails if the pre-conditions are not met, in which case it leaves the sequence unmodified. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classDDS_1_1Sequence.html#ae1189a8b3879fbdeb2467648374a4a8d" title="Loan a contiguous buffer to this sequence.">DDS::Sequence&lt;T&gt;::loan</a>(array&lt;T&gt;^, System::Int32), ::DDS::Sequence::loan_discontiguous, <a class="el" href="classDDS_1_1Sequence.html#abe1b5200f7a295923c3cf4d9b52a1268" title="The current maximum number of elements that can be stored in this sequence.">DDS::Sequence::maximum</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classDDS_1_1LoanableSequence.html#aa17e7a4c3d3bf59f5cf34b6fdcb8259a">DDS::LoanableSequence&lt; E &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#aa17e7a4c3d3bf59f5cf34b6fdcb8259a">DDS::LoanableSequence&lt; TopicBuiltinTopicData^  &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#aa17e7a4c3d3bf59f5cf34b6fdcb8259a">DDS::LoanableSequence&lt; ParticipantBuiltinTopicData^  &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#aa17e7a4c3d3bf59f5cf34b6fdcb8259a">DDS::LoanableSequence&lt; SubscriptionBuiltinTopicData^  &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#aa17e7a4c3d3bf59f5cf34b6fdcb8259a">DDS::LoanableSequence&lt; M^  &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#aa17e7a4c3d3bf59f5cf34b6fdcb8259a">DDS::LoanableSequence&lt; SampleInfo^  &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#aa17e7a4c3d3bf59f5cf34b6fdcb8259a">DDS::LoanableSequence&lt; Foo^  &gt;</a>, and <a class="el" href="classDDS_1_1LoanableSequence.html#aa17e7a4c3d3bf59f5cf34b6fdcb8259a">DDS::LoanableSequence&lt; PublicationBuiltinTopicData^  &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9ffe63ac5ca1035c12f1e9366ebc48fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDDS_1_1Sequence.html">DDS::Sequence</a>&lt; T &gt;::from_array </td>
          <td>(</td>
          <td class="paramtype">array&lt; T &gt;^&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy elements from an array of elements, resizing the sequence if necessary. The original contents of the sequence (if any) are replaced. </p>
<p>Fill the elements in this sequence by copying the corresponding elements in <code>array</code>. The original contents in this sequence are replaced via the element assignment operation (Foo_copy() function). By default, elements are discarded; 'delete' is not invoked on the discarded elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>this::owned == true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>this::length == <code>length</code> </dd>
<dd>
this[i] == array[i] for 0 &lt;= i &lt; <code>length</code> </dd>
<dd>
this::owned == true </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The array of elements to be copy elements from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the array was successfully copied; false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the pre-conditions are not met, the method will print a message to stdout and leave this sequence unchanged. </dd></dl>

</div>
</div>
<a class="anchor" id="a8dd442b3a083e75fb2b693419711e2c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDDS_1_1Sequence.html">DDS::Sequence</a>&lt; T &gt;::to_array </td>
          <td>(</td>
          <td class="paramtype">array&lt; T &gt;^&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy elements to an array of elements. The original contents of the array (if any) are replaced. </p>
<p>Copy the elements of this sequence to the corresponding elements in the array. The original contents of the array are replaced via the element assignment operation (Foo_copy() function). By default, elements are discarded; 'delete' is not invoked on the discarded elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> The array of elements to be filled with elements from this sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the elements of the sequence were successfully copied; false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a360a7f669a8c8acad7addf8e1c712812"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">System::Boolean <a class="el" href="classDDS_1_1Sequence.html">DDS::Sequence</a>&lt; T &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDDS_1_1Sequence.html">Sequence</a>&lt; T &gt;^&#160;</td>
          <td class="paramname"><em>src_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy elements from another sequence, resizing the sequence if necessary. </p>
<p>This method invokes <a class="el" href="classDDS_1_1Sequence.html#a360a7f669a8c8acad7addf8e1c712812" title="Copy elements from another sequence, resizing the sequence if necessary.">DDS::Sequence::copy_from</a>(DDS::Sequence&lt;T&gt;^) after ensuring that the sequence has enough capacity to hold the elements to be copied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the sequence from which to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classDDS_1_1Sequence.html#a360a7f669a8c8acad7addf8e1c712812" title="Copy elements from another sequence, resizing the sequence if necessary.">DDS::Sequence::copy_from</a>(DDS::Sequence&lt;T&gt;^) </dd></dl>

</div>
</div>
<a class="anchor" id="a81d877e89d4f088eec2fe6b37e063985"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual System::Boolean <a class="el" href="classDDS_1_1Sequence.html">DDS::Sequence</a>&lt; T &gt;::copy_from_no_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDDS_1_1Sequence.html">Sequence</a>&lt; T &gt;^&#160;</td>
          <td class="paramname"><em>src_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy elements from another sequence, only if the destination sequence has enough capacity. </p>
<p>Fill the elements in this sequence by copying the corresponding elements in <code>src_seq</code>. The original contents in this sequence are replaced via the element assignment operation (Foo_copy() function). By default, elements are discarded; 'delete' is not invoked on the discarded elements. </p>
<dl class="section pre"><dt>Precondition</dt><dd>this::maximum &gt;= src_seq::length </dd>
<dd>
this::owned == true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>this::length == src_seq::length </dd>
<dd>
this[i] == src_seq[i] for 0 &lt;= i &lt; target_seq::length </dd>
<dd>
this::owned == true </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_seq</td><td><em><a class="el" href="group__DDSDocGuideModule.html#a_st_in">&lt;&lt;in&gt;&gt;</a></em> the sequence from which to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the sequence was successfully copied; false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the pre-conditions are not met, the operator will print a message to stdout and leave this sequence unchanged. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classDDS_1_1Sequence.html#a81d877e89d4f088eec2fe6b37e063985" title="Copy elements from another sequence, only if the destination sequence has enough capacity.">DDS::Sequence::copy_from_no_alloc</a>(DDS::Sequence&lt;T&gt;^) </dd></dl>

<p>Reimplemented in <a class="el" href="classDDS_1_1LoanableSequence.html#a93899069d970914457107ece7dd36bf3">DDS::LoanableSequence&lt; E &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#a93899069d970914457107ece7dd36bf3">DDS::LoanableSequence&lt; TopicBuiltinTopicData^  &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#a93899069d970914457107ece7dd36bf3">DDS::LoanableSequence&lt; ParticipantBuiltinTopicData^  &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#a93899069d970914457107ece7dd36bf3">DDS::LoanableSequence&lt; SubscriptionBuiltinTopicData^  &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#a93899069d970914457107ece7dd36bf3">DDS::LoanableSequence&lt; M^  &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#a93899069d970914457107ece7dd36bf3">DDS::LoanableSequence&lt; SampleInfo^  &gt;</a>, <a class="el" href="classDDS_1_1LoanableSequence.html#a93899069d970914457107ece7dd36bf3">DDS::LoanableSequence&lt; Foo^  &gt;</a>, and <a class="el" href="classDDS_1_1LoanableSequence.html#a93899069d970914457107ece7dd36bf3">DDS::LoanableSequence&lt; PublicationBuiltinTopicData^  &gt;</a>.</p>

</div>
</div>
<h2>Property Documentation</h2>
<a class="anchor" id="ae1dbca92f0e7622f82a3e06f5e14c03b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">System:: Int32 <a class="el" href="classDDS_1_1Sequence.html">DDS::Sequence</a>&lt; T &gt;::length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The logical length of this sequence. </p>
<p><b><em>Getting the property:</em></b></p>
<p>Get the length that was last set, or zero if the length has never been set. </p>
<p><b><em>Setting the property:</em></b></p>
<p>Change the length of this sequence.</p>
<p>This method does not allocate/deallocate memory. </p>
<p>The new length must not exceed the maximum of this sequence as returned by the <a class="el" href="classDDS_1_1Sequence.html#abe1b5200f7a295923c3cf4d9b52a1268" title="The current maximum number of elements that can be stored in this sequence.">DDS::Sequence::maximum</a> operation. (Note that, if necessary, the maximum of this sequence can be increased manually by using the <a class="el" href="classDDS_1_1Sequence.html#abe1b5200f7a295923c3cf4d9b52a1268" title="The current maximum number of elements that can be stored in this sequence.">DDS::Sequence::maximum</a> operation.) </p>
<p>The elements of the sequence are not modified by this operation. If the new length is larger than the original length, the new elements will be uninitialized; if the length is decreased, the old elements that are beyond the new length will physically remain in the sequence but will not be accessible. </p>
<dl class="section post"><dt>Postcondition</dt><dd>length = new_length. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_length</td><td>the new desired length. This value must be non-negative and cannot exceed maximum of the sequence. In other words 0 &lt;= new_length &lt;= maximum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe1b5200f7a295923c3cf4d9b52a1268"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual System:: Int32 <a class="el" href="classDDS_1_1Sequence.html">DDS::Sequence</a>&lt; T &gt;::maximum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current maximum number of elements that can be stored in this sequence. </p>
<p><b><em>Getting the property:</em></b></p>
<p>The <code>maximum</code> of the sequence represents the maximum number of elements that the underlying buffer can hold. It does not represent the current number of elements. </p>
<p>The <code>maximum</code> is a non-negative number. It is initialized when the sequence is first created. </p>
<p><code>maximum</code> can only be changed with the <a class="el" href="classDDS_1_1Sequence.html#abe1b5200f7a295923c3cf4d9b52a1268" title="The current maximum number of elements that can be stored in this sequence.">DDS::Sequence::maximum</a> operation. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classDDS_1_1Sequence.html#ae1dbca92f0e7622f82a3e06f5e14c03b" title="The logical length of this sequence.">DDS::Sequence::length</a></dd></dl>
<p><b><em>Setting the property:</em></b></p>
<p>Resize this sequence to a new desired maximum.</p>
<p>This operation does nothing if the new desired maximum matches the current maximum. </p>
<p>If this sequence owns its buffer and the new maximum is not equal to the old maximum, then the existing buffer will be freed and re-allocated. </p>
<dl class="section pre"><dt>Precondition</dt><dd>owned == true </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>owned == true </dd>
<dd>
length == MINIMUM(original length, new_max) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_max</td><td>Must be &gt;= 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad28b6977aee1953d70faaf7b64f737fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">array&lt; T&gt;^ <a class="el" href="classDDS_1_1Sequence.html">DDS::Sequence</a>&lt; T &gt;::buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the contiguous buffer of the sequence. </p>
<p>Get the underlying buffer where contiguous elements of the sequence are stored. The size of the buffer matches the maximum of the sequence, but only the elements up to the <a class="el" href="classDDS_1_1Sequence.html#ae1dbca92f0e7622f82a3e06f5e14c03b" title="The logical length of this sequence.">DDS::Sequence::length</a> of the sequence are valid. </p>
<p>This property is real-only. </p>
<p>This method provides almost no encapsulation of the sequence's underlying implementation. Certain operations, such as <a class="el" href="classDDS_1_1Sequence.html#abe1b5200f7a295923c3cf4d9b52a1268" title="The current maximum number of elements that can be stored in this sequence.">DDS::Sequence::maximum</a>, may render the buffer invalid. In light of these caveats, this operation should be used with care. </p>
<dl class="section return"><dt>Returns</dt><dd>buffer that stores contiguous elements in sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6b6d6d726cbd352eeefdbb6875d027b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">System:: Boolean <a class="el" href="classDDS_1_1Sequence.html">DDS::Sequence</a>&lt; T &gt;::has_ownership</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of the owned flag. </p>
<p>This property is real-only. </p>
<dl class="section return"><dt>Returns</dt><dd>true if sequence owns the underlying buffer, or false if it has an outstanding loan. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Connext .Net APIs Version 5.2.3</A>
Copyright &copy; Wed Apr 27 2016 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
