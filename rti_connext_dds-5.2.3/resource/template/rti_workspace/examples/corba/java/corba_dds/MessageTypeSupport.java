
/*
  WARNING: THIS FILE IS AUTO-GENERATED. DO NOT MODIFY.

  This file was generated from .idl using "rtiddsgen".
  The rtiddsgen tool is part of the RTI Connext distribution.
  For more information, type 'rtiddsgen -help' at a command shell
  or consult the RTI Connext user manual.
*/
    

import com.rti.dds.cdr.CdrEncapsulation;
import com.rti.dds.cdr.CdrInputStream;
import com.rti.dds.cdr.CdrOutputStream;
import com.rti.dds.cdr.CdrPrimitiveType;
import com.rti.dds.cdr.CdrBuffer;
import com.rti.dds.cdr.CdrHelper;
import com.rti.dds.domain.DomainParticipant;
import com.rti.dds.publication.DataWriter;
import com.rti.dds.publication.DataWriterListener;
import com.rti.dds.subscription.DataReader;
import com.rti.dds.subscription.DataReaderListener;
import com.rti.dds.topic.KeyHash_t;
import com.rti.dds.topic.TypeSupportImpl;
import com.rti.dds.topic.TypeSupportType;
import com.rti.dds.util.Sequence;
import com.rti.dds.topic.DefaultEndpointData;
import com.rti.dds.infrastructure.RETCODE_ERROR;

    
import com.rti.dds.topic.TypeSupportParticipantInfo;
import com.rti.dds.topic.TypeSupportEndpointInfo;
import com.rti.dds.typecode.TypeCode;


/**
 * A collection of useful methods for dealing with objects of type
 * Message.
 */
public final class MessageTypeSupport extends TypeSupportImpl {
    // -----------------------------------------------------------------------
    // Private Fields
    // -----------------------------------------------------------------------

    private static final String TYPE_NAME = "Message";

    private static final char[] PLUGIN_VERSION = {2, 0, 0, 0};

    private static final MessageTypeSupport _singleton
        = new MessageTypeSupport();
    
    // -----------------------------------------------------------------------
    // Public Methods
    // -----------------------------------------------------------------------

    // --- External methods: -------------------------------------------------
    /* The methods in this section are for use by users of RTI Connext.
     */

    public static String get_type_name() {
        return _singleton.get_type_nameI();
    }

    public static void register_type(DomainParticipant participant,
                                     String type_name) {
        _singleton.register_typeI(participant, type_name);
    }

    public static void unregister_type(DomainParticipant participant,
                                       String type_name) {
        _singleton.unregister_typeI(participant, type_name);
    }


    
     /* The methods in this section are for use by RTI Connext
     * itself and by the code generated by rtiddsgen for other types.
     * They should be used directly or modified only by advanced users and are
     * subject to change in future versions of RTI Connext.
     */
    public static MessageTypeSupport get_instance() {
        return _singleton;
    }

    /* deprecated API */
    public static MessageTypeSupport getInstance() {
        return get_instance();
    }

    public Object create_data() {
        Message instance = new Message();
        
        instance.time = (DateTime) DateTimeTypeSupport.get_instance().create_data();
            
        return instance;
    }

    public void destroy_data(Object data) {
        return;
    }

    public Object create_key() {
        Message instance = new Message();
        
        instance.time = (DateTime) DateTimeTypeSupport.get_instance().create_data();
            
        return instance;
    }

    public void destroy_key(Object key) {
        return;
    }

    public Class get_type() {
        return Message.class;
    }

    /**
     * This is a concrete implementation of this method inherited from the base class.
     * This method will perform a deep copy of <code>source</code> into
     * <code>destination</code>.
     * 
     * @param src The Object which contains the data to be copied.
     * @return Returns <code>destination</code>.
     * @exception NullPointerException If <code>destination</code> or 
     * <code>source</code> is null.
     * @exception ClassCastException If either <code>destination</code> or
     * <code>this</code> is not a <code>Message</code>
     * type.
     */
    public Object copy_data(Object destination, Object source) {
        Message typedDst = (Message) destination;
        Message typedSrc = (Message) source;

	
        typedDst.time = (DateTime) DateTimeTypeSupport.get_instance().copy_data(typedDst.time, typedSrc.time);
            
        typedDst.msg = typedSrc.msg;
            
        return typedDst;
    }

    public boolean are_samples_equal(Message sample,
                                     Message sample2) {
        
        if(!DateTimeTypeSupport.get_instance().are_samples_equal(sample.time, sample2.time)) {
            return false;
        }
            
        if(!sample.msg.equals(sample2.msg)) {
            return false;
        }
            
        return true;
    }

    
    public String sample_toString(Message sample, String desc, int indent) {
        StringBuffer strBuffer = new StringBuffer();
        

        if (desc != null) {
            CdrHelper.printIndent(strBuffer, indent);
            strBuffer.append(desc).append(":\n");
        }
      
        
        strBuffer.append(DateTimeTypeSupport.get_instance().sample_toString(sample.time, "time ", indent+1));
            
        CdrHelper.printIndent(strBuffer, indent+1);
        strBuffer.append("msg: ").append(sample.msg).append("\n");
            
        return strBuffer.toString();
    }

    
    public long get_serialized_sample_max_size(Object endpoint_data,boolean include_encapsulation, short encapsulation_id, long current_alignment) {

        long encapsulation_size = current_alignment;

        long origAlignment = current_alignment;


        if(include_encapsulation) {
            if (!CdrEncapsulation.isValidEncapsulationKind(encapsulation_id)) {
                throw new RETCODE_ERROR("Unsupported encapsulation");
            }


            encapsulation_size += CdrPrimitiveType.SHORT.getMaxSizeSerialized(encapsulation_size);
            encapsulation_size += CdrPrimitiveType.SHORT.getMaxSizeSerialized(encapsulation_size);
            encapsulation_size -= current_alignment;
            current_alignment = 0;
            origAlignment = 0;

        }


        current_alignment +=  DateTimeTypeSupport.get_instance().get_serialized_sample_max_size(endpoint_data,false, encapsulation_id, current_alignment);
            
        current_alignment +=  CdrPrimitiveType.getStringMaxSizeSerialized(current_alignment, (((MSG_MAX_LENGTH.value))) + 1);
            
        if (include_encapsulation) {
            current_alignment += encapsulation_size;
        }


        if ((current_alignment - origAlignment) == 0) {
            return 1;
        } else {
            return current_alignment - origAlignment;
        }

    }

    
    public long get_serialized_sample_min_size(Object endpoint_data,boolean include_encapsulation,short encapsulation_id,long current_alignment) {

        long encapsulation_size = current_alignment;

        long origAlignment = current_alignment;
        
    
        if(include_encapsulation) {
            if (!CdrEncapsulation.isValidEncapsulationKind(encapsulation_id)) {
                throw new RETCODE_ERROR("Unsupported encapsulation");
            }


            encapsulation_size += CdrPrimitiveType.SHORT.getMaxSizeSerialized(encapsulation_size);
            encapsulation_size += CdrPrimitiveType.SHORT.getMaxSizeSerialized(encapsulation_size);
            encapsulation_size -= current_alignment;
            current_alignment = 0;
            origAlignment = 0;

        }
    
        
        current_alignment +=  DateTimeTypeSupport.get_instance().get_serialized_sample_min_size(endpoint_data,false, encapsulation_id, current_alignment);
            
        current_alignment +=  CdrPrimitiveType.getStringMaxSizeSerialized(current_alignment, 1);
            
        if (include_encapsulation) {
            current_alignment += encapsulation_size;
        }

        
        if ((current_alignment - origAlignment) == 0) {
            return 1;
        } else {
            return current_alignment - origAlignment;
        }    
    }

    
    public long get_serialized_sample_size(
        Object endpoint_data, boolean include_encapsulation, 
        short encapsulation_id, int current_alignment,
        Object sample) 
    {
        long origAlignment = current_alignment;

        long encapsulation_size = current_alignment;
        Message typedSrc = (Message) sample;
    
        if(include_encapsulation) {
            if (!CdrEncapsulation.isValidEncapsulationKind(encapsulation_id)) {
                throw new RETCODE_ERROR("Unsupported encapsulation");
            }


            encapsulation_size += CdrPrimitiveType.SHORT.getMaxSizeSerialized(encapsulation_size);
            encapsulation_size += CdrPrimitiveType.SHORT.getMaxSizeSerialized(encapsulation_size);
            encapsulation_size -= current_alignment;
            current_alignment = 0;
            origAlignment = 0;

        }
    

        current_alignment += DateTimeTypeSupport.get_instance().get_serialized_sample_size(
            endpoint_data,false,encapsulation_id,current_alignment,typedSrc.time);
            
        current_alignment += CdrPrimitiveType.getStringSerializedSize(current_alignment, typedSrc.msg);
            
        if (include_encapsulation) {
            current_alignment += encapsulation_size;
        }

        return current_alignment - origAlignment;
    }

    
    public long get_serialized_key_max_size(
        Object endpoint_data,
        boolean include_encapsulation, 
        short encapsulation_id,
        long current_alignment) 
    {

        long encapsulation_size = current_alignment;

        long origAlignment = current_alignment;
        
    
        if(include_encapsulation) {
            if (!CdrEncapsulation.isValidEncapsulationKind(encapsulation_id)) {
                throw new RETCODE_ERROR("Unsupported encapsulation");
            }


            encapsulation_size += CdrPrimitiveType.SHORT.getMaxSizeSerialized(encapsulation_size);
            encapsulation_size += CdrPrimitiveType.SHORT.getMaxSizeSerialized(encapsulation_size);
            encapsulation_size -= current_alignment;
            current_alignment = 0;
            origAlignment = 0;

        }
    

    current_alignment += get_serialized_sample_max_size(
                            endpoint_data,false,encapsulation_id,current_alignment);
    
        if (include_encapsulation) {
            current_alignment += encapsulation_size;
        }


        if ((current_alignment - origAlignment) == 0) {
            return 1;
        } else {
            return current_alignment - origAlignment;
        }
    }

    
    public void serialize(Object endpoint_data,Object src,CdrOutputStream dst,
                          boolean serialize_encapsulation, short encapsulation_id, 
                          boolean serialize_sample,  Object endpoint_plugin_qos) {
        int position = 0;
Message typedSrc = (Message) src;    
        
        if(serialize_encapsulation) {
            dst.serializeAndSetCdrEncapsulation(encapsulation_id);


            position = dst.resetAlignment();

        }

        if(serialize_sample) {

        DateTimeTypeSupport.get_instance().serialize(endpoint_data, typedSrc.time, dst, false, encapsulation_id, true, endpoint_plugin_qos);
            
        dst.writeString(typedSrc.msg,((MSG_MAX_LENGTH.value)));
            
        }


        if (serialize_encapsulation) {
            dst.restoreAlignment(position);
        }

    }

    
    public void serialize_key(
        Object endpoint_data,
        Object src, 
        CdrOutputStream dst, 
        boolean serialize_encapsulation,
        short encapsulation_id,
        boolean serialize_key, 
        Object endpoint_plugin_qos) 
    {
        int position = 0;

        if (serialize_encapsulation) {
            dst.serializeAndSetCdrEncapsulation(encapsulation_id);


            position = dst.resetAlignment();

        }
    
        if (serialize_key) {
Message typedSrc = (Message) src;    

            serialize(endpoint_data, src, dst, false, encapsulation_id,true, endpoint_plugin_qos);
    
        }


        if (serialize_encapsulation) {
            dst.restoreAlignment(position);
        }

    }

    
    public Object deserialize_sample(
        Object endpoint_data,
        Object dst, 
        CdrInputStream src,
        boolean deserialize_encapsulation,
        boolean deserialize_sample, 
        Object endpoint_plugin_qos) 
    {
        int position = 0;
Message typedDst = (Message) dst;

        if(deserialize_encapsulation) {
            src.deserializeAndSetCdrEncapsulation();


            position = src.resetAlignment();

        }


        if(deserialize_sample) {

            typedDst.time = (DateTime) DateTimeTypeSupport.get_instance().deserialize_sample(endpoint_data, typedDst.time, src, false, true, endpoint_plugin_qos);
            
            typedDst.msg = src.readString();
            
        }


        if (deserialize_encapsulation) {
            src.restoreAlignment(position);
        }


        return dst;
    }

    
    public Object deserialize_key_sample(
        Object endpoint_data,
        Object dst, 
        CdrInputStream src, 
        boolean deserialize_encapsulation,
        boolean deserialize_key,
        Object endpoint_plugin_qos) 
    {
        int position = 0;

        if(deserialize_encapsulation) {
            src.deserializeAndSetCdrEncapsulation();


            position = src.resetAlignment();

        }
    
        if(deserialize_key) {
Message typedDst = (Message) dst;
    

            deserialize_sample(endpoint_data, dst, src, false, true, endpoint_plugin_qos);
    
        }


        if (deserialize_encapsulation) {
            src.restoreAlignment(position);
        }


        return dst;
    }

    
    public void skip(Object endpoint_data, 
                     CdrInputStream src,
                     boolean skip_encapsulation, 
                     boolean skip_sample, 
                     Object endpoint_plugin_qos)
    {
        int position = 0;

    
        if (skip_encapsulation) {
            src.skipEncapsulation();


            position = src.resetAlignment();

        }
    
        if (skip_sample) {

            DateTimeTypeSupport.get_instance().skip(endpoint_data, src, false, true, endpoint_plugin_qos);
            
            src.skipString();
            
        }


        if (skip_encapsulation) {
            src.restoreAlignment(position);
        }

    }

    public Object serialized_sample_to_key(
        Object endpoint_data,
        Object sample,
        CdrInputStream src, 
        boolean deserialize_encapsulation,  
        boolean deserialize_key, 
        Object endpoint_plugin_qos) {
        int position = 0;


        if(deserialize_encapsulation) {
            src.deserializeAndSetCdrEncapsulation();


            position = src.resetAlignment();

        }

        if (deserialize_key) {
Message typedDst = (Message) sample;

            deserialize_sample(
                endpoint_data, sample, src, false, 
                true, endpoint_plugin_qos);

        }


        if (deserialize_encapsulation) {
            src.restoreAlignment(position);
        }


        return sample;
    }



    // -----------------------------------------------------------------------
    // Callbacks
    // -----------------------------------------------------------------------

    public Object on_participant_attached(Object registration_data,
                                          TypeSupportParticipantInfo participant_info,
                                          boolean top_level_registration,
                                          Object container_plugin_context,
                                          TypeCode type_code) {
        return super.on_participant_attached(
            registration_data, participant_info, top_level_registration,
            container_plugin_context, type_code);
    }

    public void on_participant_detached(Object participant_data) {
        super.on_participant_detached(participant_data);
    }

    public Object on_endpoint_attached(Object participantData,
                                       TypeSupportEndpointInfo endpoint_info,
                                       boolean top_level_registration,
                                       Object container_plugin_context) {
        return super.on_endpoint_attached(
              participantData,  endpoint_info,  
              top_level_registration, container_plugin_context);        
    }

    public void on_endpoint_detached(Object endpoint_data) {
        super.on_endpoint_detached(endpoint_data);
    }

    // -----------------------------------------------------------------------
    // Protected Methods
    // -----------------------------------------------------------------------

    protected DataWriter create_datawriter(long native_writer,
                                           DataWriterListener listener,
                                           int mask) {
        
        return new MessageDataWriter(native_writer, listener, mask, this);                
            
    }

    protected DataReader create_datareader(long native_reader,
                                           DataReaderListener listener,
                                           int mask) {
        
        return new MessageDataReader(native_reader, listener, mask, this);                
            
    }

    // -----------------------------------------------------------------------
    // Constructor
    // -----------------------------------------------------------------------

    private MessageTypeSupport() {
        
        /* If the user data type supports keys, then the second argument
        to the constructor below should be true.  Otherwise it should
        be false. */        

        super(TYPE_NAME, false,MessageTypeCode.VALUE,Message.class,TypeSupportType.TST_STRUCT, PLUGIN_VERSION);
    
    }

    protected MessageTypeSupport(boolean enableKeySupport) {
    
        super(TYPE_NAME, enableKeySupport,MessageTypeCode.VALUE,Message.class,TypeSupportType.TST_STRUCT, PLUGIN_VERSION);
    }
}
