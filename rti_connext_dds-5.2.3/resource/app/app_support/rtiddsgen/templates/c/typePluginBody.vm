##/* $Id$
##
##   (c) Copyright, Real-Time Innovations, Inc. 2001.  All rights reserved.
##   No duplications, whole or partial, manual or electronic, may be made
##   without prior written permission.  Any such copies, or
##   revisions thereof, must display this notice unaltered.
##   This code contains trade secrets of Real-Time Innovations, Inc.

##modification history:
##---------------------
##2.3,02feb16, ajm CODEGENII-462 Warning when using -Wunused-parameter
##2.0,13nov15,ajm CODEGENII-501 Setting the option to disable must understand for interlanguage
## iteroperability 
##2.0,24mar15, CODEGENII-433 Incorrect code generation for a mutable struct that inherits
## from a struct with key
##2.0,25feb15,acr CORE-6269: Use PRES_TYPEPLUGIN_CPP_LANG for C++ plugins
##2.0,05feb15,ajm CODEGENII-426 Fixing warning
##2.0,18sep14,ajm CODEGENII-364 and CODEGENII-365 Unbounded sequence and string in C/C++
##2.2.0,08sep14,ajm CODEGENII-359 Add APIs to serialize a sample to a CDR buffer and to 
## deserialize from a CDR buffer##2.0,30oct13,ajm CODEGENII-147 removing warnings
##2.0,29oct13,ajm CODEGENII-143 fixing nddsgen1 issues CODEGEN-620 CODEGEN-624
##2.0,12sep13,ajm CODEGENII-143 and CODEGEN-622 Enum as last field of a type
##2.0,12sep13,ajm CODEGENII-92: Support for optional members
##10a,10jun13,ajm CODEGENII-109 adding envMap and constructMapList variables
##10a,25mar13,ajm Adding support for enums and inheritance in .Net. We do check now
## it we are working with namespaces because we introduce always the module in the list of nodes
##10a,08mar13, ajm CODEGENII-30: Code reviews
##10a,01mar13, ajm CODEGENII-59: Updating to generate XTypes Mutable as in IN-Branch
##10a,16jan13, ajm RRTIDDSGEN-52 Renaming variables and functions for the codereview
##10a,13dec12, ajm RRTIDDSGEN-53 Support for XTypes (extensible and final)
##10a,4dec12, ajm Refactoring of the code and variable names.
##10a,8nov12, ajm  RRTIDDSGEN-34 support for the copy directives and resolve-name
##10a,25oct12, ajm Refactorizing code and variable names.
##                 RRTIDDSGEN-32 support for -use42eAlignment and -generateCTypecode
##10a,10oct12, ajm Upgrade to Bigpine.Formatting and commenting
##10a,04ene11, ajm Upgrading to Lola (code in C)
##10a,07nov11, ajm Refactoring code
##10a,21oct11,ajm Adding a return at the end of the file
##10a,17oct11,ajm Fixing a bug with enums and c++ namespaces
##10a,10oct11,ajm Adding union support
##10a,30sep11,ajm Adding noTypeCode option support
##10a,29sep11,ajm adding forward declaration and namespace support 
##10a,26sep11,ajm adding enum support 
##10a,22sep11,ajm Fixing a bug
##10a,22sep11,ajm adding valuetypes support
##10a,15sep11,ajm Fixing more typedef issues
##10a,14sep11,ajm Refactor typedef
##10a,2sep11,ajm Refactoring using a unique list for all elements(typedefs, structs and const)
##10a,2sep11,jmt Adding typedef support for sequences and arrays of sequences
##10a,01se11,jmt Adding typedef support for primitive types and typedef arrays
##10a,29ag11,ajm Fixing macros consistency by adding the missing parameters
##10a,29ag11,ajm Refactor of variables and cleaning loops 
##10a,19ag11,ajm Refactorizing and cleaning the templates code.
##10a,17ag11,ajm Adding //@key
##10a,12ag11,jmt Adding functionality for C++
##10a,11ag11,ajm Refactorizing the templates code.
##           ajm Adding variable $nativeFQName
##10a,10ag11,ajm Adding functionality for arrays
##10a,09ag11,jmt Fixing tabulations and length of the lines
##10a,08ag11,ajm Fixing an error in the template (it includes now the plugin file header intead the type file header file)
##10a,08ag11,ajm Fixing the bug for a struct without a module
##10a,05ag11,jmt Adding all the basic type and testing them
##10a,04ag11,ajm adding modification history header 
##10a,03ag11,ajm created 
##-----------------------------------------------------------------
##               
##             Template for the TypePluginBody C file
## 
##------------------------------------------------------------------
##------------------------------------------------------------------
## Structure:
##
## 
## To use this template, the structure provided from the main program
## to the context of the Velocity template must be as indicated here:
##
## The context will be feed by a list of the structs ($constructMapList) defined in the 
## IDL file. Each of the structs will have the following mandatory fields:
##
## $packageName (the path of all the modules separated by a .)
## $nodeName (the name of the struct)
## $memberFieldMapList (will be a list of all the members inside the struct)
## $memberFieldMapList must contain the followin fields:
##   name (the name of the field)
##   typeFQName (the IDL type of the variable)
##   basic (boolean, it indicates if it is a basic or non basic type)
##---------------------------------------------------------------------
##---------------------------------------------------------------------

/*
  WARNING: THIS FILE IS AUTO-GENERATED. DO NOT MODIFY.

  This file was generated from ${envMap.idlFileName}.idl using "rtiddsgen".
  The rtiddsgen tool is part of the RTI Connext distribution.
  For more information, type 'rtiddsgen -help' at a command shell
  or consult the RTI Connext manual.
*/


${envMap.POUND_CHAR}include <string.h>

#*----*##if($envMap.language.equals("Cpp"))
${envMap.POUND_CHAR}ifndef ndds_cpp_h
  ${envMap.POUND_CHAR}include "ndds/ndds_cpp.h"
${envMap.POUND_CHAR}endif
#else
${envMap.POUND_CHAR}ifndef ndds_c_h
  ${envMap.POUND_CHAR}include "ndds/ndds_c.h"
${envMap.POUND_CHAR}endif
#end

${envMap.POUND_CHAR}ifndef osapi_type_h
  ${envMap.POUND_CHAR}include "osapi/osapi_type.h"
${envMap.POUND_CHAR}endif
${envMap.POUND_CHAR}ifndef osapi_heap_h
  ${envMap.POUND_CHAR}include "osapi/osapi_heap.h"
${envMap.POUND_CHAR}endif

${envMap.POUND_CHAR}ifndef osapi_utility_h
  ${envMap.POUND_CHAR}include "osapi/osapi_utility.h"
${envMap.POUND_CHAR}endif

${envMap.POUND_CHAR}ifndef cdr_type_h
  ${envMap.POUND_CHAR}include "cdr/cdr_type.h"
${envMap.POUND_CHAR}endif

${envMap.POUND_CHAR}ifndef cdr_type_object_h
  ${envMap.POUND_CHAR}include "cdr/cdr_typeObject.h"
${envMap.POUND_CHAR}endif

${envMap.POUND_CHAR}ifndef cdr_encapsulation_h
  ${envMap.POUND_CHAR}include "cdr/cdr_encapsulation.h"
${envMap.POUND_CHAR}endif

${envMap.POUND_CHAR}ifndef cdr_stream_h
  ${envMap.POUND_CHAR}include "cdr/cdr_stream.h"
${envMap.POUND_CHAR}endif

${envMap.POUND_CHAR}ifndef pres_typePlugin_h
  ${envMap.POUND_CHAR}include "pres/pres_typePlugin.h"
${envMap.POUND_CHAR}endif



${envMap.POUND_CHAR}include "${envMap.idlFileName}Plugin.h"


#*--*##foreach($node in $constructMapList)
##if it is a directive we print its value
#*----*##if($node.constructKind=="directive") 
##we avoid to copy the declaration directives
#*------*##if($node.directiveKind=="copy-c"||$node.directiveKind=="copy") 
$node.value
#*------*##end
#*----*##elseif($node.constructKind=="module" && ${envMap.namespace})
namespace $node.name {
#*----*##elseif($node.constructKind=="moduleClose" && ${envMap.namespace}) 
} /* namespace $node.name  */
#*----*##elseif(($node.constructKind=="alias")
           ||($node.isAggregationType))

/* ----------------------------------------------------------------------------
 *  Type ${node.nativeFQNameInModule}
 * -------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
    Support functions:
 * -------------------------------------------------------------------------- */
 
${node.nativeFQNameInModule}*
${node.nativeFQNameInModule}PluginSupport_create_data_w_params(
    const struct DDS_TypeAllocationParams_t * alloc_params){
    ${node.nativeFQNameInModule} *sample = NULL;

    RTIOsapiHeap_allocateStructure(
        &sample, ${node.nativeFQNameInModule});

    if(sample != NULL) {
        if (!${node.nativeFQName}_initialize_w_params(sample,alloc_params)) {
            RTIOsapiHeap_freeStructure(sample);
            return NULL;
        }
    }        
    return sample; 
} 

${node.nativeFQNameInModule} *
${node.nativeFQNameInModule}PluginSupport_create_data_ex(RTIBool allocate_pointers){
    ${node.nativeFQNameInModule} *sample = NULL;

    RTIOsapiHeap_allocateStructure(
        &sample, ${node.nativeFQNameInModule});

    if(sample != NULL) {
        if (!${node.nativeFQName}_initialize_ex(sample,allocate_pointers, RTI_TRUE)) {
            RTIOsapiHeap_freeStructure(sample);
            return NULL;
        }
    }
    return sample; 
}


#*-****************************************************************-*#
${node.nativeFQNameInModule} *
${node.nativeFQNameInModule}PluginSupport_create_data(void)
{
    return ${node.nativeFQName}PluginSupport_create_data_ex(RTI_TRUE);
}

#*-****************************************************************-*#
void 
${node.nativeFQNameInModule}PluginSupport_destroy_data_w_params(
    ${node.nativeFQNameInModule} *sample,
    const struct DDS_TypeDeallocationParams_t * dealloc_params) {

    ${node.nativeFQName}_finalize_w_params(sample,dealloc_params);

    RTIOsapiHeap_freeStructure(sample);
}

#*-****************************************************************-*#
void 
${node.nativeFQNameInModule}PluginSupport_destroy_data_ex(
    ${node.nativeFQNameInModule} *sample,RTIBool deallocate_pointers) {

    ${node.nativeFQName}_finalize_ex(sample,deallocate_pointers);

    RTIOsapiHeap_freeStructure(sample);
}


#*-****************************************************************-*#
void 
${node.nativeFQNameInModule}PluginSupport_destroy_data(
    ${node.nativeFQNameInModule} *sample) {

    ${node.nativeFQName}PluginSupport_destroy_data_ex(sample,RTI_TRUE);

}


#*-****************************************************************-*#
RTIBool 
${node.nativeFQNameInModule}PluginSupport_copy_data(
    ${node.nativeFQNameInModule} *dst,
    const ${node.nativeFQNameInModule} *src)
{
    return ${node.nativeFQName}_copy(dst,src);
}


#*-****************************************************************-*#
void 
${node.nativeFQNameInModule}PluginSupport_print_data(
    const ${node.nativeFQNameInModule} *sample,
    const char *desc,
    unsigned int indent_level)
{


    RTICdrType_printIndent(indent_level);

    if (desc != NULL) {
      RTILog_debug("%s:\n", desc);
    } else {
      RTILog_debug("\n");
    }

    if (sample == NULL) {
      RTILog_debug("NULL\n");
      return;
    }

#*-****************************************************************-*#
#*------*##if(${node.baseTypeFQName})
${node.baseTypeFQName}PluginSupport_print_data((const ${node.baseTypeFQName}*)sample,"",indent_level);
#*------*##end

#*------*##if($node.constructKind=="union")
#*------*##printMember($node.unionDiscriminatorMap)

 switch(sample->_d) {
#*------*##end 

#print($node) ## Call to a macro toy print the members

#*------*##if($node.constructKind=="union")
    }
#*------*##end
               
}
##----------------------------------------------------
## This code is only generated if the struct has a key
##----------------------------------------------------
#*------*##if($node.hasKey ||  $node.hasKeyBaseType)
${node.nativeFQNameInModule} *
${node.nativeFQNameInModule}PluginSupport_create_key_ex(RTIBool allocate_pointers){
   ${node.nativeFQNameInModule} *key = NULL;

    RTIOsapiHeap_allocateStructure(
        &key, ${node.nativeFQNameInModule}KeyHolder);

    ${node.nativeFQName}_initialize_ex(key,allocate_pointers, RTI_TRUE);
    return key;
}

#*-****************************************************************-*#
${node.nativeFQNameInModule} *
${node.nativeFQNameInModule}PluginSupport_create_key(void)
{
    return  ${node.nativeFQName}PluginSupport_create_key_ex(RTI_TRUE);
}

#*-****************************************************************-*#
void 
${node.nativeFQNameInModule}PluginSupport_destroy_key_ex(
   ${node.nativeFQNameInModule}KeyHolder *key,RTIBool deallocate_pointers)
{
    ${node.nativeFQName}_finalize_ex(key,deallocate_pointers);

    RTIOsapiHeap_freeStructure(key);
}

#*-****************************************************************-*#
void 
${node.nativeFQNameInModule}PluginSupport_destroy_key(
   ${node.nativeFQNameInModule}KeyHolder *key) {

  ${node.nativeFQName}PluginSupport_destroy_key_ex(key,RTI_TRUE);

}
#*------*##end ##if struct.hasKey

/* ----------------------------------------------------------------------------
    Callback functions:
 * ---------------------------------------------------------------------------- */


#*------*##if (($node.isAggregationType)
                  &&($node.topLevel=="true"))
                  
PRESTypePluginParticipantData 
${node.nativeFQNameInModule}Plugin_on_participant_attached(
    void *registration_data,
    const struct PRESTypePluginParticipantInfo *participant_info,
    RTIBool top_level_registration,
    void *container_plugin_context,
    RTICdrTypeCode *type_code)
{
    if (registration_data) {} /* To avoid warnings */
    if (participant_info) {} /* To avoid warnings */
    if (top_level_registration) {} /* To avoid warnings */
    if (container_plugin_context) {} /* To avoid warnings */
    if (type_code) {} /* To avoid warnings */
    

    return PRESTypePluginDefaultParticipantData_new(participant_info);

}
#*-****************************************************************-*#

void 
${node.nativeFQNameInModule}Plugin_on_participant_detached(
    PRESTypePluginParticipantData participant_data)
{

  PRESTypePluginDefaultParticipantData_delete(participant_data);
}

#*-****************************************************************-*#
PRESTypePluginEndpointData
${node.nativeFQNameInModule}Plugin_on_endpoint_attached(
    PRESTypePluginParticipantData participant_data,
    const struct PRESTypePluginEndpointInfo *endpoint_info,
    RTIBool top_level_registration, 
    void *containerPluginContext)
{
    PRESTypePluginEndpointData epd = NULL;
        

    unsigned int serializedSampleMaxSize;

##----------------------------------------------------
## This code is only generated if the struct has a key 
##----------------------------------------------------

#*--------*##if($node.hasKey || $node.hasKeyBaseType)
    unsigned int serializedKeyMaxSize;
#*--------*##end 

    if (top_level_registration) {} /* To avoid warnings */
    if (containerPluginContext) {} /* To avoid warnings */
    
    epd = PRESTypePluginDefaultEndpointData_new(
            participant_data,
            endpoint_info,
            (PRESTypePluginDefaultEndpointDataCreateSampleFunction)
            ${node.nativeFQName}PluginSupport_create_data,
            (PRESTypePluginDefaultEndpointDataDestroySampleFunction)
            ${node.nativeFQName}PluginSupport_destroy_data,
            #if($node.hasKey || $node.hasKeyBaseType)(PRESTypePluginDefaultEndpointDataCreateKeyFunction)
            ${node.nativeFQName}PluginSupport_create_key #else NULL #end,#*
            *##if($node.hasKey || $node.hasKeyBaseType)
            
            (PRESTypePluginDefaultEndpointDataDestroyKeyFunction)
            ${node.nativeFQName}PluginSupport_destroy_key#else NULL #end);

    if (epd == NULL) {
        return NULL;
    } 
##----------------------------------------------------
## This code is only generated if the struct has a key
##----------------------------------------------------    
#*--------*##if($node.hasKey || $node.hasKeyBaseType)
    serializedKeyMaxSize =  ${node.nativeFQName}Plugin_get_serialized_key_max_size(
        epd,RTI_FALSE,RTI_CDR_ENCAPSULATION_ID_CDR_BE,0);
    
    if(!PRESTypePluginDefaultEndpointData_createMD5StreamWithInfo(
            epd,endpoint_info,serializedKeyMaxSize))  
    {
        PRESTypePluginDefaultEndpointData_delete(epd);
        return NULL;
    }
    
   
    
#*--------*##end ##if struct.hasKey
  
 
    if (endpoint_info->endpointKind == PRES_TYPEPLUGIN_ENDPOINT_WRITER) {
#*--------*##if(($node.isAggregationType))
    serializedSampleMaxSize = ${node.nativeFQName}Plugin_get_serialized_sample_max_size(
            epd,RTI_FALSE,RTI_CDR_ENCAPSULATION_ID_CDR_BE,0);
            
        PRESTypePluginDefaultEndpointData_setMaxSizeSerializedSample(epd, serializedSampleMaxSize);
#*--------*##end    
    
        if (PRESTypePluginDefaultEndpointData_createWriterPool(
                epd,
                endpoint_info,
            (PRESTypePluginGetSerializedSampleMaxSizeFunction)
                ${node.nativeFQName}Plugin_get_serialized_sample_max_size, epd,
            (PRESTypePluginGetSerializedSampleSizeFunction)
            ${node.nativeFQName}Plugin_get_serialized_sample_size,
            epd) == RTI_FALSE) {
            PRESTypePluginDefaultEndpointData_delete(epd);
            return NULL;
        }
    }
    


    return epd;    
}

#*-****************************************************************-*#
void 
${node.nativeFQNameInModule}Plugin_on_endpoint_detached(
    PRESTypePluginEndpointData endpoint_data)
{  

    PRESTypePluginDefaultEndpointData_delete(endpoint_data);
}

#*-****************************************************************-*#
void    
${node.nativeFQNameInModule}Plugin_return_sample(
    PRESTypePluginEndpointData endpoint_data,
    ${node.nativeFQNameInModule} *sample,
    void *handle)
{
    
    ${node.nativeFQNameInModule}_finalize_optional_members(sample, RTI_TRUE);
           
    PRESTypePluginDefaultEndpointData_returnSample(
        endpoint_data, sample, handle);
}
 
#*-****************************************************************-*#
#*------*##end



RTIBool 
${node.nativeFQNameInModule}Plugin_copy_sample(
    PRESTypePluginEndpointData endpoint_data,
    ${node.nativeFQNameInModule} *dst,
    const ${node.nativeFQNameInModule} *src)
{
    if (endpoint_data) {} /* To avoid warnings */
    return ${node.nativeFQName}PluginSupport_copy_data(dst,src);
}
#*----*##end
#*----*##if(($node.constructKind=="alias")
            || ($node.constructKind=="enum") 
            ||($node.isAggregationType))
           

/* ----------------------------------------------------------------------------
    (De)Serialize functions:
 * ------------------------------------------------------------------------- */
#*------*##if (($node.isAggregationType)
                ||($node.constructKind=="alias")) 
unsigned int 
${node.nativeFQNameInModule}Plugin_get_serialized_sample_max_size(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment);
#*------*##end

RTIBool 
${node.nativeFQNameInModule}Plugin_serialize(
    PRESTypePluginEndpointData endpoint_data,
    const ${node.nativeFQNameInModule} *sample, 
    struct RTICdrStream *stream,    
    RTIBool serialize_encapsulation,
    RTIEncapsulationId encapsulation_id,
    RTIBool serialize_sample, 
    void *endpoint_plugin_qos)
{
   char * position = NULL;
#*------*##if($node.constructKind!="enum")##updating to lola
    RTIBool retval = RTI_TRUE;
    
#*--------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
|| ($node.hasOptionalMember))
    DDS_UnsignedLong memberId = 0;
    char *memberLengthPosition = NULL;
    RTIBool extended;
    struct RTICdrStreamState state;
#*--------*##end
#*--------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    RTIBool ignoreListEndId = RTI_FALSE;
#*--------*##end
#*------*##end


#*------*##if($envMap.rtidds42e)
    RTIBool topLevel;
#*------*##end


#*------*##if(!$node.baseTypeFQName) 
    if (endpoint_data) {} /* To avoid warnings */
    if (endpoint_plugin_qos) {} /* To avoid warnings */
#*------*##end  
 
#*------*##serializeEncapsulation($node)

  

  if(serialize_sample) {
#if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY") || $node.hasOptionalMember)
     &&$node.constructKind!="enum")
      if (RTICdrStream_isDirty(stream)) {
#*--------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
            ignoreListEndId = stream->_xTypesState.skipListEndId;
#*--------*##end
      } else {
            /* Top level */
            RTICdrStream_setDirtyBit(stream,RTI_TRUE);


#*------------*##if ($envMap.mutExtCode)
                stream->_xTypesState.useExtendedId = RTI_TRUE;
#*------------*##else
                if (PRESTypePluginDefaultEndpointData_getMaxSizeSerializedSample(endpoint_data) > 65535) {
                    stream->_xTypesState.useExtendedId = RTI_TRUE;
                } else {
                    stream->_xTypesState.useExtendedId = RTI_FALSE;
                }
#*------------*##end
       }
#*--------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
        stream->_xTypesState.skipListEndId = RTI_FALSE;
#*--------*##end


#*------*##end
#*------*##rtidds42Alignmet ("serialize")
  
#*------*##if ($node.constructKind=="enum")
    if (!RTICdrStream_serializeEnum(stream, sample))
    {
       return RTI_FALSE;
    }
  
#*------*##else  
#*--------*##if($node.baseTypeFQName)  
#*----------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    stream->_xTypesState.skipListEndId = RTI_TRUE;
#*----------*##end
    if (!${node.baseTypeFQName}Plugin_serialize(endpoint_data,
             (const ${node.baseTypeFQName}*)sample,stream,RTI_FALSE,encapsulation_id,
             RTI_TRUE,endpoint_plugin_qos)) {
        return RTI_FALSE;
    }
#*----------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    stream->_xTypesState.skipListEndId = RTI_FALSE;
#*----------*##end    
#*--------*##end  
#*------*##if($node.constructKind=="union")
#*--------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
        memberId = $node.unionDiscriminatorMap.id;
#*----------*##if($node.unionDiscriminatorMap.needExtendedId=="yes" )       
        extended = RTI_TRUE;
#*----------*##elseif($node.unionDiscriminatorMap.needExtendedId=="no")
        extended = RTI_FALSE;
#*----------*##else
        extended = stream->_xTypesState.useExtendedId;
#*----------*##end                                   
        memberLengthPosition = RTICdrStream_serializeParameterHeader(
                                   stream, &state, extended, memberId, RTI_FALSE);
#*------*##end                                   
#*--------*##serializeMember($node.unionDiscriminatorMap "")
#if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    if (!RTICdrStream_serializeParameterLength(
             stream, &state, extended, memberLengthPosition)) {
        return RTI_FALSE;
    } 
#end    
    switch(sample->_d) {
#*--------*##end 

#*--------*##serialize( $node.memberFieldMapList "serialize")
#*------*##end
#*------*##if($node.constructKind=="union")
    }
#*------*##end  
#*------*##if($envMap.rtidds42e)
    if (!serialize_encapsulation && topLevel) {
      RTICdrStream_restoreAlignment(stream,position);
    }
#*------*##end
#*------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY") &&$node.constructKind!="enum") 
#*------*##serializeEndMutable()
#*------*##end        
}


 
#*------*##if(!$envMap.rtidds42e)
  if(serialize_encapsulation) {
    RTICdrStream_restoreAlignment(stream,position);
  }
#*------*##end

#*------*##if($node.constructKind=="enum") ##updating to lola
  return RTI_TRUE;
#*------*##else
  return retval;
#*------*##end
}

#*-****************************************************************-*#
RTIBool 
${node.nativeFQNameInModule}Plugin_deserialize_sample(
    PRESTypePluginEndpointData endpoint_data,
    ${node.nativeFQNameInModule} *sample,
    struct RTICdrStream *stream,   
    RTIBool deserialize_encapsulation,
    RTIBool deserialize_sample, 
    void *endpoint_plugin_qos)
{

    char * position = NULL;
#*------*##if(($node.constructKind=="struct" ||$node.constructKind=="valueType" ) 
                 && ($node.extensibility.equals("EXTENSIBLE_EXTENSIBILITY")))
                                                                   
    RTIBool done = RTI_FALSE;
#*------*##elseif(($node.constructKind=="enum") 
                    && (!$node.extensibility.equals("FINAL_EXTENSIBILITY")))
    DDS_Enum enum_tmp;
#*------*##end

#*------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY") &&$node.constructKind!="enum")
|| $node.hasOptionalMember)
    DDS_UnsignedLong memberId = 0;
    DDS_UnsignedLong length = 0;
    RTIBool mustUnderstand = RTI_FALSE;
    struct RTICdrStreamState state;
    RTIBool extended;
#*--------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
 RTIBool end = RTI_FALSE;
#*--------*##end
#*------*##end

#*--*##if($envMap.rtidds42e)
    RTIBool topLevel;
#*--*##end

#*--*##if(!$node.baseTypeFQName) 
    if (endpoint_data) {} /* To avoid warnings */
    if (endpoint_plugin_qos) {} /* To avoid warnings */
#*--*##end    
#*--*##deserializeEncapsulation ($node)
    if(deserialize_sample) {
    

#*------*##rtidds42Alignmet ("deserialize")    

#*------*##if (($node.constructKind=="enum") 
                 && (!$node.extensibility.equals("FINAL_EXTENSIBILITY")))
    if (!RTICdrStream_deserializeEnum(stream, &enum_tmp))
    {
     return RTI_FALSE;
    }
    switch (enum_tmp) {
#*--------*##foreach($element in $node.memberFieldMapList)
#*----------*##if(!$element.duplicated)
        case $element.nativeFQNameInModule:
            *sample=$element.nativeFQNameInModule;
             break;
#*----------*##end   
#*--------*##end             
        default:
            stream->_xTypesState.unassignable = RTI_TRUE;
            return RTI_FALSE;
    }
      
#*------*##elseif ($node.constructKind=="enum")
if (!RTICdrStream_deserializeEnum(stream, sample))
    {
     return RTI_FALSE;
    }
#*------*##else
#*--------*##if(($node.constructKind!="union")&&(!$node.extensibility.equals("FINAL_EXTENSIBILITY")))
    ${node.nativeFQName}_initialize_ex(sample, RTI_FALSE, RTI_FALSE);
#if($node.baseTypeFQName) 
#if (($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) )
    {
        char *begin = RTICdrStream_getCurrentPosition(stream);
        RTICdrStream_pushState(stream, &state, -1);
#end        
        if (!${node.baseTypeFQName}Plugin_deserialize_sample(endpoint_data,
                  (${node.baseTypeFQName} *)sample,stream,RTI_FALSE,RTI_TRUE,
                  endpoint_plugin_qos)) {
              return RTI_FALSE;
        }
#if (($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) )        
        RTICdrStream_popState(
                stream, &state);
            RTICdrStream_setCurrentPosition(stream, begin);
        }     
#end
#end

#*--------*##end
#*------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))   
        while (end != RTI_TRUE && RTICdrStream_getRemainder(stream) > 0) {
#*--------*##mutableDeserializeHeader()
#*--------*##deserializeMutableType($node "deserialize_sample")
        }
#*------*##else
#*----------*##if($node.constructKind=="union")
#*------------*##deserializeMember( $node.unionDiscriminatorMap "deserialize_sample")
    switch(sample->_d) {
#*----------*##end 
#*------------*##deserialize( $node.memberFieldMapList "deserialize_sample")
#*----------*##if($node.constructKind=="union")
    }
#*----------*##end
#*--------*##end
#*------*##end  
#*------*##if($envMap.rtidds42e)   
   if (!deserialize_encapsulation && topLevel) {
            RTICdrStream_restoreAlignment(stream,position);
        }
#*------*##end
     }


#*------*##if(($node.constructKind=="struct" || $node.constructKind=="valueType")
                && ($node.extensibility.equals("EXTENSIBLE_EXTENSIBILITY"))) 
done = RTI_TRUE;
fin:
    if (done != RTI_TRUE && 
        RTICdrStream_getRemainder(stream) >=
           RTI_CDR_PARAMETER_HEADER_ALIGNMENT) {
        return RTI_FALSE;   
    }
#*------*##end
#*------*##if(!$envMap.rtidds42e)
    if(deserialize_encapsulation) {
        RTICdrStream_restoreAlignment(stream,position);
    }
#*------*##end

    return RTI_TRUE;
}

 #*-****************************************************************-*#
#*------*##if($node.isAggregationType)
RTIBool
${node.nativeFQNameInModule}Plugin_serialize_to_cdr_buffer(
    char * buffer,
    unsigned int * length,
    const ${node.nativeFQNameInModule} *sample)
{
    struct RTICdrStream stream;
    struct PRESTypePluginDefaultEndpointData epd;
    RTIBool result;
    
    if (length == NULL) {
        return RTI_FALSE;
    }
    
    epd._maxSizeSerializedSample =
        ${node.nativeFQNameInModule}Plugin_get_serialized_sample_max_size(
            NULL, RTI_TRUE, RTI_CDR_ENCAPSULATION_ID_CDR_NATIVE, 0);
    
    if (buffer == NULL) {
        *length = 
            ${node.nativeFQNameInModule}Plugin_get_serialized_sample_size(
                (PRESTypePluginEndpointData)&epd,
                RTI_TRUE,
                RTI_CDR_ENCAPSULATION_ID_CDR_NATIVE,
                0,
                sample);
        
        if (*length == 0) {
            return RTI_FALSE;
        }
        
        return RTI_TRUE;
    }    
    
    RTICdrStream_init(&stream);
    RTICdrStream_set(&stream, (char *)buffer, *length);
    
    result = ${node.nativeFQName}Plugin_serialize(
            (PRESTypePluginEndpointData)&epd, sample, &stream, 
            RTI_TRUE, RTI_CDR_ENCAPSULATION_ID_CDR_NATIVE, 
            RTI_TRUE, NULL);  
            
    *length = RTICdrStream_getCurrentPositionOffset(&stream);
    return result;     
}

RTIBool
${node.nativeFQNameInModule}Plugin_deserialize_from_cdr_buffer(
    ${node.nativeFQNameInModule} *sample,
    const char * buffer,
    unsigned int length)
{
    struct RTICdrStream stream;

    RTICdrStream_init(&stream);
    RTICdrStream_set(&stream, (char *)buffer, length);
    
    return ${node.nativeFQNameInModule}Plugin_deserialize_sample( 
        NULL, sample,
        &stream, RTI_TRUE, RTI_TRUE, 
        NULL);
}
 
RTIBool 
${node.nativeFQNameInModule}Plugin_deserialize(
    PRESTypePluginEndpointData endpoint_data,
    ${node.nativeFQNameInModule} **sample,
    RTIBool * drop_sample,
    struct RTICdrStream *stream,   
    RTIBool deserialize_encapsulation,
    RTIBool deserialize_sample, 
    void *endpoint_plugin_qos)
{

    RTIBool result;
    if (drop_sample) {} /* To avoid warnings */

    stream->_xTypesState.unassignable = RTI_FALSE;
    result= ${node.nativeFQName}Plugin_deserialize_sample( 
        endpoint_data, (sample != NULL)?*sample:NULL,
        stream, deserialize_encapsulation, deserialize_sample, 
        endpoint_plugin_qos);
        if (result) {
             if (stream->_xTypesState.unassignable) {
                 result = RTI_FALSE;
             }
        }
  
        return result;
 
}

#*------*##end
#*-****************************************************************-*#
RTIBool ${node.nativeFQNameInModule}Plugin_skip(
    PRESTypePluginEndpointData endpoint_data,
    struct RTICdrStream *stream,   
    RTIBool skip_encapsulation,
    RTIBool skip_sample, 
    void *endpoint_plugin_qos)
{
    char * position = NULL;
    
#*------*##if($envMap.rtidds42e)
    RTIBool topLevel;
#*------*##end
    
#*------*##if(($node.constructKind=="struct" ||$node.constructKind=="valueType" )
                   && ($node.extensibility.equals("EXTENSIBLE_EXTENSIBILITY")))
    RTIBool done = RTI_FALSE;
#*------*##end
#*------*##if((($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) && ($node.constructKind!="enum"))
               || ($node.hasOptionalMember))
    DDS_UnsignedLong memberId = 0;
    DDS_UnsignedLong length = 0;
    RTIBool mustUnderstand = RTI_FALSE;
    struct RTICdrStreamState state;
    RTIBool extended;
#*------*##end 

#*------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY") && (!$node.constructKind.equals("enum")))
 RTIBool end = RTI_FALSE;
#*------*##end

#*------*##if(!$node.baseTypeFQName) 
    if (endpoint_data) {} /* To avoid warnings */
    if (endpoint_plugin_qos) {} /* To avoid warnings */
#*------*##end

    if(skip_encapsulation) {
        if (!RTICdrStream_skipEncapsulation(stream)) {
            return RTI_FALSE;
        }

#*------*##if(!$envMap.rtidds42e)
        position = RTICdrStream_resetAlignment(stream);
#*------*##end
    }

    if (skip_sample) {
    
#*--------*##rtidds42Alignmet ("skip")
#*-------*##if($node.constructKind=="union" && $node.extensibility.equals("MUTABLE_EXTENSIBILITY")) 
     $node.unionDiscriminatorMap.nativeTypeFQName    disc;
#*----------*##elseif($node.baseTypeFQName) 
#*------------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))       
    {
        char *begin = RTICdrStream_getCurrentPosition(stream);
        RTICdrStream_pushState(stream, &state, -1);
#*------------*##end
        if (!${node.baseTypeFQName}Plugin_skip(endpoint_data,
                  stream,RTI_FALSE,RTI_TRUE,
                  endpoint_plugin_qos)) {
              return RTI_FALSE;
        }
#*------------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))      
        
        RTICdrStream_popState(
                stream, &state);
            RTICdrStream_setCurrentPosition(stream, begin);
        }     
#*------------*##end
#*------*##end   
#if($node.extensibility.equals("MUTABLE_EXTENSIBILITY")  && (!$node.constructKind.equals("enum")))       
        while (end != RTI_TRUE && RTICdrStream_getRemainder(stream) > 0) {
#*--------*##mutableDeserializeHeader()
#*------*##end   


#*------*##if($node.constructKind=="enum")   
        if (!RTICdrStream_skipEnum(stream)) {
            return RTI_FALSE;
        }
#*------*##else   
    
#*--------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))  
                && ($node.constructKind!="enum"))
#*----------*##skipMutable($node.memberFieldMapList)
        }
#*--------*##else     
#*----------*##if($node.constructKind=="union")
        $node.unionDiscriminatorMap.nativeTypeFQName disc;

#*------------*##if(($node.unionDiscriminatorMap.typeKind=="user")
                    ||($node.unionDiscriminatorMap.typeKind=="enum"))   
        if (!${node.unionDiscriminatorMap.nativeTypeFQName}Plugin_deserialize_sample(
            endpoint_data,
            &disc,
            stream, 
            RTI_FALSE, RTI_TRUE, 
            endpoint_plugin_qos)) {
                return RTI_FALSE;
        }
#*------------*##else
        if (!${node.unionDiscriminatorMap.elementDeserializeMethod}(
            stream, &disc)) {
                return RTI_FALSE;
        }

#*------------*##end   
 
        switch(disc) {
#*----------*##end 
   
#*----------*##skip($node.memberFieldMapList)
#*----------*##if($node.constructKind=="union")
        }
#*----------*##end
#*--------*##end
#*--------*##end
#*------*##if($envMap.rtidds42e) 
        if (!skip_encapsulation && topLevel) {
            RTICdrStream_restoreAlignment(stream,position);
        }
#*------*##end        
    }

#*------*##if(($node.constructKind=="struct" ||$node.constructKind=="valueType") 
                    && ($node.extensibility=="EXTENSIBLE_EXTENSIBILITY"))
    done = RTI_TRUE;
fin:
    if (done != RTI_TRUE && 
        RTICdrStream_getRemainder(stream) >=
           RTI_CDR_PARAMETER_HEADER_ALIGNMENT) {
        return RTI_FALSE;   
    }
#*------*##end
#*------*##if(!$envMap.rtidds42e) 
    if(skip_encapsulation) {
        RTICdrStream_restoreAlignment(stream,position);
    }
#*------*##end

    return RTI_TRUE;
}

#*-****************************************************************-*#
unsigned int 
${node.nativeFQNameInModule}Plugin_get_serialized_sample_max_size_ex(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool * overflow,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{

#if($node.hasUnboundedMember && $envMap.unboundedSupport)
  if (endpoint_data) {} /* To avoid warnings */
    if (include_encapsulation) {}
    if (encapsulation_id) {}
    if (current_alignment) {}
    
    if (overflow != NULL) {
        *overflow = RTI_TRUE;
    }
    
    return RTI_CDR_MAX_SERIALIZED_SIZE;

#else

#*------*##if($node.constructKind=="union")
    unsigned int union_max_size_serialized = 0;
#*------*##end

    unsigned int initial_alignment = current_alignment;

#*------*##if(!$envMap.rtidds42e)
    unsigned int encapsulation_size = current_alignment;
#*------*##end   
 
#*------*##if(!$node.baseTypeFQName && !$node.hasNonBasicMember)  
    if (endpoint_data) {} /* To avoid warnings */ 
    if (overflow) {} /* To avoid warnings */
#*------*##end   
#*--------*##getEncapsulation ($node)
#*------*##if($node.constructKind=="enum")
    current_alignment += RTICdrType_getEnumMaxSizeSerialized(current_alignment);
#*------*##else

#*--------*##if(${node.baseTypeFQName})  
    current_alignment += ${node.baseTypeFQName}Plugin_get_serialized_sample_max_size_ex(
                              endpoint_data,overflow,RTI_FALSE,encapsulation_id,current_alignment);
#*--------*##end
    
#*--------*##if($node.constructKind=="union")
#*----------*##alignmentMaxSizeExUnion($node) 
#*--------*##else
#*----------*##alignmentMaxSizeEx($node) 
#*--------*##end    
#*------*##end

#*------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    /* Sentinel */

#*--------*##if($node.constructKind=="union")
    union_max_size_serialized += RTICdrStream_getExtendedParameterHeaderMaxSizeSerialized(union_max_size_serialized);
#*--------*##else
    current_alignment += RTICdrStream_getExtendedParameterHeaderMaxSizeSerialized(current_alignment);
#*--------*##end
#*------*##end
#*------*##if(!$envMap.rtidds42e)            
    if (include_encapsulation) {
        current_alignment += encapsulation_size;
    }
#*------*##end
    return #if($node.constructKind=="union")union_max_size_serialized +#*
----------*##end current_alignment - initial_alignment;
#end
}


#*-****************************************************************-*#


#*------*##if($node.constructKind=="enum")

unsigned int 
${node.nativeFQNameInModule}Plugin_get_serialized_sample_max_size(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{
    unsigned int initial_alignment = current_alignment;

    current_alignment += ${node.nativeFQName}Plugin_get_serialized_sample_max_size_ex(
        endpoint_data,
        NULL,
        include_encapsulation,
        encapsulation_id, current_alignment);

    return current_alignment - initial_alignment;
}

unsigned int ${node.nativeFQNameInModule}Plugin_get_serialized_sample_min_size(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{
    unsigned int initial_alignment = current_alignment;

    current_alignment += ${node.nativeFQName}Plugin_get_serialized_sample_max_size(
        endpoint_data,include_encapsulation,
        encapsulation_id, current_alignment);

    return current_alignment - initial_alignment;
}
#*------*##else

unsigned int 
${node.nativeFQNameInModule}Plugin_get_serialized_sample_max_size(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{
    unsigned int size;
    RTIBool overflow = RTI_FALSE;
    
    size = ${node.nativeFQNameInModule}Plugin_get_serialized_sample_max_size_ex(
            endpoint_data,&overflow,include_encapsulation,encapsulation_id,current_alignment);
    
    if (overflow) {
        size = RTI_CDR_MAX_SERIALIZED_SIZE;
    }
    
    return size;
}

unsigned int 
${node.nativeFQNameInModule}Plugin_get_serialized_sample_min_size(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{

#*--------*##if(${node.constructKind}=="union")  
    unsigned int union_min_size_serialized = 0xffffffff;
#*--------*##end

    unsigned int initial_alignment = current_alignment;

#*--------*##if(!$envMap.rtidds42e)
    unsigned int encapsulation_size = current_alignment;
#*--------*##end   
 
#*--------*##if(!$node.baseTypeFQName)  
    if (endpoint_data) {} /* To avoid warnings */ 
#*--------*##end   
#*--------*##getEncapsulation ($node)
#*--------*##if(${node.baseTypeFQName})  
    current_alignment += ${node.baseTypeFQName}Plugin_get_serialized_sample_min_size(
                              endpoint_data,RTI_FALSE,encapsulation_id,current_alignment);
#*--------*##end

#*--------*##if($node.constructKind=="union")
#*----------*##alignmentMinSizeUnion($node) 
#*----------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    /* Sentinel */   
    union_min_size_serialized += RTICdrStream_getParameterHeaderMaxSizeSerialized(union_min_size_serialized);
#*----------*##end 
#*--------*##else
#*----------*##alignmentMinSize($node)
#*----------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    /* Sentinel */   
    current_alignment += RTICdrStream_getParameterHeaderMaxSizeSerialized(current_alignment);
#*----------*##end 
#*--------*##end  

#*--------*##if(!$envMap.rtidds42e)        
    if (include_encapsulation) {
        current_alignment += encapsulation_size;
    }
#*--------*##end
    return #if($node.constructKind=="union")#*
--------*# union_min_size_serialized +#end current_alignment - initial_alignment;
}
#*--------*##end
#*-****************************************************************-*#

/* Returns the size of the sample in its serialized form (in bytes).
 * It can also be an estimation in excess of the real buffer needed 
 * during a call to the serialize() function.
 * The value reported does not have to include the space for the
 * encapsulation flags.
 */
unsigned int
${node.nativeFQNameInModule}Plugin_get_serialized_sample_size(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment,
    const ${node.nativeFQNameInModule} * sample) 
{
  
   
    
#*------*##if($node.constructKind=="enum")

    unsigned int initial_alignment = current_alignment;
  
    if (sample==NULL) {
        return 0;
    }

    current_alignment += ${node.nativeFQName}Plugin_get_serialized_sample_max_size(
        endpoint_data,include_encapsulation,
        encapsulation_id, current_alignment);

    
#*------*##else
    unsigned int initial_alignment = current_alignment;

#*------*##if(!$envMap.rtidds42e)
    unsigned int encapsulation_size = current_alignment;
#*------*##end   
 
#*------*##if(!$node.baseTypeFQName)  
    if (endpoint_data) {} /* To avoid warnings */ 
    if (sample==NULL) {
        return 0;
    }
#*--------*##end
#*--------*##getEncapsulation ($node)  

#*--------*##if(${node.baseTypeFQName})  
    current_alignment += ${node.baseTypeFQName}Plugin_get_serialized_sample_size(endpoint_data,RTI_FALSE,encapsulation_id,current_alignment,(const ${node.baseTypeFQName}*)sample);   
#*--------*##end
#*--------*##if($node.constructKind=="union")
#*----------*##alignmentSampleUnion($node)   
#*--------*##else
#*----------*##alignmentSample($node) 
#*--------*##end      
#*----------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    /* Sentinel */   
    current_alignment += RTICdrStream_getParameterHeaderMaxSizeSerialized(current_alignment);
#*----------*##end

#*--------*##if(!$envMap.rtidds42e)            
    if (include_encapsulation) {
        current_alignment += encapsulation_size;
    }
#*--------*##end    
#*------*##end
    return current_alignment - initial_alignment;
}

/* --------------------------------------------------------------------------------------
    Key Management functions:
 * -------------------------------------------------------------------------------------- */

#*------*##if($node.constructKind!="enum")
PRESTypePluginKeyKind 
${node.nativeFQNameInModule}Plugin_get_key_kind(void)
{
#*--------*##if($node.hasKey || $node.hasKeyBaseType)
    return PRES_TYPEPLUGIN_USER_KEY;
#*--------*##else    
    return PRES_TYPEPLUGIN_NO_KEY;
#*--------*##end     
}
#*------*##end

RTIBool 
${node.nativeFQNameInModule}Plugin_serialize_key(
    PRESTypePluginEndpointData endpoint_data,
    const ${node.nativeFQNameInModule} *sample, 
    struct RTICdrStream *stream,    
    RTIBool serialize_encapsulation,
    RTIEncapsulationId encapsulation_id,
    RTIBool serialize_key,
    void *endpoint_plugin_qos)
{
#*------*##if($node.constructKind=="enum")
    return  ${node.nativeFQName}Plugin_serialize(
            endpoint_data, sample, stream, 
            serialize_encapsulation, encapsulation_id, 
            serialize_key, endpoint_plugin_qos);

#*------*##else
    char * position = NULL;
#*--------*##if($envMap.rtidds42e)
    RTIBool topLevel;
#*--------*##end
#* If is an alias of nonbasic type or
   it has a key but it is not a complex member key and it does not have a key in the parent*#
#*--------*##if(($node.constructKind.equals("alias") && $node.firstMember.typeKind.equals("builtin"))
                || ($node.hasKey && !$node.hasNonBasicKeyMember && !$node.hasKeyBaseType))
    if (endpoint_data) {} /* To avoid warnings */
    if (endpoint_plugin_qos) {} /* To avoid warnings */
#*--------*##end  
    
#*--------*##serializeEncapsulation ($node)

    if(serialize_key) {
    


#*--------*##rtidds42Alignmet ("serialize")

    

#*----------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) 
            && ($node.hasKeyBaseType || $node.hasKey))
        { 
            RTIBool ignoreListEndId = RTI_FALSE;
            DDS_UnsignedLong memberId = 0;
            char *memberLengthPosition = NULL;
            RTIBool extended=RTI_FALSE;
#*------------*##if($node.hasKey)           
            struct RTICdrStreamState state;
#*------------*##end            
    
            if (RTICdrStream_isDirty(stream)) {
                ignoreListEndId = stream->_xTypesState.skipListEndId; 
            } else {
            /* Top level */
                RTICdrStream_setDirtyBit(stream,RTI_TRUE);

#*------------*##if ($envMap.mutExtCode)
                stream->_xTypesState.useExtendedId = RTI_TRUE;
#*------------*##else
                if (PRESTypePluginDefaultEndpointData_getMaxSizeSerializedSample(endpoint_data) > 65535) {
                    stream->_xTypesState.useExtendedId = RTI_TRUE;
                } else {
                    stream->_xTypesState.useExtendedId = RTI_FALSE;
                }
#*------------*##end
            }

            stream->_xTypesState.skipListEndId = RTI_FALSE;
#*----------*##end  
#*------------*##if($node.hasKeyBaseType)  
    if (!${node.baseTypeFQName}Plugin_serialize_key(endpoint_data, 
             (const ${node.baseTypeFQName}*)sample, stream, RTI_FALSE, 
             encapsulation_id,RTI_TRUE, endpoint_plugin_qos)) {
        return RTI_FALSE;
    }
#*------------*##end
#*--------*##serialize_key($node)
#*----------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) 
                  && ($node.hasKeyBaseType || $node.hasKey))
                  #serializeEndMutable()
        }
#*----------*##end     
       
 

   
#*--------*##if($envMap.rtidds42e)
        if (!serialize_encapsulation && topLevel) {
            RTICdrStream_restoreAlignment(stream,position);
        }
#*--------*##end         
    }

#*--------*##if(!$envMap.rtidds42e)
    if(serialize_encapsulation) {
        RTICdrStream_restoreAlignment(stream,position);
    }
#*--------*##end

    return RTI_TRUE;
#*------*##end    
}
#*-****************************************************************-*#

RTIBool ${node.nativeFQNameInModule}Plugin_deserialize_key_sample(
    PRESTypePluginEndpointData endpoint_data,
    ${node.nativeFQNameInModule} *sample, 
    struct RTICdrStream *stream,
    RTIBool deserialize_encapsulation,
    RTIBool deserialize_key,
    void *endpoint_plugin_qos)
{
#*------*##if($node.constructKind=="enum")
    return  ${node.nativeFQName}Plugin_deserialize_sample(
            endpoint_data, sample, stream, deserialize_encapsulation, 
            deserialize_key, endpoint_plugin_qos);
#*------*##else
    char * position = NULL;
    
    
#*--*##if($envMap.rtidds42e)
    RTIBool topLevel;
#*--*##end

#*--*##if(!$node.hasKeyBaseType||!$node.baseTypeFQName) 
    if (endpoint_data) {} /* To avoid warnings */
    if (endpoint_plugin_qos) {} /* To avoid warnings */
#*--*##end    
    
#*--*##deserializeEncapsulation ($node)
    if (deserialize_key) {
    #*------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY") &&$node.hasKey )
        DDS_UnsignedLong memberId = 0;
        DDS_UnsignedLong length = 0;
        RTIBool mustUnderstand = RTI_FALSE;
        RTIBool end = RTI_FALSE;
        struct RTICdrStreamState state;
        RTIBool extended;
#*------*##end
    
#*--------*##rtidds42Alignmet ("deserialize")
    
#*--------*##if($node.hasKeyBaseType)        
     if (!${node.baseTypeFQName}Plugin_deserialize_key_sample(endpoint_data,
              (${node.baseTypeFQName}*)sample,stream,RTI_FALSE,RTI_TRUE,endpoint_plugin_qos)) {
        return RTI_FALSE;
    }
    
#*--------*##end        

#*--------*##deserialize_key_sample($node)
#*--------*##if($envMap.rtidds42e) 
    if (!deserialize_encapsulation && topLevel) {
            RTICdrStream_restoreAlignment(stream,position);
        }
#*--------*##end         
    }

#*--------*##if(!$envMap.rtidds42e) 
    if(deserialize_encapsulation) {
        RTICdrStream_restoreAlignment(stream,position);
    }
#*--------*##end 

    return RTI_TRUE;
#*------*##end    
}
#*-****************************************************************-*#
#*------*##if($node.isAggregationType) 
RTIBool ${node.nativeFQNameInModule}Plugin_deserialize_key(
    PRESTypePluginEndpointData endpoint_data,
    ${node.nativeFQNameInModule} **sample, 
    RTIBool * drop_sample,
    struct RTICdrStream *stream,
    RTIBool deserialize_encapsulation,
    RTIBool deserialize_key,
    void *endpoint_plugin_qos)
{
    RTIBool result;
    if (drop_sample) {} /* To avoid warnings */
    stream->_xTypesState.unassignable = RTI_FALSE;
    result= ${node.nativeFQName}Plugin_deserialize_key_sample(
        endpoint_data, (sample != NULL)?*sample:NULL, stream,
        deserialize_encapsulation, deserialize_key, endpoint_plugin_qos);
    if (result) {
        if (stream->_xTypesState.unassignable) {
                 result = RTI_FALSE;
        }
    }
  
    return result;    
        
        
}
#*------*##end

#*-****************************************************************-*#
unsigned int
${node.nativeFQNameInModule}Plugin_get_serialized_key_max_size_ex(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool * overflow,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{
#if($node.hasUnboundedKeyMember && $envMap.unboundedSupport)
  if (endpoint_data) {} /* To avoid warnings */
    if (include_encapsulation) {}
    if (encapsulation_id) {}
    if (current_alignment) {}
    
    if (overflow != NULL) {
        *overflow = RTI_TRUE;
    }
    
    return RTI_CDR_MAX_SERIALIZED_SIZE;

#else

#*------*##if($node.constructKind=="enum")
    unsigned int initial_alignment = current_alignment;

    current_alignment +=  ${node.nativeFQName}Plugin_get_serialized_sample_max_size_ex(
        endpoint_data, overflow, include_encapsulation,
        encapsulation_id, current_alignment);

#*------*##else
 unsigned int initial_alignment = current_alignment;

#*--*##if(!$envMap.rtidds42e)
    unsigned int encapsulation_size = current_alignment;
#*--*##end   
 
#if(!$node.hasKeyBaseType && !$node.hasNonBasicKeyMember)  
    if (endpoint_data) {} /* To avoid warnings */
    if (overflow) {} /* To avoid warnings */
 #end   
#*--------*##getEncapsulation ($node)

#*--------*##if($node.hasKeyBaseType)    
    current_alignment += ${node.baseTypeFQName}Plugin_get_serialized_key_max_size_ex(
        endpoint_data,
        overflow,
        RTI_FALSE, encapsulation_id,
        current_alignment);
#*--------*##end        

#*--------*##get_serialized_key_max_size($node) 
#*------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY") && $node.hasKey)
    /* Sentinel */
    current_alignment += RTICdrStream_getExtendedParameterHeaderMaxSizeSerialized(current_alignment);
#*------*##end
       
#*--------*##if(!$envMap.rtidds42e)           
    if (include_encapsulation) {
        current_alignment += encapsulation_size;
    }
#*--------*##end    
#*------*##end
    return current_alignment - initial_alignment;
#*------*##end    
}
#*-****************************************************************-*#

#*------*##if($node.constructKind!="enum")
unsigned int
${node.nativeFQNameInModule}Plugin_get_serialized_key_max_size(
    PRESTypePluginEndpointData endpoint_data,
    RTIBool include_encapsulation,
    RTIEncapsulationId encapsulation_id,
    unsigned int current_alignment)
{
    unsigned int size;
    RTIBool overflow = RTI_FALSE;
    
    size = ${node.nativeFQNameInModule}Plugin_get_serialized_key_max_size_ex(
            endpoint_data,&overflow,include_encapsulation,encapsulation_id,current_alignment);
    
    if (overflow) {
        size = RTI_CDR_MAX_SERIALIZED_SIZE;
    }
    
    return size;
}
#end

#*-****************************************************************-*#
RTIBool 
${node.nativeFQNameInModule}Plugin_serialized_sample_to_key(
    PRESTypePluginEndpointData endpoint_data,
    ${node.nativeFQNameInModule} *sample,
    struct RTICdrStream *stream, 
    RTIBool deserialize_encapsulation,  
    RTIBool deserialize_key, 
    void *endpoint_plugin_qos)
{
#*------*##if($node.constructKind=="enum")

    return  ${node.nativeFQName}Plugin_deserialize_sample(
            endpoint_data, sample, stream, deserialize_encapsulation, 
            deserialize_key, endpoint_plugin_qos);

#*------*##else
    char * position = NULL;

#*--------*##if(($node.constructKind=="struct" ||$node.constructKind=="valueType") 
                && ($node.extensibility.equals("EXTENSIBLE_EXTENSIBILITY")))
      RTIBool done = RTI_FALSE;
      RTIBool error = RTI_FALSE;
#*--------*##end
#if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY") || $node.hasOptionalMember)&&($node.hasKey ||  $node.hasKeyBaseType))
    DDS_UnsignedLong memberId = 0;
    DDS_UnsignedLong length = 0;
    RTIBool extended;
    RTIBool mustUnderstand = RTI_FALSE;
    struct RTICdrStreamState state;
#*------*##if($node.extensibility.equals("MUTABLE_EXTENSIBILITY"))
    RTIBool end = RTI_FALSE;
#*------*##end
#*--------*##end


#*--------*##if($envMap.rtidds42e)
    RTIBool topLevel;
#*--------*##end

    
#*--------*##if(($node.hasKey) 
               || ($node.constructKind=="alias") ||($node.hasKeyBaseType )) 

   if (endpoint_data) {} /* To avoid warnings */
   if (endpoint_plugin_qos) {} /* To avoid warnings */
   
#*--------*##end
#*----------*##if(($node.constructKind=="struct" ||$node.constructKind=="valueType") 
                 && ($node.extensibility.equals("EXTENSIBLE_EXTENSIBILITY")))
   if (stream == NULL) {
       error = RTI_TRUE;
       goto fin;
   }
#*----------*##end
   if(deserialize_encapsulation) {
        if (!RTICdrStream_deserializeAndSetCdrEncapsulation(stream)) {
            return RTI_FALSE;
        }
#*----------*##if(!$envMap.rtidds42e)
        position = RTICdrStream_resetAlignment(stream);
#*----------*##end
    }

    if (deserialize_key) {

#*----------*##rtidds42Alignmet ("deserialize")
#*----------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) 
                  &&((${node.hasKeyBaseType})||($node.hasKey && $node.baseTypeFQName)))
              
  {
                    char *begin = RTICdrStream_getCurrentPosition(stream);
                    RTICdrStream_pushState(
                        stream, &state, -1);
#*----------*##end      
#*----------*##if(${node.hasKeyBaseType})       
        if (!${node.baseTypeFQName}Plugin_serialized_sample_to_key(endpoint_data,
                (${node.baseTypeFQName} *)sample,
                stream, RTI_FALSE, RTI_TRUE,
                endpoint_plugin_qos)) {
            return RTI_FALSE;
        }
#*----------*##elseif($node.hasKey && $node.baseTypeFQName) 
        if (!${node.baseTypeFQName}Plugin_skip(endpoint_data, stream,
                RTI_FALSE, RTI_TRUE,
                endpoint_plugin_qos)) {
            return RTI_FALSE;
        }
        
#*----------*##end  
#*----------*##if(($node.extensibility.equals("MUTABLE_EXTENSIBILITY")) 
                  &&((${node.hasKeyBaseType})||($node.hasKey && $node.baseTypeFQName)))
        RTICdrStream_popState(
                        stream, &state);
                    RTICdrStream_setCurrentPosition(stream, begin);
                    }
#*----------*##end  
      
#*----------*##deserialize_key_and_skip($node)

     }
     
#*----------*##if(($node.constructKind=="struct" ||$node.constructKind=="valueType") 
                   && ($node.extensibility.equals("EXTENSIBLE_EXTENSIBILITY")))
      done = RTI_TRUE;
fin:
    if(!error) {
        if (done != RTI_TRUE && 
            RTICdrStream_getRemainder(stream) >=
                RTI_CDR_PARAMETER_HEADER_ALIGNMENT) {
            return RTI_FALSE;   
        }
    } else {
        return error;
    }       
#*----------*##end                

#*----------*##if($envMap.rtidds42e)            ### REview this because in other cases this is inside the  if(deserialize_key) 
  if (!deserialize_encapsulation && topLevel) {
            RTICdrStream_restoreAlignment(stream,position);
        }             
#*----------*##else                
      if(deserialize_encapsulation) {
        RTICdrStream_restoreAlignment(stream,position);
    }
#*----------*##end                
                
                
    return RTI_TRUE;
#*--------*##end    
}
 
#*--------*##keyCode($node) ##The code with funtions relative to serialized/deserialized key is in this macro

#*------*##if($node.constructKind=="enum")
/* ----------------------------------------------------------------------------
    Support functions:
 * ---------------------------------------------------------------------------- */


void ${node.nativeFQNameInModule}PluginSupport_print_data(
    const ${node.nativeFQNameInModule} *sample,
    const char *description, int indent_level)
{
    if (description != NULL) {
        RTICdrType_printIndent(indent_level);
        RTILog_debug("%s:\n", description);
    }

    if (sample == NULL) {
        RTICdrType_printIndent(indent_level+1);
        RTILog_debug("NULL\n");
        return;
    }

    RTICdrType_printEnum((RTICdrEnum *)sample, "${node.nativeFQNameInModule}", indent_level + 1);
}

#*------*##end

/* ------------------------------------------------------------------------
 * Plug-in Installation Methods
 * ------------------------------------------------------------------------ */
#*------*##if (($node.isAggregationType)
                 && ($node.topLevel=="true")) 
struct PRESTypePlugin *${node.nativeFQNameInModule}Plugin_new(void) 
{ 
    struct PRESTypePlugin *plugin = NULL;
    const struct PRESTypePluginVersion PLUGIN_VERSION = 
        PRES_TYPE_PLUGIN_VERSION_2_0;

    RTIOsapiHeap_allocateStructure(
        &plugin, struct PRESTypePlugin);
    if (plugin == NULL) {
       return NULL;
    }

    plugin->version = PLUGIN_VERSION;

    /* set up parent's function pointers */
    plugin->onParticipantAttached =
        (PRESTypePluginOnParticipantAttachedCallback)
        ${node.nativeFQName}Plugin_on_participant_attached;
    plugin->onParticipantDetached =
        (PRESTypePluginOnParticipantDetachedCallback)
        ${node.nativeFQName}Plugin_on_participant_detached;
    plugin->onEndpointAttached =
        (PRESTypePluginOnEndpointAttachedCallback)
        ${node.nativeFQName}Plugin_on_endpoint_attached;
    plugin->onEndpointDetached =
        (PRESTypePluginOnEndpointDetachedCallback)
        ${node.nativeFQName}Plugin_on_endpoint_detached;

    plugin->copySampleFnc =
        (PRESTypePluginCopySampleFunction)
        ${node.nativeFQName}Plugin_copy_sample;
    plugin->createSampleFnc =
        (PRESTypePluginCreateSampleFunction)
        ${node.nativeFQNameInModule}Plugin_create_sample;
    plugin->destroySampleFnc =
        (PRESTypePluginDestroySampleFunction)
        ${node.nativeFQNameInModule}Plugin_destroy_sample;

    plugin->serializeFnc =
        (PRESTypePluginSerializeFunction)
        ${node.nativeFQName}Plugin_serialize;
    plugin->deserializeFnc =
        (PRESTypePluginDeserializeFunction)
        ${node.nativeFQName}Plugin_deserialize;
    plugin->getSerializedSampleMaxSizeFnc =
        (PRESTypePluginGetSerializedSampleMaxSizeFunction)
        ${node.nativeFQName}Plugin_get_serialized_sample_max_size;
    plugin->getSerializedSampleMinSizeFnc =
        (PRESTypePluginGetSerializedSampleMinSizeFunction)
        ${node.nativeFQName}Plugin_get_serialized_sample_min_size;

    plugin->getSampleFnc =
        (PRESTypePluginGetSampleFunction)
        ${node.nativeFQNameInModule}Plugin_get_sample;
    plugin->returnSampleFnc =
        (PRESTypePluginReturnSampleFunction)
        ${node.nativeFQNameInModule}Plugin_return_sample;

    plugin->getKeyKindFnc =
        (PRESTypePluginGetKeyKindFunction)
        ${node.nativeFQName}Plugin_get_key_kind;
        
#if($node.hasKey || $node.hasKeyBaseType)
 plugin->getSerializedKeyMaxSizeFnc =   
        (PRESTypePluginGetSerializedKeyMaxSizeFunction)
       ${node.nativeFQName}Plugin_get_serialized_key_max_size;
    plugin->serializeKeyFnc =
        (PRESTypePluginSerializeKeyFunction)
        ${node.nativeFQName}Plugin_serialize_key;
    plugin->deserializeKeyFnc =
        (PRESTypePluginDeserializeKeyFunction)
        ${node.nativeFQName}Plugin_deserialize_key;
    plugin->deserializeKeySampleFnc =
        (PRESTypePluginDeserializeKeySampleFunction)
        ${node.nativeFQName}Plugin_deserialize_key_sample;

    plugin-> instanceToKeyHashFnc = 
        (PRESTypePluginInstanceToKeyHashFunction)
        ${node.nativeFQName}Plugin_instance_to_keyhash;
    plugin->serializedSampleToKeyHashFnc = 
        (PRESTypePluginSerializedSampleToKeyHashFunction)
        ${node.nativeFQName}Plugin_serialized_sample_to_keyhash;

    plugin->getKeyFnc =
        (PRESTypePluginGetKeyFunction)
       ${node.nativeFQNameInModule}Plugin_get_key;
    plugin->returnKeyFnc =
        (PRESTypePluginReturnKeyFunction)
        ${node.nativeFQNameInModule}Plugin_return_key;

    plugin->instanceToKeyFnc =
        (PRESTypePluginInstanceToKeyFunction)
       ${node.nativeFQName}Plugin_instance_to_key;
    plugin->keyToInstanceFnc =
        (PRESTypePluginKeyToInstanceFunction)
        ${node.nativeFQName}Plugin_key_to_instance;
    plugin->serializedKeyToKeyHashFnc = NULL; /* Not supported yet */
#*------*##else
    /* These functions are only used for keyed types. As this is not a keyed
    type they are all set to NULL
    */
    plugin->serializeKeyFnc = NULL ;    
    plugin->deserializeKeyFnc = NULL;  
    plugin->getKeyFnc = NULL;
    plugin->returnKeyFnc = NULL;
    plugin->instanceToKeyFnc = NULL;
    plugin->keyToInstanceFnc = NULL;
    plugin->getSerializedKeyMaxSizeFnc = NULL;
    plugin->instanceToKeyHashFnc = NULL;
    plugin->serializedSampleToKeyHashFnc = NULL;
    plugin->serializedKeyToKeyHashFnc = NULL;    
#*------*##end
#*--------*##if(!$envMap.typeCode)
    plugin->typeCode = NULL; 
#*--------*##else
    plugin->typeCode =  (struct RTICdrTypeCode *)${node.nativeFQName}_get_typecode();
#*--------*##end    

#if($envMap.language.equals("Cpp") || $envMap.generateCforCpp03)
    plugin->languageKind = PRES_TYPEPLUGIN_CPP_LANG;
#else
    plugin->languageKind = PRES_TYPEPLUGIN_DDS_TYPE;
#end 

    /* Serialized buffer */
    plugin->getBuffer = 
        (PRESTypePluginGetBufferFunction)
        ${node.nativeFQNameInModule}Plugin_get_buffer;
    plugin->returnBuffer = 
        (PRESTypePluginReturnBufferFunction)
        ${node.nativeFQNameInModule}Plugin_return_buffer;
    plugin->getSerializedSampleSizeFnc =
        (PRESTypePluginGetSerializedSampleSizeFunction)
        ${node.nativeFQName}Plugin_get_serialized_sample_size;

    plugin->endpointTypeName = ${node.nativeFQNameInModule}TYPENAME;

    return plugin;
}

void
${node.nativeFQNameInModule}Plugin_delete(struct PRESTypePlugin *plugin)
{
    RTIOsapiHeap_freeStructure(plugin);
} 
#*------*##end
#*----*##end
#*--*##end 

