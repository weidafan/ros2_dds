/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)dds_c_subscription_impl.h    generated by: makeheader    Mon Apr 25 07:50:59 2016
 *
 *		built from:	subscription_impl.ifc
 */

#ifndef dds_c_subscription_impl_h
#define dds_c_subscription_impl_h


  #ifndef dds_c_topic_h
    #include "dds_c/dds_c_topic.h"
  #endif
  #ifndef dds_c_subscription_h
    #include "dds_c/dds_c_subscription.h"
  #endif
  #ifndef dds_c_dll_h
    #include "dds_c/dds_c_dll.h"
  #endif
  #ifndef pres_common_h
    #include "pres/pres_common.h"
  #endif
  #ifndef pres_psGroup_h
    #include "pres/pres_psGroup.h"
  #endif

#ifdef __cplusplus
    extern "C" {
#endif

extern DDSCDllExport DDS_ReturnCode_t DDS_DataReader_read_or_take_untypedI(
    DDS_DataReader* self,
    DDS_Boolean* is_loan, void*** received_data, int* data_count,
    struct DDS_SampleInfoSeq* info_seq,
    DDS_Long data_seq_len, DDS_Long data_seq_max_len,
    DDS_Boolean data_seq_has_ownership,
    void* data_seq_contiguous_buffer_for_copy,
    int data_size,
    DDS_Long max_samples,
    DDS_SampleStateMask sample_states, DDS_ViewStateMask view_states,
    DDS_InstanceStateMask instance_states,
    DDS_Boolean take);

extern DDSCDllExport DDS_ReturnCode_t
DDS_DataReader_read_or_take_w_condition_untypedI(
    DDS_DataReader* self,
    DDS_Boolean* is_loan, void*** received_data, int* data_count,
    struct DDS_SampleInfoSeq* info_seq,
    DDS_Long data_seq_len, DDS_Long data_seq_max_len,
    DDS_Boolean data_seq_has_ownership,
    void* data_seq_contiguous_buffer_for_copy,
    int data_size,
    DDS_Long max_samples,
    DDS_ReadCondition* condition,
    DDS_Boolean take);

extern DDSCDllExport DDS_ReturnCode_t 
DDS_DataReader_read_or_take_next_sample_untypedI(
    DDS_DataReader* self,
    void* received_data,
    struct DDS_SampleInfo* info_seq,
    DDS_Boolean take);

extern DDSCDllExport DDS_ReturnCode_t
DDS_DataReader_read_or_take_instance_untypedI(
    DDS_DataReader* self,
    DDS_Boolean* is_loan, void*** received_data, int* data_count,
    struct DDS_SampleInfoSeq* info_seq,
    DDS_Long data_seq_len, DDS_Long data_seq_max_len,
    DDS_Boolean data_seq_has_ownership,
    void* data_seq_contiguous_buffer_for_copy,
    int data_size,
    DDS_Long max_samples,
    const DDS_InstanceHandle_t* a_handle,
    DDS_SampleStateMask sample_states, DDS_ViewStateMask view_states,
    DDS_InstanceStateMask instance_states,
    DDS_Boolean take);

extern DDSCDllExport DDS_ReturnCode_t
DDS_DataReader_read_or_take_instance_w_condition_untypedI(
    DDS_DataReader* self,
    DDS_Boolean* is_loan, void*** received_data, int* data_count,
    struct DDS_SampleInfoSeq* info_seq,
    DDS_Long dataSeqLen, DDS_Long dataSeqMaxLen,
    DDS_Boolean dataSeqHasOwnership,
    void* data_seq_contiguous_buffer_for_copy,
    int data_size,
    DDS_Long max_samples,
    const DDS_InstanceHandle_t* previous_handle,
    DDS_ReadCondition* condition,
    DDS_Boolean take);

extern DDSCDllExport DDS_ReturnCode_t
DDS_DataReader_read_or_take_next_instance_untypedI(
    DDS_DataReader* self,
    DDS_Boolean* is_loan, void*** received_data, int* data_count,
    struct DDS_SampleInfoSeq* info_seq,
    DDS_Long data_seq_len, DDS_Long data_seq_max_len,
    DDS_Boolean data_seq_has_ownership,
    void* data_seq_contiguous_buffer_for_copy,
    int data_size,
    DDS_Long max_samples,
    const DDS_InstanceHandle_t* previous_handle,
    DDS_SampleStateMask sample_states, DDS_ViewStateMask view_states,
    DDS_InstanceStateMask instance_states,
    DDS_Boolean take);

extern DDSCDllExport DDS_ReturnCode_t
DDS_DataReader_read_or_take_next_instance_w_condition_untypedI(
    DDS_DataReader* self,
    DDS_Boolean* is_loan, void*** received_data, int* data_count,
    struct DDS_SampleInfoSeq* info_seq,
    DDS_Long dataSeqLen, DDS_Long dataSeqMaxLen,
    DDS_Boolean dataSeqHasOwnership,
    void* data_seq_contiguous_buffer_for_copy,
    int data_size,
    DDS_Long max_samples,
    const DDS_InstanceHandle_t* previous_handle,
    DDS_ReadCondition* condition,
    DDS_Boolean take);

extern DDSCDllExport DDS_ReturnCode_t DDS_DataReader_return_loan_untypedI(
    DDS_DataReader* self,
    void** received_data, int dataCount,
    struct DDS_SampleInfoSeq* info_seq);

extern DDSCDllExport DDS_ReturnCode_t DDS_DataReader_get_key_value_untypedI(
    DDS_DataReader* self,
    void* key_holder, const DDS_InstanceHandle_t* handle);

extern DDSCDllExport DDS_InstanceHandle_t
DDS_DataReader_lookup_instance_untypedI(
    DDS_DataReader* self,
    const void* key_holder);

extern DDSCDllExport PRESTypePluginEndpointData
DDS_DataReader_get_endpoint_dataI(
    DDS_DataReader* self);

extern DDSCDllExport DDS_ReturnCode_t DDS_DataReader_set_listenerI(
    DDS_DataReader* self,
    const struct DDS_DataReaderListener* l, DDS_StatusMask mask, RTIBool logWarnEnable);

extern DDSCDllExport
int DDS_QueryCondition_get_query_parameters_length(DDS_QueryCondition* self);

extern DDSCDllExport DDS_ReturnCode_t DDS_DataReader_add_sample_to_remote_writer_queue_untypedI(
    DDS_DataReader* self,
    const void* localData,
    const struct DDS_GUID_t* guid);

extern DDSCDllExport DDS_DataReader* DDS_Subscriber_create_datareader_disabledI(
    DDS_Subscriber* self,
    DDS_Boolean* need_enable,
    DDS_TopicDescription* topic,
    const struct DDS_DataReaderQos* qos,
    const struct DDS_DataReaderListener* listener,
    DDS_StatusMask mask);

extern DDSCDllExport DDS_DataReader*
DDS_Subscriber_lookup_datareaderI(
    DDS_Subscriber* self, DDS_Boolean* is_newly_created,
    DDS_Boolean* need_enable, DDS_TopicDescription* builtin_topic_description,
    const char* topic_name);

extern DDSCDllExport DDS_Boolean DDS_Subscriber_is_builtinI(
    DDS_Subscriber* self);

extern DDSCDllExport DDS_Boolean 
DDS_DataReader_compare_typeI(DDS_DataReader *self, const char* typeToCompare);

extern DDSCDllExport DDS_ReturnCode_t DDS_Subscriber_begin_get_datareadersI(
    DDS_Subscriber* self,
    void ** iter,
    DDS_Long* max_reader_count); 

extern DDSCDllExport DDS_ReturnCode_t DDS_Subscriber_end_get_datareadersI(
    DDS_Subscriber* self,
    void * iter); 

extern DDSCDllExport DDS_DataReader* DDS_Subscriber_get_next_readerI(
    DDS_Subscriber* self,
    DDS_ReturnCode_t *failReason,    
    void * iter,
    DDS_Boolean use_states,
    DDS_SampleStateMask sample_states,
    DDS_ViewStateMask view_states,
    DDS_InstanceStateMask instance_states); 

extern DDSCDllExport DDS_ReturnCode_t DDS_Subscriber_set_listenerI(
    DDS_Subscriber* self,
    const struct DDS_SubscriberListener* l, DDS_StatusMask mask, RTIBool logWarnEnable);

extern DDSCDllExport
void DDS_SubscriberQos_get_defaultI( struct DDS_SubscriberQos* self);

extern DDSCDllExport
void DDS_DataReaderQos_get_defaultI(struct DDS_DataReaderQos* self);

extern DDSCDllExport
void DDS_DataReaderQos_copy_from_topic_qosI(
    struct DDS_DataReaderQos* self, const struct DDS_TopicQos* topic_qos);

extern DDSCDllExport
DDS_ReturnCode_t DDS_DataReader_get_all_read_conditions(
    DDS_DataReader* self,
    struct DDS_ReadConditionSeq* read_conditions);


#define DDS_SampleInfo_get_loaned_sampleinfo_user_objectI(ddsSampleInfo) \
       ((struct PRESLoanedSampleInfo *)(ddsSampleInfo))->userObject

extern DDSCDllExport DDS_Boolean DDS_Subscriber_is_implicitI(
    DDS_Subscriber* self);


#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* dds_c_subscription_impl_h */
