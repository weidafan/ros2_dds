/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)dds_c_sequence.h    generated by: makeheader    Mon Apr 25 07:50:59 2016
 *
 *		built from:	sequence.ifc
 */

#ifndef dds_c_sequence_h
#define dds_c_sequence_h



  #ifndef osapi_type_h
    #include "osapi/osapi_type.h"
  #endif
  #ifndef dds_c_common_h
    #include "dds_c/dds_c_common.h"
  #endif
  #ifndef dds_c_dll_h
    #include "dds_c/dds_c_dll.h"
  #endif


struct DDS_SeqElementTypeAllocationParams_t {
    DDS_Boolean allocate_pointers;
    DDS_Boolean allocate_optional_members;
    DDS_Boolean allocate_memory;
};

struct DDS_SeqElementTypeDeallocationParams_t {
    DDS_Boolean delete_pointers;
    DDS_Boolean delete_optional_members;
};


#define DDS_SeqElementTypeAllocationParams_from_type_alloc_settings( \
            self, typeAlloc) \
    (self)->allocate_pointers = (typeAlloc)->allocate_pointers; \
    (self)->allocate_optional_members = (typeAlloc)->allocate_optional_members; \
    (self)->allocate_memory = (typeAlloc)->allocate_memory

#define DDS_SeqElementTypeDeallocationParams_from_type_dealloc_settings( \
            self, typeDealloc) \
    (self)->delete_pointers = (typeDealloc)->delete_pointers; \
    (self)->delete_optional_members = (typeDealloc)->delete_optional_members

#define DDS_TypeAllocationParams_from_seq_type_alloc_settings( \
            self, typeAlloc) \
    (self)->allocate_pointers = (typeAlloc)->allocate_pointers; \
    (self)->allocate_optional_members = (typeAlloc)->allocate_optional_members; \
    (self)->allocate_memory = (typeAlloc)->allocate_memory
        
#define DDS_TypeDeallocationParams_from_seq_type_dealloc_settings( \
            self, typeDealloc) \
    (self)->delete_pointers = (typeDealloc)->delete_pointers; \
    (self)->delete_optional_members = (typeDealloc)->delete_optional_members


/*i @ingroup DDSSequenceModule
  @brief Member definition of the sequence struct

  Used in incarnating a \em generics implementation.
*/

#define DDS_SEQUENCE_MEMBERS(TSeq, T) \
        DDS_Boolean _owned;           \
        T* _contiguous_buffer;        \
        T** _discontiguous_buffer;    \
        DDS_UnsignedLong _maximum;    \
        DDS_UnsignedLong _length;     \
        DDS_Long _sequence_init;          \
        void* _read_token1;   \
        void* _read_token2;   \
        struct DDS_SeqElementTypeAllocationParams_t _elementAllocParams; \
        struct DDS_SeqElementTypeDeallocationParams_t _elementDeallocParams;


/* Make sure that NDDSUSERDllExport expands to nothing by default */

#define NDDSUSERDllExport



#ifdef RTI_CPP

#ifndef dds_cpp_dll_h
  #include "dds_cpp/dds_cpp_dll.h"
#endif

#ifdef NDDS_NO_OVERLOADED_OPERATORS_IN_CPP

/*i @ingroup DDSSequenceModule
  @brief    Empty list of sequence operator overloaded methods.
*/
#define DDS_SEQUENCE_OVERLOADED_OPERATOR_METHODS(TSeq, T)

#else /* #ifdef NDDS_NO_OVERLOADED_OPERATORS_IN_CPP */

/*ci @ingroup DDSSequenceModule
  @brief    Sequence operator overloaded methods
*/
#define DDS_SEQUENCE_OVERLOADED_OPERATOR_METHODS(TSeq, T) \
TSeq& operator=(const struct TSeq& src_seq); \
const T& operator[](DDS_Long i) const; \
T& operator[](DDS_Long i);

#endif /* #ifdef NDDS_NO_OVERLOADED_OPERATORS_IN_CPP */

/*ci @ingroup DDSSequenceModule
  @brief    Sequence dll export
*/
#define DDS_SEQUENCE_DLL_EXPORT NDDSUSERDllExport DDSCPPDllExport

/*i @ingroup DDSSequeceModule
  @brief C++-only methods definition of the sequence methods

  Used in incarnating a \em generics implementation.
*/
#define DDS_SEQUENCE_METHODS(TSeq, T) \
bool element_pointers_allocation(bool allocatePointers);\
bool element_pointers_allocation();\
bool element_allocation_params( \
         const DDS_TypeAllocationParams_t & params); \
DDS_TypeAllocationParams_t element_allocation_params(); \
bool element_deallocation_params( \
         const DDS_TypeDeallocationParams_t & params); \
DDS_TypeDeallocationParams_t element_deallocation_params(); \
DDS_Long maximum() const; \
bool maximum(DDS_Long new_max); \
DDS_Long length() const; \
bool length(DDS_Long new_length); \
bool ensure_length(DDS_Long length, DDS_Long max); \
bool has_ownership(); \
bool copy_no_alloc(const struct TSeq& src_seq); \
bool from_array(const T array[], DDS_Long length); \
bool to_array(T array[], DDS_Long length); \
bool loan_contiguous(T* buffer, DDS_Long new_length, DDS_Long new_max); \
bool loan_discontiguous(T** buffer, DDS_Long new_length, DDS_Long new_max); \
bool unloan(); \
T* get_contiguous_bufferI() const; \
T* get_contiguous_buffer() const; \
T** get_discontiguous_bufferI() const; \
T** get_discontiguous_buffer() const; \
void get_read_tokenI(void** token1, void** token2) const; \
void set_read_tokenI(void* token1, void* token2);        \
explicit TSeq(DDS_Long max = 0); \
TSeq(const struct TSeq& seq); \
\
T& set_at(DDS_Long i, const T& val); \
const T& get_at(DDS_Long i) const; \
bool copy(const struct TSeq& src_seq); \
\
DDS_SEQUENCE_OVERLOADED_OPERATOR_METHODS(TSeq, T) \
\
~TSeq();

#else /* if !defined(RTI_CPP) */

/*ci @ingroup DDSSequenceModule
  @brief    Empty Sequence dll export variable

  Since for dds c sequence structure, there are no methods. Therefore, there is
  no need to export anything.
*/
#define DDS_SEQUENCE_DLL_EXPORT

/*ci @ingroup DDSSequenceModule
  @brief    Empty list of sequence methods.
*/
#define DDS_SEQUENCE_METHODS(TSeq, T)


#endif /* RTI_CPP */





#ifdef NDDS_NO_OVERLOADED_OPERATORS_IN_CPP

/*ci @ingroup DDSSequenceModule
  @brief    Empty sequence get method.
*/
#define DDS_SEQUENCE_GET_METHOD_IN_C(TSeq, T)

/*ci @ingroup DDSSequenceModule
  @brief    Empty sequence C methods.
*/
#define DDS_SEQUENCE_METHODS_IN_C(TSeq, T)

#else /* #ifdef NDDS_NO_OVERLOADED_OPERATORS_IN_CPP */

/*ci @ingroup DDSSequenceModule
  @brief    Sequence get method in C
*/
#define DDS_SEQUENCE_GET_METHOD_IN_C(TSeq, T) \
; \
NDDSUSERDllExport DDSCDllExport \
T TSeq ## _get(const struct TSeq* self, DDS_Long i)

/*ci @ingroup DDSSequenceModule
  @brief    All sequence methods in C (except for get)
*/
#define DDS_SEQUENCE_METHODS_IN_C(TSeq, T) \
; \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _get_element_pointers_allocation(                  \
    const struct TSeq* self);                                          \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _set_element_pointers_allocation(                  \
    struct TSeq* self,                                                 \
    DDS_Boolean allocatePointers);                                     \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _set_element_allocation_params(                    \
    struct TSeq* self,                                                 \
    const struct DDS_TypeAllocationParams_t * params);                 \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
void TSeq ## _get_element_allocation_params(                           \
    struct TSeq* self, struct DDS_TypeAllocationParams_t * params);    \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _set_element_deallocation_params(                  \
    struct TSeq* self,                                                 \
    const struct DDS_TypeDeallocationParams_t * params);               \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
void TSeq ## _get_element_deallocation_params(                         \
    struct TSeq* self,                                                 \
    struct DDS_TypeDeallocationParams_t * params);                     \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _initialize(struct TSeq* self);                    \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Long TSeq ## _get_maximum(const struct TSeq* self);                \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _set_maximum(struct TSeq* self, DDS_Long new_max); \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Long TSeq ## _get_length(const struct TSeq *self);                 \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _set_length(struct TSeq *self, DDS_Long new_length);\
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _ensure_length(struct TSeq *self, DDS_Long length, \
                                                      DDS_Long max);   \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
T* TSeq ## _get_reference(const struct TSeq* self, DDS_Long i);        \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _copy_no_alloc(struct TSeq* self,                  \
                                    const struct TSeq* src);           \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _copy_no_allocI(struct TSeq* self,                 \
                                    const struct TSeq* src);           \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
struct TSeq* TSeq ## _copy(struct TSeq* self, const struct TSeq* src); \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _from_array(struct TSeq* self, const T array[],    \
                                                   DDS_Long length);   \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _to_array(struct TSeq* self, T array[],            \
                                                   DDS_Long length);   \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _loan_contiguous(struct TSeq* self, T* buffer,     \
                                      DDS_Long new_length,             \
                                      DDS_Long new_max);               \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _loan_discontiguous(struct TSeq* self, T** buffer, \
                                        DDS_Long new_length,           \
                                        DDS_Long new_max);             \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _unloan(struct TSeq* self);                        \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
T* TSeq ## _get_contiguous_bufferI(const struct TSeq* self);           \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
T* TSeq ## _get_contiguous_buffer(const struct TSeq* self);            \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
T** TSeq ## _get_discontiguous_bufferI(const struct TSeq* self);       \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
T** TSeq ## _get_discontiguous_buffer(const struct TSeq* self);        \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
void TSeq ## _get_read_tokenI(const struct TSeq* self,                 \
                              void** token1, void** token2);           \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
void TSeq ## _set_read_tokenI(struct TSeq* self,                       \
                              void* token1, void* token2);             \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _has_ownership(const struct TSeq* self);           \
                                                                       \
NDDSUSERDllExport DDSCDllExport                                        \
DDS_Boolean TSeq ## _finalize(struct TSeq* self)

#endif /* #ifdef NDDS_NO_OVERLOADED_OPERATORS_IN_CPP */



/*i @ingroup DDSSequenceModule

  @brief Declares an abstract \st_interface \p TSeq, for IDL \p
  sequence\_T of type \p T.
 
   @uses     T      base type
   @defines  TSeq   name of the sequence type to be defined

   Using this macro introduces a class declaration TSeq in the
   enclosing name space.

   <STRONG>Incarnation:</STRONG>

   \em Incarnation is the process of realizing a concrete type
   from the \em generic skeleton defined by TSeq.  Given a user type
   \p Foo, a type \p FooSeq representing the IDL type \p
   sequence\_Foo is incarnated as follows.

   <EM>\em Value-type sequences</EM>

   When the base type \p T is a value-type, \p sequence\_T is declared
   follows.  
   \code
      DDS_SEQUENCE(FooSeq, Foo);
   \endcode

   <EM>\em Reference-type sequences</EM>

   When the base type \p Foo is a reference-type, \p sequence\_Foo is
   declared as follows.  

   \code
      typedef  Foo*  Foo_ptr;

      DDS_SEQUENCE(FooSeq, Foo_ptr);

   \endcode      

   We use a two step process, because in C++
   \code 
       const Foo_ptr  =   Foo *const  
                 !=   const Foo*
   \endcode
   and we want the \p Foo_ptr semantics for the method:
   \code
       const T& TSeq::operator[]() const
   \endcode

  \hideinitializer
*/

/*******************************************************************/
/*   NOTE(V.V.IMP): This structure should match exactly to the     */
/*   PRESDDSSequence. The reason for this is that we may directly  */
/*   typecast a DDS_SEQUENCE to this struct and visa-versa.        */
/*******************************************************************/ 


#define DDS_SEQUENCE_NO_GET(TSeq, T)   \
struct DDS_SEQUENCE_DLL_EXPORT TSeq { \
DDS_SEQUENCE_MEMBERS(TSeq, T)   \
DDS_SEQUENCE_METHODS(TSeq, T)   \
}                              \
DDS_SEQUENCE_METHODS_IN_C(TSeq, T)

#define DDS_SEQUENCE(TSeq, T)   \
DDS_SEQUENCE_NO_GET(TSeq, T) \
DDS_SEQUENCE_GET_METHOD_IN_C(TSeq, T)

#define DDS_SEQUENCE_NO_GET_IN_C(TSeq, T)   \
struct DDS_SEQUENCE_DLL_EXPORT TSeq { \
DDS_SEQUENCE_MEMBERS(TSeq, T)   \
}                              \
DDS_SEQUENCE_METHODS_IN_C(TSeq, T)

#define DDS_SEQUENCE_IN_C(TSeq, T)   \
DDS_SEQUENCE_NO_GET_IN_C(TSeq, T) \
DDS_SEQUENCE_GET_METHOD_IN_C(TSeq, T)



/*ci
 * @brief   The magic value of the _sequence_init field.
 * 
 * If the field is not set to this value, the sequence has not been
 * initialized.
 */

#define DDS_SEQUENCE_MAGIC_NUMBER       0x7344L


/*ce \dref_FooSeq_SEQUENCE_INITIALIZER
 */

#define DDS_SEQUENCE_INITIALIZER { DDS_BOOLEAN_TRUE, NULL, NULL, 0L, 0L, \
                                 DDS_SEQUENCE_MAGIC_NUMBER, NULL, NULL, \
                                 {DDS_BOOLEAN_TRUE, DDS_BOOLEAN_FALSE, DDS_BOOLEAN_TRUE}, \
                                 {DDS_BOOLEAN_TRUE, DDS_BOOLEAN_TRUE} }



/* ================================================================= */
#ifdef DOXYGEN_DOCUMENTATION_ONLY

/*ce \dref_FooSeq
 */
struct FooSeq {
    /*i @brief Ownership of the buffer

      Indicates whether this sequence currently owns its buffers. It is
      false if the sequence's buffer is on loan or true if the sequence
      owns the buffer (i.e. manages the memory itself). A newly created
      sequence or a sequence with maximum == 0 owns its memory.
     */
    DDS_Boolean _owned;

    /*i @brief Pointer to array of contiguous data

      Each sequence has two buffers: a contiguous buffer and a 
      discontiguous buffer. The former may be either loaned or owned;
      the latter is only ever loaned. The public operations on the
      sequence must be written in such a way that it is impossible for
      both buffers to be non-NULL simultaneously.
     */
    T *_contiguous_buffer;

    /*i @brief Pointer to array of pointers to data

      The discontigous buffer is an array of T* element. It is loaned to
      user type and DDS_SampleInfo sequences during read and take
      operations in order to avoid a copy; it is unused at other times.
      It is essentially an extension to the CORBA sequence mapping,
      which assumes all elements are contiguous.

      When this field is non-NULL, the owned flag is essentially
      redundant. Nevertheless, it simplifies understanding and
      implementation of this class if the public operations ensure that
      the flag is always in the correct state regardless of which buffer
      is in use.

      Since the buffer is anticipated to be used only during read and
      take, it amounts to four bytes of wasted space in primitive and
      object type sequences. Thsi amount is small in comparison to the
      total overhead of the seqeunce and even smaller when one considers
      that most sequences will contain many elements.
     */
    T **_discontiguous_buffer;

    /*i @brief Maximum size of the sequence
      
      The allocated length of this sequence. It applies to whichever of
      the above buffers is non-NULL, if any. If both a NULL, its value
      must be 0.

      If _maximum == 0, _owned == true.
     */
    DDS_UnsignedLong _maximum;

    /*i @brief Actual length of the sequence that contains data

      The current logical length of thsi seqeunce, i.e. the number of valid
      elements it contains. It applies to whichever of the above
      buffers is non-null, if any. If both are NULL, its value must be 0.
     */
    DDS_UnsignedLong _length;
    
    /*i @brief  A magic number that serves as a hint as to whether this
     *          sequence has been initialized yet.
     * 
     * In C, it is very easy to declare a variable on the stack and forget
     * to initialize it. Since sequences contain dynamic memory, this is a
     * big problem. This field serves as an imperfect safety net to allow the
     * sequence to detect when it's uninitialized and initialize itself on
     * the fly.
     * 
     * @see     DDS_SEQUENCE_MAGIC_NUMBER
     */
    DDS_Long _sequence_init;
    
    /*i @brief  Together, the two read tokens are used during read/take
     *          operations to ensure that sequences loaned together are
     *          returned together.
     * 
     * These fields are intended to be entirely opaque and are the business
     * of the data reader only. They should not be used for any other purpose!
     */
    void* _read_token1;
    
    /*i @brief  Together, the two read tokens are used during read/take
     *          operations to ensure that sequences loaned together are
     *          returned together.
     * 
     * These fields are intended to be entirely opaque and are the business
     * of the data reader only. They should not be used for any other purpose!
     */
    void* _read_token2;
};


/*ce \dref_FooSeq_initialize
 */
DDS_Boolean FooSeq_initialize(struct FooSeq* self);

/*ce \dref_FooSeq_get_maximum
 */
DDS_Long FooSeq_get_maximum(const struct FooSeq* self);

/*ce \dref_FooSeq_set_maximum
 */
DDS_Boolean FooSeq_set_maximum(struct FooSeq* self, DDS_Long new_max);

/*ce \dref_FooSeq_get_length
 */
DDS_Long FooSeq_get_length(const struct FooSeq* self);

/*ce \dref_FooSeq_set_length
 */
DDS_Boolean FooSeq_set_length(struct FooSeq* self, DDS_Long new_length);

/*ce \dref_FooSeq_ensure_length
 */
DDS_Boolean FooSeq_ensure_length(struct FooSeq* self, DDS_Long length, DDS_Long max);                                                       

/*ce \dref_FooSeq_operatorBracketConst
 */
Foo FooSeq_get(const struct FooSeq* self, DDS_Long i);

/*ce \dref_FooSeq_get_reference
 */
Foo* FooSeq_get_reference(const struct FooSeq* self, DDS_Long i);

/*ce \dref_FooSeq_copy_no_alloc
 */
DDS_Boolean FooSeq_copy_no_alloc(struct FooSeq* self, const struct FooSeq* src_seq);

/*ce \dref_FooSeq_copy
 */
FooSeq* FooSeq_copy(struct FooSeq* self, const struct FooSeq* src_seq);

/*ce \dref_FooSeq_from_array
 */
DDS_Boolean FooSeq_from_array(struct FooSeq* self, const Foo array[],   
                                                   DDS_Long length); 
                                                   
/*ce \dref_FooSeq_to_array
 */
DDS_Boolean FooSeq_to_array(struct FooSeq* self, Foo array[], DDS_Long length); 
                                                   
/*ce \dref_FooSeq_loan_contiguous
 */
DDS_Boolean FooSeq_loan_contiguous(struct FooSeq* self, Foo* buffer,
                           DDS_Long new_length, DDS_Long new_max);

/*ce \dref_FooSeq_loan_discontiguous
 */
DDS_Boolean FooSeq_loan_discontiguous(struct FooSeq* self, Foo** buffer,
                          DDS_Long new_length, DDS_Long new_max);

/*ce \dref_FooSeq_unloan
 */
DDS_Boolean FooSeq_unloan(struct FooSeq* self);

/*ci \dref_FooSeq_get_contiguous_bufferI
 */
Foo* FooSeq_get_contiguous_bufferI(const struct FooSeq* self);

/*ce \dref_FooSeq_get_contiguous_buffer
 */
Foo* FooSeq_get_contiguous_buffer(const struct FooSeq* self);

/*ci \dref_FooSeq_get_discontiguous_bufferI
 */
Foo** FooSeq_get_discontiguous_bufferI(const struct FooSeq* self);

/*ce \dref_FooSeq_get_discontiguous_buffer
 */
Foo** FooSeq_get_discontiguous_buffer(const struct FooSeq* self);

/*ci \dref_FooSeq_get_read_tokenI
 */
void FooSeq_get_read_tokenI(const struct TSeq* self,
                            void** token1, void** token2);

/*ci \dref_FooSeq_set_read_tokenI
 */
void FooSeq_set_read_tokenI(struct TSeq* self, void* token1, void* token2);

/*ce \dref_FooSeq_has_ownership
 */
DDS_Boolean FooSeq_has_ownership(const struct FooSeq* self);

/*ce \dref_FooSeq_delete
 */
DDS_Boolean FooSeq_finalize(struct FooSeq* self);

#endif /* DOXYGEN_DOCUMENTATION_ONLY */


/* ----------------------------------------------------------------- */
/* End of $Id$ */
#endif /* dds_c_sequence_h */
