/* (c) Copyright 2003-2015, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)osapi_semaphore.h    generated by: makeheader    Mon Apr 25 07:49:33 2016
 *
 *		built from:	semaphore.ifc
 */

#ifndef osapi_semaphore_h
#define osapi_semaphore_h


  #ifndef log_common_h
    #include "log/log_common.h"
  #endif
  #ifndef osapi_log_h
    #include "osapi/osapi_log.h"
  #endif

  #ifndef osapi_type_h
    #include "osapi/osapi_type.h"
  #endif

#ifdef __cplusplus
    extern "C" {
#endif

struct RTIOsapiSemaphore;/* forward declare */

struct RTINtpTime;/* we count represent time with RTINtpTime */

typedef enum {
    /*e \brief Binary sempahore.
     */
    RTI_OSAPI_SEMAPHORE_KIND_BINARY =
    RTI_LOG_formSubmoduleSpecificNumber(MODULE_OSAPI,
					RTI_OSAPI_SUBMODULE_MASK_SEMAPHORE, 0),
    /*e \brief Counting sempahore.
     */
    RTI_OSAPI_SEMAPHORE_KIND_COUNTING =
    RTI_LOG_formSubmoduleSpecificNumber(MODULE_OSAPI,
					RTI_OSAPI_SUBMODULE_MASK_SEMAPHORE, 1),
    /*e \brief Mutex semaphore.
     */
    RTI_OSAPI_SEMAPHORE_KIND_MUTEX =
    RTI_LOG_formSubmoduleSpecificNumber(MODULE_OSAPI,
					RTI_OSAPI_SUBMODULE_MASK_SEMAPHORE, 2),

    /*e Broadcast semantics is the same as pthread_cond_broadcast
      http://www.cs.wustl.edu/~schmidt/win32-cv-1.html is an excellent related
      material.
     */
    RTI_OSAPI_SEMAPHORE_KIND_BROADCAST =
    RTI_LOG_formSubmoduleSpecificNumber(MODULE_OSAPI,
					RTI_OSAPI_SUBMODULE_MASK_SEMAPHORE, 3)
} RTIOsapiSemaphoreKind;

typedef enum {
    /*e The order threads are awaken is first in first out. */
    RTI_SEMAPHORE_THREAD_QUEUE_OPTION_FIFO = 0x0, 
    /*e The order threads are awaken is determined by their priority. */
    RTI_SEMAPHORE_THREAD_QUEUE_OPTION_PRIORITY = 0x1 
} RTIOsapiSemaphoreThreadQueueOption;

struct RTIOsapiSemaphoreProperty {
    /*e \brief Thread wakeup option.

      Irrelevant on some OSes.
     */
    RTIOsapiSemaphoreThreadQueueOption queueOption;

    /*e
      @param initialCountIn
      <UL>
      <LI>for counting semaphore, the initial count.  0 means the
          semaphore starts out being empty, so that the first take() will block
      <LI>for binary semaphore, 0 means initially empty, and non-zero means
          initially full.
      <LI>for mutex semaphore, count is irrelevant.
    </UL>
    */
    int initialCount;
};


  /*e \ingroup RTIOsapiSemaphoreClass
   * @brief Default property values.
   */
  #define RTI_OSAPI_SEMAPHORE_PROPERTY_DEFAULT { \
    RTI_SEMAPHORE_THREAD_QUEUE_OPTION_FIFO, \
    0 \
  }

extern RTIOsapiDllExport
struct RTIOsapiSemaphore*
RTIOsapiSemaphore_new(RTIOsapiSemaphoreKind kindIn,
		      const struct RTIOsapiSemaphoreProperty* pIn);

extern RTIOsapiDllExport void
RTIOsapiSemaphore_delete(struct RTIOsapiSemaphore* me);

typedef enum {
    /*e \brief The operation succeeded.
     */
    RTI_OSAPI_SEMAPHORE_STATUS_OK =
    RTI_LOG_formSubmoduleSpecificNumber(MODULE_OSAPI,
					RTI_OSAPI_SUBMODULE_MASK_SEMAPHORE,
					0xF0),
    /*e \brief The operation timed out.
     */
    RTI_OSAPI_SEMAPHORE_STATUS_TIMEOUT =
    RTI_LOG_formSubmoduleSpecificNumber(MODULE_OSAPI,
					RTI_OSAPI_SUBMODULE_MASK_SEMAPHORE,
					0xF1),
    /*e \brief An error occurred.
     */
    RTI_OSAPI_SEMAPHORE_STATUS_ERROR =
    RTI_LOG_formSubmoduleSpecificNumber(MODULE_OSAPI,
					RTI_OSAPI_SUBMODULE_MASK_SEMAPHORE,
					0xFF)
} RTIOsapiSemaphoreStatus;

extern RTIOsapiDllExport RTIOsapiSemaphoreStatus
RTIOsapiSemaphore_take(struct RTIOsapiSemaphore* me,
		       const struct RTINtpTime* blockDurationIn);

extern RTIOsapiDllExport RTIOsapiSemaphoreStatus
RTIOsapiSemaphore_give(struct RTIOsapiSemaphore* me);

extern RTIOsapiDllExport RTI_INT32 RTIOsapi_global_lock();

extern RTIOsapiDllExport RTI_INT32 RTIOsapi_global_unlock();


#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* osapi_semaphore_h */
